unit uJxdVidGrab;

{$ALIGN ON}
{$Z4}
{$OPTIMIZATION OFF}

interface
uses Windows, Messages, Classes, ActiveX, Controls, ComCtrls, Graphics, ExtCtrls, MMSystem, ComObj,
     CommCtrl, Jpeg, Forms, Balancer;

const
   TVideoGrabberVersion =

{(((((((((((((((((((((((((((((((((((((((O))))))))))))))))))))))))))))))))))))))}
{
{                                 TVideoGrabber
{                                                                              }
                   'v1.0 2010-06-09 terry make';
{
{
{       Copyright ?005 Datastead - Michel Fornengo. All rights reserved.
{
{  home page : http://www.datastead.com
{  contact   : WestMediaSystems@Jan West
{  support   : support@datastead.com
{
{(((((((((((((((((((((((((((((((((((((((O)))))))))))))))))))))))))))))))))))))))


                     TVIDEOGRABBER LICENSE AGREEMENT
                     ===============================
 Copyright
 ---------
 All Datastead Ltd. software products are copyrighted
 by Michel Fornengo (hereafter "author"), and shall remain the
 exclusive property of the author.

 Agreement
 ---------
 By installing this software you agree with:

 - You may not use the source code in this package to create competitive
   software product (in this case a competitive video capture component).

 - You  may not manipulate any binary files included or generated by
   Delphi/C++Builder using the package.

 - You may not distribute source code or binaries to non registered people.

 License statement
 -----------------
 This software and any accompanying documentation are protected
 by France copyright law and also by International Treaty provisions.

 Any use of this software in violation of copyright law or the terms
 of this agreement will be prosecuted to the best of the author's ability.

 You are hereby authorized to make archival copies of this software
 for the sole purpose of back-up and protecting your investment from loss.

 Under no circumstances may you copy this software or documentation for the
 purposes of distribution to others. Under no conditions may you remove
 the copyright notices made part of the software or documentation.

 Distribution Rights
 -------------------
 You are granted a non-exclusive, royalty-free right to produce and distribute
 executable binary files (executables, DLLs, etc.) that are built with the
 registered version of the software, unless specifically stated otherwise.

 The origin of this software must not be misrepresented, you must not claim that
 you wrote the original software. If you use this software in a product, an
 acknowledgment in the product documentation would be appreciated but is not required.

 Restrictions
 ------------
 Without the express prior written consent of the author, you may not distribute
 any of the author's commercial source code, compiled units or documentation
 by any means whatsoever. You may not transfer, lease, lend, copy, modify,
 translate , sublicense, time-share , or electronically transmit or receive
 the software or documentation.

 Upgrade
 -------
 The upgrade version of the software constitutes a SingleText product of the
 author's software that you upgraded. For example, the upgrade and the software
 that you upgraded cannot both be available for use by two different people
 at the same time, without written permission from the author.

 Disclaimer
 ----------
 The Author cannot and does not warrant that any functions contained
 in the Software will meet your requirements, or that its operations
 will be error free. The entire risk as to the Software performance
 or quality, or both, is solely with the user and not the Author.
 You assume responsibility for the selection of the component to
 achieve your intended results, and for the installation, use, and
 results obtained from the Software.

 The Author makes no warranty, either implied or expressed, including
 without limitation any warranty with respect to this Software
 documented here, its quality, performance, or fitness for a particular
 purpose. In no event shall the Author be liable to you for damages,
 whether direct or indirect, incidental, special, or consequential
 arising out the use of or any defect in the Software,  even if the
 Author has been advised of the possibility of such damages, or for
 any claim by any other party.

 All other warranties of any kind, either express or implied,
 including but not limited to the implied warranties of
 merchantability and fitness for a particular purpose, are expressly
 excluded.
}

   APPNAME = 'JxdVideoGrabber';

type

{$DEFINE DELPHI_OR_BCB_6_AND_GREATER}

{$IFDEF VER120}
   {$DEFINE DELPHI_OR_BCB_4}
   {$UNDEF DELPHI_OR_BCB_6_AND_GREATER}
{$ENDIF VER120}

{$IFDEF VER125}
   {$DEFINE DELPHI_OR_BCB_4}
   {$UNDEF DELPHI_OR_BCB_6_AND_GREATER}
{$ENDIF VER125}

{$IFDEF VER130}
   {$DEFINE DELPHI_OR_BCB_5}
   {$UNDEF DELPHI_OR_BCB_6_AND_GREATER}
{$ENDIF VER130}

{$IFDEF VER135}
   {$DEFINE DELPHI_OR_BCB_5}
   {$UNDEF DELPHI_OR_BCB_6_AND_GREATER}
{$ENDIF VER135}

{$IFDEF DELPHI_OR_BCB_6_AND_GREATER}
   {$WARNINGS OFF}
   {WARN SYMBOL_PLATFORM OFF}
{$ENDIF DELPHI_OR_BCB_6_AND_GREATER}

{$IFDEF DELPHI_OR_BCB_4}
   TOleEnum = type LongInt;
   pBoolean = ^Boolean;
{$ENDIF DELPHI_OR_BCB_4}

{$IFDEF DELPHI_OR_BCB_5}
   pBoolean = ^Boolean;
{$ENDIF DELPHI_OR_BCB_5}

   int_64 = int64;


{$HPPEMIT 'typedef __int64 Int_64;'}
{$HPPEMIT 'DECLARE_DINTERFACE_TYPE(IEnumMoniker)'}
{$HPPEMIT 'DECLARE_DINTERFACE_TYPE(IBindCtx)'}

   TFrameGrabber          = (fg_BothStreams, fg_PreviewStream, fg_CaptureStream, fg_Disabled);
   TFrameGrabberRGBFormat = (fgf_Default, fgf_RGB32, fgf_RGB24, fgf_RGB565, fgf_RGB555, fgf_RGB8);
   TAutoFileName          = (fn_Sequential, fn_DateTime);
   TCompressionMode       = (cm_NoCompression, cm_CompressOnTheFly, cm_CompressAfterRecording);
   TCompressionType       = (ct_Video, ct_Audio, ct_AudioVideo);
   TCurrentState          = (cs_Down, cs_Preview, cs_Recording, cs_Playback, cs_Reencoding);
   TFrameCaptureDest      = (fc_TBitmap, fc_BmpFile, fc_JpegFile);
   TCrossbarSelector      = (cs_VideoCrossbar, cs_AudioCrossbar);
   TDVSize                = (dvFull, dvHalf, dvQuarter, dvDC);
   TDVVideoStandard       = (dvPAL, dvNTSC);
   TDVVideoFormat         = (dvDVSD, dvDVHD, dvDVSL);
   TDVCommand            = (dv_Play,
                             dv_Stop,
                             dv_Freeze,
                             dv_Thaw,
                             dv_Ff,
                             dv_Rew,
                             dv_Record,
                             dv_RecordFreeze,
                             dv_RecordStrobe,
                             dv_StepFwd,
                             dv_StepRev,
                             dv_ModeShuttle,
                             dv_PlayFastestFwd,
                             dv_PlaySlowestFwd,
                             dv_PlayFastestRev,
                             dv_PlaySlowestRev);

   TDialog = (
      dlg_VideoDevice,
      dlg_VideoCompressor,
      dlg_AudioCompressor,
      dlg_StreamConfig,
      dlg_VfwFormat,
      dlg_VfwSource,
      dlg_vfwDisplay,
      dlg_VideoCrossbar,
      dlg_AudioCrossbar,
      dlg_TVTuner,
      dlg_TVAudio,
      dlg_AudioDevice
   );

   TDialogs = set of TDialog;

   TTriState = (ts_Undefined, ts_False, ts_True);

   TLogoLayout = (lg_Centered, lg_Stretched, lg_Repeated);

   TNotificationMethod = (nm_Timer, nm_Thread);

   TVideoControl = (
     vc_FlipHorizontal,
     vc_FlipVertical,
     vc_ExternalTriggerEnable,
     vc_Trigger
   );

   TVideoRotation = (
      rt_0_deg,
      rt_90_deg,
      rt_180_deg,
      rt_270_deg,
      rt_0_deg_mirror,
      rt_90_deg_mirror,
      rt_180_deg_mirror,
      rt_270_deg_mirror
   );

   TVideoDeinterlacing = (
      di_Disabled,
      di_HalfSize,
      di_FullSize
   );

  TVideoControlSet = set of TVideoControl;

  TSampleCapture = (sc_Disabled, sc_Unsplitted, sc_Native, sc_AfterOnDraw, sc_AfterCompression);
  TThirdPartyFilterList = (tpf_VideoSource, tpf_VideoPreview, tpf_VideoCapture, tpf_AudioSource, tpf_AudioRender, tpf_AudioRecording);
  TFormatType = (ft_VideoInfo, ft_VideoInfo2, ft_DvInfo, ft_Mpeg1Video, ft_Mpeg2Video, ft_MpegStreamType, ft_MpegCustom, ft_WaveFormatEx, ft_Unknown);

  TAudioFormat     =(af_default,
                     af_8000_8b_1ch,
                     af_8000_8b_2ch,
                     af_8000_16b_1ch,
                     af_8000_16b_2ch,
                     af_11025_8b_1ch,
                     af_11025_8b_2ch,
                     af_11025_16b_1ch,
                     af_11025_16b_2ch,
                     af_16000_8b_1ch,
                     af_16000_8b_2ch,
                     af_16000_16b_1ch,
                     af_16000_16b_2ch,
                     af_22050_8b_1ch,
                     af_22050_8b_2ch,
                     af_22050_16b_1ch,
                     af_22050_16b_2ch,
                     af_32000_8b_1ch,
                     af_32000_8b_2ch,
                     af_32000_16b_1ch,
                     af_32000_16b_2ch,
                     af_44100_8b_1ch,
                     af_44100_8b_2ch,
                     af_44100_16b_1ch,
                     af_44100_16b_2ch,
                     af_48000_8b_1ch,
                     af_48000_8b_2ch,
                     af_48000_16b_1ch,
                     af_48000_16b_2ch);

   TVideoRenderer = (vr_AutoSelect, vr_VMR9, vr_VMR7, vr_StandardRenderer, vr_None);

   TVideoSource = (vs_VideoCaptureDevice,
                   vs_VideoFileOrURL,
                   vs_IPCamera,
                   vs_VideoFromImages,
                   vs_VideoFromBitmaps,
                   vs_ExternalSource
                   );

   TASFDeinterlaceMode = (
      adm_NotInterlaced,
      adm_DeinterlaceNormal,
      adm_DeinterlaceHalfSize,
      adm_DeinterlaceHalfSizeDoubleRate,
      adm_DeinterlaceInverseTelecine,
      adm_DeinterlaceVerticalHalfSizeDoubleRate
    );


   TFileSort = (fs_TimeAsc, fs_TimeDesc, fs_NameAsc, fs_NameDesc);

   TTunerInputType =(
     TunerInputCable,
     TunerInputAntenna
   );

   TCameraControl = (
      cc_Pan,
      cc_Tilt,
      cc_Roll,
      cc_Zoom,
      cc_Exposure,
      cc_Iris,
      cc_Focus
   );

   TVideoQuality = (
    vq_Brightness,
    vq_Contrast,
    vq_Hue,
    vq_Saturation,
    vq_Sharpness,
    vq_Gamma,
    vq_WhiteBalance,
    vq_Gain,
    vq_ColorEnable,
    vq_BacklightCompensation
   );

   TPin_Direction = (
     PINDIR_INPUT,
     PINDIR_OUTPUT
   );

   pDVDateTime = ^TDVDateTime;
   TDVDateTime = record
      IsAvailable: Boolean;
      Year: LongInt;
      Month: LongInt;
      Day: LongInt;
      Hour: LongInt;
      Minute: LongInt;
      Second: LongInt;
   end;

   pDVTimeCode = ^TDVTimeCode;
   TDVTimeCode = record
      IsAvailable: Boolean;
      Hour: LongInt;
      Min: LongInt;
      Sec: LongInt;
      Ff: LongInt;
      TrackNumber: LongInt;
   end;

   TRecordingMethod = (rm_AVI, rm_ASF, rm_Stream);

   TNetworkStreaming = (ns_Disabled, ns_ASFDirectNetworkStreaming, ns_ASFStreamingToPublishingPoint);

  pVideoHdr = ^TVideoHdr;
  TVideoHdr = record
     lpData: pByte;
     dwBufferLength: LongWord;
     dwBytesUsed: LongWord;
     dwTimeCaptured: LongWord;
     dwUser: LongWord;
     dwFlags: LongWord;
     dwReserved: array[0..3] of pLongWord;
  end;

   pFrameInfo = ^TFrameInfo;
   TFrameInfo = record
      FrameNumber: LongInt;
      DroppedFrameCount: LongInt;
      SampleTime_TotalMin: LongInt;
      SampleTime_Hour: LongInt;
      SampleTime_Min: LongInt;
      SampleTime_Sec: LongInt;
      SampleTime_Hs: LongInt;
      DVDateTime: TDVDateTime;
      DVTimeCode: TDVTimeCode;
      Reserved: LongInt;
      FrameTime: int64;
      SampleTime_TotalSec: int64;
      SampleTime_TotalHs: int64;
   end;

   TTVChannelInfo = record
      Channel: LongInt;
      Locked: Boolean;
      DefaultVideoFrequency: LongInt;
      OverriddenVideoFrequency: LongInt;
      TunerVideoFrequency: LongInt;
      TunerAudioFrequency: LongInt;
   end;

   TProgressInfo = record
      Percent: LongInt;
      Position: int64;
      Duration: int64;
      Comment: String;
   end;

   TSampleData = record
      SampleBuffer: pByte;
      SampleBufferSize: LongInt;
      SampleDataLength: LongInt;
      FormatType: TFormatType;
      pFormat: pointer;
      pbmi: pBitmapInfoHeader;
      SampleStartTime: int64;
      SampleEndTime: int64;
   end;

const
   MULTIPLEXEDSLAVE_MINBOUND = 0;
   MULTIPLEXEDSLAVE_MAXBOUND = 3;
type
   TMultiplexedRole = (mr_NotMultiplexed, mr_MultiplexedMaster, mr_MultiplexedSlave);

   TMpegStreamType = (mpst_Default, mpst_Program, mpst_Program_DVD, mpst_Program_DVD_MC, mpst_Program_SVCD, mpst_MPEG1, mpst_MPEG1_VCD);

   pFrameData = ^TFrameData;
   TFrameData = record
      Bitmap: TBitmap;
      FrameNumber: LongInt;
      DibSection: TDibSection;
      FrameTime: int64;
   end;

   TLogType = (
      e_add_filter,
      e_add_source_filter,
      e_audio_compressor_not_suitable,
      e_bind_moniker_to_filter,
      e_compressor_possibly_not_suited,
      e_create_instance,
      e_ddraw_caps_not_suitable,
      e_device_in_use_in_another_graph,
      e_disk_full,
      e_failed,
      e_failed_to_allocate_recording_file,
      e_failed_to_bind_codec,
      e_failed_to_connect_crossbar_pin,
      e_failed_to_connect_to_server,
      e_failed_to_create_directory,
      e_failed_to_create_file,
      e_failed_to_create_temp,
      e_failed_to_bind_frame_grabber,
      e_failed_to_load_ASF_profile,
      e_failed_to_load_ASF_profile_custom_file,
      e_failed_to_load_set_of_bitmaps,
      e_failed_to_play_backwards,
      e_failed_to_render_file,
      e_failed_to_renew_recording_file,
      e_failed_to_set_player_speed_ratio_with_audio,
      e_failed_to_setup_network_streaming,
      e_failed_to_start_preview,
      e_failed_to_start_recording,
      e_file_in_use,
      e_file_name_not_specified,
      e_file_not_found,
      e_get_audio_format,
      e_get_interface,
      e_get_video_format,
      e_graph_error,
      e_graph_must_be_restarted,
      e_hw_deinterlace_not_supported,
      e_incompatible_options,
      e_index_out_of_range,
      e_invalid_directory,
      e_library_not_found,
      e_load_filter,
      e_no_audio_input_device,
      e_no_device_available,
      e_no_dialog_for_this_compressor,
      e_no_stream_control,
      e_no_tv_tuner,
      e_no_video_device_selected,
      e_no_video_input_device,
      e_not_allowed_during_network_streaming,
      e_not_assigned,
      e_not_multiplexed_master,
      e_not_previewing,
      e_not_recording,
      e_not_reencoding,
      e_not_streaming,
      e_pause_resume_disabled,
      e_pin_not_found,
      e_query_config_avi_mux,
      e_reencoding,
      e_recording_cannot_pause,
      e_render_audio_stream,
      e_render_video_stream,
      e_must_restart_master,
      e_recording_on_motion_failed,
      e_set_filter_graph,
      e_set_interleaving_mode,
      e_set_master_stream,
      e_set_output_compatibility_index,
      e_set_output_file_name,
      e_set_format,
      e_start_preview_first,
      e_stop_player_first,
      e_stop_preview_first,
      e_stop_recording_first,
      e_stop_reencoding_first,
      e_storage_path_read_only,
      e_streaming_type_not_specified,
      e_third_party_filter_already_inserted,
      e_third_party_filter_error,
      e_trace_log,
      e_tv_command_not_allowed_during_tv_tuning,
      e_tuner_input_not_selected,
      e_TVideoGrabber_Filter_obsolete,
      e_value_out_of_range,
      e_video_compressor_not_suitable,
      e_window_transparency_failed,
      i_audio_device_associated_to_video_device,
      i_begin_discovering_device,
      i_binding_device_or_compressor,
      i_discovering_device,
      i_end_discovering_device,
      i_preallocated_file_size_large_enough,
      i_preallocated_file_size_changed,
      i_preallocated_file_not_suitable,
      i_streaming_to_publishing_point,
      i_third_party_filter_inserted,
      i_using_ASF_Profile,
      i_recording_videosubtype,
      w_cannot_connect_thirdparty_filter,
      w_cannot_connect_thirdparty_renderer,
      w_cannot_instantiate_thirdparty_filter,
      w_cannot_route_audio_crossbar,
      w_cannot_use_color_key,
      w_does_not_apply_to_dv,
      w_find_audio_device,
      w_filter_does_not_save_properties,
      w_frame_grabber_requires_CPU,
      w_hold_recording,
      w_information,
      w_not_playing,
      w_player_audio_should_be_disabled,
      w_recording_cancelled_by_user,
      w_can_pause_and_ASF_incompatible,
      w_set_audio_format,
      w_storage_path_on_network,
      w_tv_tuner,
      w_using_nearest_video_size,
      w_divx_codec_not_installed
   );

type
   TRegistryRoot = (RR_HKEY_CURRENT_USER, RR_HKEY_LOCAL_MACHINE);

   TTextOverlayAlign      = (tf_Left, tf_Center, tf_Right);

   TVideoWindowNotify = (vwActive, vwAutoSize, vwEmbedded, vwFullScreen, vwKeepAspectRatio, vwStayOnTop, vwMouseMovesWindow, vwVideoPortEnabled, vwMonitor, vwVideoWidth, vwVideoHeight, vwWidth, vwHeight, vwLeft, vwTop, vwLocation);

  {$IFNDEF TPPAGESAVINTF}
  {$DEFINE TPPAGESAVINTF}
   {$HINTS OFF}

   TPropertyPageSaverBase = class (TCustomControl)
   private
      FAssociated: TComponent;

      function CreateNewInstance (Owner: TComponent): TPropertyPageSaverBase; virtual; abstract;
      function Activate (pIUnknown: Variant): Boolean; virtual; abstract;
      procedure Deactivate; virtual; abstract;
      function IsActive: Boolean; virtual; abstract;
      function RestoreProperties: Boolean; virtual; abstract;
      function ShowDialog: Boolean; virtual; abstract;
      function SaveProperties: Boolean; virtual; abstract;
      function GetPropertiesState: String; virtual; abstract;
      function GetProperty (PropertyId: String): String; virtual; abstract;
      function SetProperty (PropertyId: String; Value: String): Boolean; virtual; abstract;
      function ClearProperties: Boolean; virtual; abstract;

      function GetRegistryRoot: TRegistryRoot; virtual; abstract;
      function GetRegistryKey: String; virtual; abstract;
      function GetRegistrySubKey: String; virtual; abstract;
      function GetSelectPages: String; virtual; abstract;
      function GetDialogTitle: String; virtual; abstract;
      function GetDialogPosition: TPosition; virtual; abstract;
      function GetIdentifyProperties: Boolean; virtual; abstract;

      procedure SetRegistryRoot (Value: TRegistryRoot) ; virtual; abstract;
      procedure SetRegistryKey (Value: String); virtual; abstract;
      procedure SetRegistrySubKey (Value: String); virtual; abstract;
      procedure SetDialogTitle (Value: String); virtual; abstract;
      procedure SetDialogPosition (Value: TPosition); virtual; abstract;
      procedure SetIdentifyProperties (Value: Boolean); virtual; abstract;
      procedure SetSelectPages (Value: String); virtual; abstract;
   end;

   {$HINTS ON}
  {$ENDIF TPPAGESAVINTF}

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{                                                                              }
{                TVIDEOGRABBER main class (derived from TCustomPanel)
{                                                                              }
{………………………………………………………………………………………………………………………………………………………………………………………………………………}

   TEventNotification = procedure (Sender: TObject)
   of object;
   TOnLog = procedure (Sender: TObject; LogType: TLogType; Severity: string; InfoMsg: string)
   of object;
   TOnSourceFileToDestFileStarted = procedure (Sender: TObject; SourceFile, DestFile: String)
   of object;
   TOnSourceFileToDestFileCompleted = procedure (Sender: TObject; SourceFile, DestFile: String; Success: Boolean)
   of object;
   TOnFileNotification = procedure (Sender: TObject; FileName: String)
   of object;
   TOnCreatePreallocatedFileCompleted = procedure (Sender: TObject; FileName: String; Success: Boolean)
   of object;
   TOnProcessCompleted = procedure (Sender: TObject; Success: Boolean)
   of object;
   TOnResizeVideo = procedure (Sender: TObject; SourceWidth, SourceHeight: LongInt)
   of object;
   TOnRecordingCompleted = procedure (Sender: TObject; FileName: string; Success: Boolean)
   of object;
   TOnVideoFromBitmaps_FormatNeeded = procedure (Sender: TObject;
   var BitmapHandle: HBITMAP)
   of object;
   TOnVideoFromBitmaps_NextFrameNeeded = procedure (Sender: TObject;
   var BitmapHandle: HBITMAP;
   var EndOfData: Boolean)
   of object;
   TOnDVCommandCompleted = procedure (Sender: TObject; NewStateValue: LongInt; NewStateLabel: String)
   of object;
   TOnDeviceArrivalOrRemoval = procedure (Sender: TObject; IsDeviceArrival: Boolean; IsVideoDevice: Boolean; DeviceName: string; DeviceIndex: LongInt)
   of object;
   TOnPlayerBufferingData = procedure (Sender: TObject; StartingToBuffer: Boolean)
   of object;
   TOnDirectNetworkStreamingHostUrl = procedure (Sender: TObject; HostUrl: String; HostName: String; HostPort: LongInt)
   of object;
   TOnVideoCompressionSettings = procedure (Sender: TObject; CanKeyFrameRate: Boolean; CanPFramesPerKeyFrame: Boolean; CanQuality: Boolean; CanWindowSize: Boolean; DefaultFrameRate: LongInt; DefaultPFramesPerKey: LongInt; DefaultQuality: Double)
   of object;
   TOnColorKeyChange = procedure (Sender: TObject; ColorKey: TColor)
   of object;
   TOnTVChannelScanStarted = procedure (Sender: TObject; MinChannel: LongInt; MaxChannel: LongInt)
   of object;
   TOnThirdPartyFilterConnected = procedure (Sender: TObject; Location: TThirdPartyFilterList; Index: LongInt; Intf: IUnknown)
   of object;

   TOnFrameProgress = procedure (Sender: TObject; const FrameInfo: TFrameInfo)
   of object;
   TOnProgress = procedure (Sender: TObject; const ProgressInfo: TProgressInfo)
   of object;
   TOnFrameCaptureCompleted = procedure (Sender: TObject; const FrameData: TFrameData; DestType: TFrameCaptureDest; FileName: string; Success: Boolean)
   of object;
   TOnFrameOverlayUsingDC = procedure (Sender: TObject; const FrameInfo: TFrameInfo; Dc: HDC)
   of object;
   TOnFrameOverlayUsingVIDEOHDR = procedure (Sender: TObject; const FrameInfo: TFrameInfo; const VideoHdr: TVideoHdr)
   of object;
   TOnFrameOverlayUsingDIB = procedure (Sender: TObject; const FrameInfo: TFrameInfo; DibSection: pDIBSECTION)
   of object;
   TOnVideoKeyPress = procedure (Sender: TObject; VideoWindow: LongInt; var Key: Char; PhysicalKey: LongInt; ShiftState: TShiftState)
   of object;
   TOnVideoMouseUpDown = procedure (Sender: TObject; VideoWindow: LongInt; Button: TMouseButton; Shift: TShiftState; X, Y: LongInt)
   of object;
   TOnVideoMouseMove = procedure (Sender: TObject; VideoWindow: LongInt; Shift: TShiftState; X, Y: LongInt)
   of object;
   TOnTVChannelSelected = procedure (Sender: TObject; const ChannelInfo: TTVChannelInfo)
   of object;
   TOnSampleCapture = procedure (Sender: TObject; const SampleData: TSampleData)
   of object;
   TOnMotionDetected = procedure (Sender: TObject; GlobalMotionRatio: Double; FrameData: TFrameData; var CaptureFrame: Boolean)
   of object;
   TOnMotionNotDetected = procedure (Sender: TObject; FrameData: TFrameData; var CaptureFrame: Boolean)
   of object;


   TJxdVideoGrabber = class (TCustomPanel)

   private
      _Vdgr: pointer;
      _VdgrInitialized: Boolean;


      FOnAudioDeviceSelected: TEventNotification;
      FOnBacktimedFramesCountReached: TEventNotification;
      FOnClick: TEventNotification;
      FOnDblClick: TEventNotification;
      FOnVideoDeviceSelected: TEventNotification;
      FOnFrameProgress: TOnFrameProgress;
      FOnRecordingReadyToStart: TEventNotification;
      FOnRecordingCompleted: TOnRecordingCompleted;
      FOnVideoFromBitmaps_FormatNeeded: TOnVideoFromBitmaps_FormatNeeded;
      FOnVideoFromBitmaps_NextFrameNeeded: TOnVideoFromBitmaps_NextFrameNeeded;
      FOnRecordingStarted: TOnFileNotification;
      FOnColorKeyChange: TOnColorKeyChange;
      FOnCopyPreallocDataCompleted: TOnSourceFileToDestFileCompleted;
      FOnCopyPreallocDataProgress: TOnProgress;
      FOnCopyPreallocDataStarted: TOnSourceFileToDestFileStarted;
      FOnCreatePreallocFileStarted: TOnFileNotification;
      FOnCreatePreallocFileProgress: TOnProgress;
      FOnCreatePreallocFileCompleted: TOnCreatePreallocatedFileCompleted;
      FOnDeviceArrivalOrRemoval: TOnDeviceArrivalOrRemoval;
      FOnDeviceLost: TEventNotification;
      FOnDirectNetworkStreamingHostUrl: TOnDirectNetworkStreamingHostUrl;
      FOnDiskFull: TEventNotification;
      FOnFrameOverlayUsingDC: TOnFrameOverlayUsingDC;
      FOnFrameOverlayUsingDIB: TOnFrameOverlayUsingDIB;
      FOnFrameOverlayUsingVIDEOHDR: TOnFrameOverlayUsingVIDEOHDR;
      FOnInactive: TEventNotification;
      FOnLog: TOnLog;
      FOnFrameCaptureCompleted: TOnFrameCaptureCompleted;
      FOnDVCommandCompleted: TOnDVCommandCompleted;
      FOnKeyPress: TOnVideoKeyPress;
      FOnMouseDown: TOnVideoMouseUpDown;
      FOnMouseMove: TOnVideoMouseMove;
      FOnMouseUp: TOnVideoMouseUpDown;
      FOnNoVideoDevices: TEventNotification;
      FOnPlayerEndOfStream: TEventNotification;
      FOnPlayerBufferingData: TOnPlayerBufferingData;
      FOnPlayerOpened: TEventNotification;
      FOnPreviewStarted: TEventNotification;
      FOnSampleCapture_Audio: TOnSampleCapture;
      FOnSampleCapture_Video: TOnSampleCapture;
      FOnReencodingCompleted: TOnSourceFileToDestFileCompleted;
      FOnReencodingProgress: TOnProgress;
      FOnBitmapsLoadingProgress: TOnProgress;
      FOnReencodingStarted: TOnSourceFileToDestFileStarted;
      FOnResizeVideo: TOnResizeVideo;
      FOnReinitializing: TEventNotification;
      FOnTVChannelSelected: TOnTVChannelSelected;
      FOnTVChannelScanCompleted: TEventNotification;
      FOnTVChannelScanStarted: TOnTVChannelScanStarted;
      FOnThirdPartyFilterConnected: TOnThirdPartyFilterConnected;
      FOnVideoCompressionSettings: TOnVideoCompressionSettings;

      FOnMotionDetected: TOnMotionDetected;
      FOnMotionNotDetected: TOnMotionNotDetected;



      function  GetASFAudioBitRate: LongInt;
      function  GetASFAudioChannels: LongInt;
      function  GetASFDeinterlaceMode: TASFDeinterlaceMode;
      function  GetASFFixedFrameRate: Boolean;
      {function  GetASFJPEGCompressionQuality: LongInt;} // not yet implemented
      function  GetASFMediaServerPublishingPoint: String;
      function  GetASFNetworkPort: LongInt;
      function  GetASFNetworkMaxUsers: LongInt;
      function  GetASFProfile: Integer;
      function  GetASFProfileFromCustomFile: string;
      function  GetASFVideoBitRate: LongInt;
      function  GetASFVideoHeight: LongInt;
      function  GetASFVideoMaxKeyFrameSpacing: LongInt;
      function  GetASFVideoQuality: LongInt;
      function  GetASFVideoWidth: LongInt;
      function  GetNetworkStreaming: TNetworkStreaming;
      function  GetAssociateAudioAndVideoDevices: Boolean;
      function  GetAudioDevice: LongInt;
      function  GetAudioDeviceRendering: Boolean;
      function  GetAudioFormat: TAudioFormat;
      function  GetAudioRecording: Boolean;
      function  GetAutoConnectRelatedPins: Boolean;
      function  GetAutoFileName: TAutoFileName;
      function  GetAutoFilePrefix: string;
      function  GetAutoRefreshPreview: Boolean;
      function  GetAutoStartPlayer: Boolean;
      function  GetAutoStartPreview: Boolean;
      function  GetAVIFormatOpenDML: Boolean;
      function  GetBackgroundColor: TColor;
      function  GetBorderStyle: TBorderStyle;
      function  GetBurstCount: LongInt;
      function  GetBurstInterval: LongInt;
      function  GetBurstMode: Boolean;
      function  GetBurstType: TFrameCaptureDest;
      function  GetBusyCursor: TCursor;
      function  GetCameraControlSettings: Boolean;
      function  GetCaptureFileExt: string;
      function  GetColorKeyEnabled: Boolean;
      function  GetCompressionMode: TCompressionMode;
      function  GetCompressionType: TCompressionType;
      function  GetDisplayBoolProperties (Index: LongInt): Boolean;
      function  GetDisplayLongIntProperties (Index: LongInt): LongInt;
      function  GetDisplay2LongIntProperties (Index: LongInt): LongInt;
      function  GetDisplay2BoolProperties (Index: LongInt): Boolean;
      function  GetDroppedFrameCount: LongInt;
      function  GetDVRgb219: Boolean;
      function  GetDVReduceFrameRate: Boolean;
      function  GetEventNotificationSynchrone: Boolean;
      function  GetFrameCaptureWithoutOverlay: Boolean;
      function  GetFrameCaptureZoomSize: LongInt;
      function  GetFrameGrabber: TFrameGrabber;
      function  GetFrameGrabberRGBFormat: TFrameGrabberRGBFormat;
      function  GetHoldRecording: Boolean;
      function  GetJPEGPerformance: TJPEGPerformance;
      function  GetJPEGProgressiveDisplay: Boolean;
      function  GetJPEGQuality: TJPEGQualityRange;
      function  GetLogoDisplayed: Boolean;
      function  GetLogoLayout: TLogoLayout;
      function  GetMotionDetector_Grid: string;
      function  GetMotionDetector_ReduceVideoNoise: Boolean;
      function  GetMotionDetector_CompareBlue: Boolean;
      function  GetMotionDetector_CompareGreen: Boolean;
      function  GetMotionDetector_CompareRed: Boolean;
      function  GetMotionDetector_GreyScale: Boolean;
      function  GetMotionDetector_Enabled: Boolean;
      function  GetMotionDetector_MaxDetectionsPerSecond: Double;
      function  GetMotionDetector_ReduceCPULoad: LongInt;
      function  GetMuteAudioRendering: Boolean;
      function  GetMultiplexedRole: TMultiplexedRole;
      function  GetMultiplexedSlaveID (Index: LongInt): LongInt;
      function  GetMultiplexedSlaveFrameRate: Double;
      function  GetNormalCursor: TCursor;
      function  GetNotificationMethod: TNotificationMethod;
      function  GetNotificationSleepTime: LongInt;
      function  GetNotificationPriority: TThreadPriority;
      function  GetPlayerAudioRendering: Boolean;
      function  GetPlayerDVSize: TDVSize;
      function  GetPlayerFastSeekSpeedRatio: LongInt;
      function  GetPlayerFileName: string;
      function  GetPlayerForcedCodec: String;
      function  GetPlayerRefreshPausedDisplay: Boolean;
      function  GetPlayerSpeedRatio: double;
      function  GetPlayerTrackBar: TTrackBar;
      function  GetPreallocCapFileCopiedAfterRecording: Boolean;
      function  GetPreallocCapFileEnabled: Boolean;
      function  GetPreallocCapFileName: string;
      function  GetPreallocCapFileSizeInMB: LongInt;
      function  GetPreviewZoomSize: LongInt;
      function  GetRecordingFileName: string;
      function  GetRecordingInNativeFormat: Boolean;
      function  GetRecordingMethod: TRecordingMethod;
      function  GetRecordingOnMotion_Enabled: Boolean;
      function  GetRecordingOnMotion_MotionThreshold: Double;
      function  GetRecordingOnMotion_NoMotionPauseDelayMs: LongInt;
      function  GetReencodingIncludeAudioStream: Boolean;
      function  GetReencodingIncludeVideoStream: Boolean;
      function  GetReencodingMethod: TRecordingMethod;
      function  GetReencodingNewVideoClip: string;
      function  GetReencodingSourceVideoClip: String;
      function  GetReencodingStartTime: int_64;
      function  GetReencodingStopTime: int_64;
      function  GetReencodingUseAudioCompressor: Boolean;
      function  GetReencodingUseFrameGrabber: Boolean;
      function  GetReencodingUseVideoCompressor: Boolean;
      function  GetReencodingWMVOutput: Boolean;
      function  GetPropertyPageSaver: TComponent;
      function  GetSampleCapture_Audio: TSampleCapture;
      function  GetSampleCapture_Video: TSampleCapture;
      function  GetSampleCaptureAsyncEvent: Boolean;
      function  GetShapeOverlay: TShape;
      function  GetShapeOverlayEnabled: Boolean;
      function  GetSpeakerControl: Boolean;
      function  GetStoragePath: string;
      function  GetStoreDeviceSettingsInRegistry: Boolean;
      function  GetSynchronized: Boolean;
      function  GetTextOverlayAlign: TTextOverlayAlign;
      function  GetTextOverlayBkColor: TColor;
      function  GetTextOverlayEnabled: Boolean;
      function  GetTextOverlayFont: TFont;
      function  GetTextOverlayLeft: LongInt;
      function  GetTextOverlayRight: LongInt;
      function  GetTextOverlayString: string;
      function  GetTextOverlayTop: LongInt;
      function  GetTextOverlayTransparent: Boolean;
      function  GetTimeCodeReaderAvailable: Boolean;
      function  GetTranslateMouseCoordinates: Boolean;
      function  GetTVUseFrequencyOverrides: Boolean;
      function  GetUniqueID: LongInt;
      function  GetVersion: String;
      function  GetVideoCompression_KeyFrameRate: LongInt;
      function  GetVideoCompression_PFramesPerKeyFrame: LongInt;
      function  GetVideoCompression_Quality: Double;
      function  GetVideoCompression_WindowSize: LongInt;
      function  GetVideoControlSettings: Boolean;
      function  GetVideoFromImages_RepeatIndefinitely: Boolean;
      function  GetVideoFromImages_SourceDirectory: String;
      function  GetVideoFromImages_BitmapsSortedBy: TFileSort;
      function  GetVideoFromImages_TemporaryFile: String;
      function  GetVideoDevice: LongInt;
      function  GetVideoProcessingBrightness: LongInt;
      function  GetVideoProcessingContrast: LongInt;
      function  GetVideoProcessingDeinterlacing: TVideoDeinterlacing;
      function  GetVideoProcessingGrayScale: Boolean;
      function  GetVideoProcessingHue: LongInt;
      function  GetVideoProcessingInvertColors: Boolean;
      function  GetVideoProcessingLeftRight: Boolean;
      function  GetVideoProcessingRotation: TVideoRotation;
      function  GetVideoProcessingSaturation: LongInt;
      function  GetVideoProcessingTopDown: Boolean;
      function  GetVideoQualitySettings: Boolean;
      function  GetVideoRenderer: TVideoRenderer;
      function  GetVideoSource: TVideoSource;
      function  GetVideoSource_FileOrURL: String;
      function  GetVideoSource_FileOrURL_StartTime: int_64;
      function  GetVideoSource_FileOrURL_StopTime: int_64;
      procedure SetASFAudioBitRate (Value: LongInt);
      procedure SetASFAudioChannels (Value: LongInt);
      procedure SetASFDeinterlaceMode (Value: TASFDeinterlaceMode);
      procedure SetASFFixedFrameRate (Value: Boolean);
      {procedure SetASFJPEGCompressionQuality (Value: LongInt);} // not yet implemented
      procedure SetASFMediaServerPublishingPoint (Value: String);
      procedure SetASFNetworkPort (Value: LongInt);
      procedure SetASFNetworkMaxUsers (Value: LongInt);
      procedure SetASFProfile (Value: Integer);
      procedure SetASFProfileFromCustomFile (Value: string);
      procedure SetASFVideoBitRate (Value: LongInt);
      procedure SetASFVideoHeight (Value: LongInt);
      procedure SetASFVideoMaxKeyFrameSpacing (Value: LongInt);
      procedure SetASFVideoQuality (Value: LongInt);
      procedure SetASFVideoWidth (Value: LongInt);
      procedure SetAssociateAudioAndVideoDevices (Value: Boolean);
      procedure SetAudioCompressor (Value: LongInt);
      procedure SetAudioDevice (Value: LongInt);
      procedure SetAudioDeviceRendering (Value: Boolean);
      procedure SetAudioFormat (Value: TAudioFormat);
      procedure SetAudioRecording (Value: Boolean);
      procedure SetAutoConnectRelatedPins (Value: Boolean);
      procedure SetAutoFileName (Value: TAutoFileName);
      procedure SetAutoFilePrefix (Value: string);
      procedure SetAutoRefreshPreview (Value: Boolean);
      procedure SetAutoStartPlayer (Value: Boolean);
      procedure SetAutoStartPreview (Value: Boolean);
      procedure SetAVIFormatOpenDML (Value: Boolean);
      procedure SetBackgroundColor (Value: TColor);
      procedure SetBorderStyle (Value: TBorderStyle);
      procedure SetBurstCount (Value: LongInt);
      procedure SetBurstInterval (Value: LongInt);
      procedure SetBurstMode (Value: Boolean);
      procedure SetBurstType (Value: TFrameCaptureDest);
      procedure SetBusyCursor (Value: TCursor);
      procedure SetCameraControlSettings (Value: Boolean);
      procedure SetCaptureFileExt (Value: string);
      procedure SetColorKeyEnabled (Value: Boolean);
      procedure SetCompressionMode (Value: TCompressionMode);
      procedure SetCompressionType (Value: TCompressionType);
      procedure SetDisplayBoolProperties (Index: LongInt; Value: Boolean);
      procedure SetDisplayLongIntProperties (Index: LongInt; Value: LongInt);
      procedure SetDisplay2BoolProperties (Index: LongInt; Value: Boolean);
      procedure SetDisplay2LongIntProperties (Index: LongInt; Value: LongInt);
      procedure SetDVReduceFrameRate (Value: Boolean);
      procedure SetDVRgb219 (value: Boolean);
      procedure SetEventNotificationSynchrone (Value: Boolean);
      procedure SetFrameCaptureWithoutOverlay (Value: Boolean);
      procedure SetFrameCaptureZoomSize (Value: LongInt);
      procedure SetFrameBuffers (Value: LongInt);
      procedure SetFrameGrabber (Value: TFrameGrabber);
      procedure SetFrameGrabberRGBFormat (Value: TFrameGrabberRGBFormat);
      procedure SetHoldRecording (Value: Boolean);
      procedure SetJPEGPerformance (Value: TJPEGPerformance);
      procedure SetJPEGProgressiveDisplay (Value: Boolean);
      procedure SetJPEGQuality (Value: TJPEGQualityRange);
      procedure SetLogoDisplayed (Value: Boolean);
      procedure SetLogoLayout (Value: TLogoLayout);
      procedure SetMotionDetector_Grid (Value: string);
      procedure SetMotionDetector_CompareBlue (Value: Boolean);
      procedure SetMotionDetector_CompareGreen (Value: Boolean);
      procedure SetMotionDetector_GreyScale (Value: Boolean);
      procedure SetMotionDetector_CompareRed (Value: Boolean);
      procedure SetMotionDetector_Enabled (Value: Boolean);
      procedure SetMotionDetector_MaxDetectionsPerSecond (Value: Double);
      procedure SetMotionDetector_ReduceVideoNoise (Value: Boolean);
      procedure SetMotionDetector_ReduceCPULoad (Value: LongInt);
      procedure SetMultiplexedRole (Value: TMultiplexedRole);
      procedure SetMultiplexedSlaveID (Index: LongInt; Value: LongInt);
      procedure SetMultiplexedSlaveFrameRate (Value: Double);
      procedure SetMuteAudioRendering (Value: Boolean);
      procedure SetNetworkStreaming (Value: TNetworkStreaming);
      procedure SetNormalCursor (Value: TCursor);
      procedure SetNotificationMethod (Value: TNotificationMethod);
      procedure SetNotificationSleepTime (Value: LongInt);
      procedure SetNotificationPriority (Value: TThreadPriority);
      procedure SetOnFrameOverlayUsingDC (Value: TOnFrameOverlayUsingDC);
      procedure SetPlayerAudioRendering (Value: Boolean);
      procedure SetPlayerDVSize (Value: TDVSize);
      procedure SetPlayerFastSeekSpeedRatio (Value: LongInt);
      procedure SetPlayerFileName (Value: string);
      procedure SetPlayerForcedCodec (Value: String);
      procedure SetPlayerRefreshPausedDisplay (Value: Boolean);
      procedure SetPlayerSpeedRatio (Value: Double);
      procedure SetPlayerTrackBar (Value: TTrackBar);
      procedure SetPreallocCapFileCopiedAfterRecording (Value: Boolean);
      procedure SetPreallocCapFileEnabled (Value: Boolean);
      procedure SetPreallocCapFileName (Value: string);
      procedure SetPreallocCapFileSizeInMB (Value: LongInt);
      procedure SetPreviewZoomSize (Value: LongInt);
      procedure SetPropertyPageSaver (Value: TComponent);
      procedure SetRecordingFileName (Value: string);
      procedure SetRecordingInNativeFormat (value: Boolean);
      procedure SetRecordingMethod (Value: TRecordingMethod);
      procedure SetRecordingOnMotion_Enabled (Value: Boolean);
      procedure SetRecordingOnMotion_MotionThreshold (Value: Double);
      procedure SetRecordingOnMotion_NoMotionPauseDelayMs (Value: LongInt);
      procedure SetReencodingNewVideoClip (Value:  string);
      procedure SetReencodingSourceVideoClip (Value:  String);
      procedure SetReencodingStartTime (Value:  int_64);
      procedure SetReencodingStopTime (Value:  int_64);
      procedure SetReencodingIncludeAudioStream (Value:  Boolean);
      procedure SetReencodingIncludeVideoStream (Value:  Boolean);
      procedure SetReencodingMethod (Value: TRecordingMethod);
      procedure SetReencodingUseAudioCompressor (Value:  Boolean);
      procedure SetReencodingUseFrameGrabber (Value:  Boolean);
      procedure SetReencodingUseVideoCompressor (Value:  Boolean);
      procedure SetReencodingWMVOutput (Value: Boolean);
      procedure SetSampleCapture_Audio (Value: TSampleCapture);
      procedure SetSampleCapture_Video (Value: TSampleCapture);
      procedure SetSampleCaptureAsyncEvent (Value: Boolean);
      procedure SetShapeOverlay (Value: TShape);
      procedure SetShapeOverlayEnabled (Value: Boolean);
      procedure SetSpeakerControl (Value: Boolean);
      procedure SetStoragePath (Value: string);
      procedure SetStoreDeviceSettingsInRegistry (Value: Boolean);
      procedure SetSynchronized (Value: Boolean);
      procedure SetTextOverlayAlign (Value: TTextOverlayAlign);
      procedure SetTextOverlayBkColor (Value: TColor);
      procedure SetTextOverlayEnabled (Value: Boolean);
      procedure SetTextOverlayFont (Value: TFont);
      procedure SetTextOverlayLeft (Value: LongInt);
      procedure SetTextOverlayRight (Value: LongInt);
      procedure SetTextOverlayString (Value: string);
      procedure SetTextOverlayTop (Value: LongInt);
      procedure SetTextOverlayTransparent (Value: Boolean);
      procedure SetTranslateMouseCoordinates (Value: Boolean);
      procedure SetTVUseFrequencyOverrides (Value: Boolean);
      //procedure SetUploadToDV_Device (Value: LongInt);
      procedure SetUniqueID (Value: LongInt);
      procedure SetVersion (Value: string);
      procedure SetVideoCompression_KeyFrameRate (Value:LongInt);
      procedure SetVideoCompression_PFramesPerKeyFrame (Value:LongInt);
      procedure SetVideoCompression_Quality (Value:Double);
      procedure SetVideoCompression_WindowSize (Value: LongInt);
      procedure SetVideoControlSettings (Value: Boolean);
      procedure SetVideoDevice (Value: LongInt);
      procedure SetVideoFromImages_SourceDirectory (Value: String);
      procedure SetVideoFromImages_TemporaryFile (Value: String);
      procedure SetVideoFromImages_BitmapsSortedBy (Value: TFileSort);
      procedure SetVideoFromImages_RepeatIndefinitely (Value: Boolean);
      procedure SetVideoProcessingBrightness (Value: LongInt);
      procedure SetVideoProcessingContrast (Value: LongInt);
      procedure SetVideoProcessingDeinterlacing (Value: TVideoDeinterlacing);
      procedure SetVideoProcessingGrayScale (Value: Boolean);
      procedure SetVideoProcessingHue (Value: LongInt);
      procedure SetVideoProcessingInvertColors (Value: Boolean);
      procedure SetVideoProcessingLeftRight (Value: boolean);
      procedure SetVideoProcessingRotation (Value: TVideoRotation);
      procedure SetVideoProcessingSaturation (Value: LongInt);
      procedure SetVideoProcessingTopDown (Value: boolean);
      procedure SetVideoQualitySettings (Value: Boolean);
      procedure SetVideoSource (Value: TVideoSource);
      procedure SetVideoSource_FileOrURL (Value: String);
      procedure SetVideoSource_FileOrURL_StartTime (Value: int_64);
      procedure SetVideoSource_FileOrURL_StopTime (Value: int_64);
      procedure SetVideoRenderer (Value: TVideoRenderer);

      function  GetAnalogVideoStandard: LongInt;
      function  GetAnalogVideoStandards: string;
      function  GetAnalogVideoStandardsCount: LongInt;
      function  GetASFProfiles: String;
      function  GetASFProfilesCount: LongInt;
      function  GetAudioCompressor: LongInt;
      function  GetAudioCompressorName: string;
      function  GetAudioInputBalance: LongInt;
      function  GetAudioInputLevel: LongInt;
      function  GetAudioInputMono: Boolean;
      function  GetAudioInput: LongInt;
      function  GetAudioInputs: string;
      function  GetAudioInputsCount: LongInt;
      function  GetAudioDeviceName: string;
      function  GetAudioFormats: string;
      function  GetBusy: Boolean;
      function  GetCameraControlAuto: Boolean;
      function  GetRecordingDuration: Double;
      function  GetRecordingFourCC: string;
      function  GetCurrentFrameRate: Double;
      function  GetCurrentState: TCurrentState;
      function  GetDeliveredFrames: int_64;
      function  GetDisplay_VideoHeight: LongInt;
      function  GetDisplay_VideoWidth: LongInt;
      function  GetDisplay_VideoWindowHandle: HWND;
      function  GetDualDisplay_VideoHeight: LongInt;
      function  GetDualDisplay_VideoWidth: LongInt;
      function  GetDualDisplay_VideoWindowHandle: HWND;
      function  GetFrameBuffers: LongInt;
      function  GetFrameGrabberCurrentRGBFormat: TFrameGrabberRGBFormat;
      function  GetFrameGrabberSynchrone: Boolean;
      function  GetFrameRate: Double;
      function  GetGlobal_AudioCompressors: string;
      function  GetGlobal_AudioCompressorsCount: LongInt;
      function  GetGlobal_AudioDevices: string;
      function  GetGlobal_AudioDevicesCount: LongInt;
      function  GetGlobal_VideoCompressors: string;
      function  GetGlobal_VideoCompressorsCount: LongInt;
      function  GetGlobal_VideoDevices: string;
      function  GetGlobal_VideoDevicesCount: LongInt;
      function  GetImageRatio: double;
      function  GetInFrameProgressEvent: Boolean;
      function  GetIsAnalogVideoDecoderAvailable: Boolean;
      function  GetIsAudioCrossbarAvailable: Boolean;
      function  GetIsAudioDeviceASoundCard: Boolean;
      function  GetIsAudioInputBalanceAvailable: TTriState;
      function  GetIsCameraControlAvailable: Boolean;
      function  GetIsDigitalVideoIn: Boolean;
      function  GetIsDVCommandAvailAvailable: Boolean;
      function  GetIsHorizontalSyncLocked: Boolean;
      function  GetIsMpegStream: Boolean;
      function  GetIsPlayerAudioStreamAvailable: TTriState;
      function  GetIsPlayerPaused: Boolean;
      function  GetIsPlayerPlaying: Boolean;
      function  GetIsRecordingPaused: Boolean;
      function  GetIsTVAudioAvailable: Boolean;
      function  GetIsTVAutoTuneRunning: Boolean;
      function  GetIsTVTunerAvailable: Boolean;
      function  GetIsVideoControlAvailable: Boolean;
      function  GetIsVideoCrossbarAvailable: Boolean;
      function  GetIsVideoQualityAvailable: Boolean;
      function  GetIsVideoPortAvailable: Boolean;
      function  GetIsVideoInterlaced: Boolean;
      function  GetIsWDMVideoDriver: Boolean;
      function  GetLast_BurstFrameCapture_FileName: string;
      function  GetLast_CaptureFrameTo_FileName: string;
      function  GetLast_Recording_FileName: string;
      function  GetLast_Clip_Played: String;
      function  GetMotionDetector_GlobalMotionRatio: Double;
      function  GetMotionDetector_GridXCount: LongInt;
      function  GetMotionDetector_GridYCount: LongInt;
      function  GetMotionDetector_IsGridValid: Boolean;
      function  GetMpegStreamType: TMpegStreamType;
      function  GetParentWindow: HWnd;
      function  GetPlayerDuration: int_64;
      function  GetPlayerAudioCodec: String;
      function  GetPlayerFrameCount: int_64;
      function  GetPlayerFramePosition: int_64;
      function  GetPlayerTimePosition: int_64;
      function  GetPlayerFrameRate: double;
      function  GetPlayerVideoCodec: String;
      function  GetRecordingBacktimedFramesCount: LongInt;
      function  GetRecordingCanPause: Boolean;
      function  GetRecordingHeight: LongInt;
      function  GetRecordingWidth: LongInt;
      //function  GetShowDialogs: TDialogs;
      function  GetSpeakerBalance: LongInt;
      function  GetSpeakerVolume: LongInt;
      function  GetStreamingURL: string;
      function  GetSystemTempPath: string;
      function  GetTVChannel: LongInt;
      function  GetTVCountryCode: LongInt;
      function  GetTVChannelInfo: TTVChannelInfo;
      function  GetTVTunerInputType: TTunerInputType;
      function  GetVCRHorizontalLocking: Boolean;
      function  GetVideoCompressor: LongInt;
      function  GetVideoCompressorName: string;
      function  GetVideoInput: LongInt;
      function  GetVideoInputs: string;
      function  GetVideoInputsCount: LongInt;
      function  GetVideoDeviceName: string;
      function  GetVideoQualityAuto: Boolean;
      function  GetVideoSourceHeight: LongInt;
      function  GetVideoSourceWidth: LongInt;
      function  GetVideoSize: LongInt;
      function  GetVideoSizes: string;
      function  GetVideoSizesCount: LongInt;
      function  GetVideoSubtype: LongInt;
      function  GetVideoSubtypes: string;
      function  GetVideoSubtypesCount: LongInt;

      /////////////////////////////////////////////////////// HERE

      procedure SetAnalogVideoStandard (Value: LongInt);
      procedure SetAudioInput (Value: LongInt);
      procedure SetAudioInputBalance (Value: LongInt);
      procedure SetAudioInputLevel (Value: LongInt);
      procedure SetAudioInputMono (Value: Boolean);
      procedure SetCameraControlAuto (Value: Boolean);
      procedure SetFrameGrabberSynchrone (Value: Boolean);
      procedure SetFrameRate (Value: Double);
      procedure SetMpegStreamType (Value: TMpegStreamType);
      procedure SetParentWindow(Value: HWnd);
      procedure SetPlayerFramePosition (Value: int_64);
      procedure SetPlayerTimePosition (Value: int_64);
      procedure SetRecordingBacktimedFramesCount (Value: LongInt);
      procedure SetRecordingCanPause (Value: Boolean);
      //procedure SetShowDialogs (Value: TDialogs);
      procedure SetSpeakerBalance (Value: LongInt);
      procedure SetSpeakerVolume (Value: LongInt);
      procedure SetTVChannel (Value: LongInt);
      procedure SetTVCountryCode (Value: LongInt);
      procedure SetTVTunerInputType (Value: TTunerInputType);
      procedure SetVCRHorizontalLocking (Value: Boolean);
      procedure SetVideoCompressor (Value: LongInt);
      procedure SetVideoInput (Value: LongInt);
      procedure SetVideoQualityAuto (Value: Boolean);
      procedure SetVideoSize (Value: LongInt);
      procedure SetVideoSubtype (Value: LongInt);

   public


      function  AMTVTunerAutoTune(lChannel: LongInt; out plFoundSignal: LongInt): Boolean;
      function  AMTVTunerChannelMinMax(out lChannelMin, lChannelMax: LongInt): Boolean;
      function  AMTVTunerGetAvailableTVFormats(out lAnalogVideoStandard: LongInt): Boolean;
      function  AMTVTunerGetTVFormat(out plAnalogVideoStandard: LongInt): Boolean;
      function  AMTVTunerGetAudioFrequency(out lFreq: LongInt): Boolean;
      function  AMTVTunerGetAvailableModes(out plModes: LongInt): Boolean;
      function  AMTVTunerGetChannel(out lChannel, lVideoSubChannel, lAudioSubChannel: LongInt): Boolean;
      function  AMTVTunerGetConnectInput(out plIndex: LongInt): Boolean;
      function  AMTVTunerGetCountryCode(out lCountryCode: LongInt): Boolean;
      function  AMTVTunerGetInputType(lIndex: LongInt; out InputType: TTunerInputType): Boolean;
      function  AMTVTunerGetMode(out plMode: dword): Boolean;
      function  AMTVTunerGetNumInputConnections(out plNumInputConnections: LongInt): Boolean;
      function  AMTVTunerGetTuningSpace(out lTuningSpace: LongInt): Boolean;
      function  AMTVTunerGetVideoFrequency(out lFreq: LongInt): Boolean;
      function  AMTVTunerLogon(hCurrentUser: THandle): Boolean;
      function  AMTVTunerLogout: Boolean;
      function  AMTVTunerPutChannel(lChannel, lVideoSubChannel, lAudioSubChannel: LongInt): Boolean;
      function  AMTVTunerPutConnectInput(lIndex: LongInt): Boolean;
      function  AMTVTunerPutCountryCode(lCountryCode: LongInt): Boolean;
      function  AMTVTunerPutInputType(lIndex: LongInt; InputType: TTunerInputType): Boolean;
      function  AMTVTunerPutMode(lMode: dword): Boolean;
      function  AMTVTunerPutTuningSpace(lTuningSpace: LongInt): Boolean;
      function  AMTVTunerSignalPresent(out plSignalStrength: LongInt): Boolean;
      function  AMTVTunerStoreAutoTune: Boolean;

      procedure About;
      function  CameraControlDefault (Setting: TCameraControl): LongInt;
      function  CameraControlMin (Setting: TCameraControl): LongInt;
      function  CameraControlMax (Setting: TCameraControl): LongInt;
      function  CameraControlStep (Setting: TCameraControl): LongInt;
      function  Cancel: Boolean;
      function  CaptureFrameTo (Dest: TFrameCaptureDest; FileName: String): Boolean;
      function  CaptureFrameSyncTo (Dest: TFrameCaptureDest; FileName: String): Boolean;
      procedure ClosePlayer;
      function  CreatePreallocCapFile: Boolean;
      function  CrossbarCanConnectInput (Crossbar: TCrossbarSelector; InputIndex, OutputIndex: LongInt): Boolean;
      function  CrossbarConnectInput (Crossbar: TCrossbarSelector; InputIndex, OutputIndex: LongInt): Boolean;
      function  CrossbarGetPInBounds (Crossbar: TCrossbarSelector; var InputCount, OutputCount: LongInt): Boolean;
      function  CrossbarGetPinInfo (Crossbar: TCrossbarSelector; PinDirection: TPin_Direction; Index: LongInt; var IndexRelated: LongInt; var PhysicalType: LongInt; var PhysicalTypestring: string): Boolean;
      function  CrossbarGetInputConnected (Crossbar: TCrossbarSelector; OutputIndex: LongInt; var InputIndex: LongInt): Boolean;
      procedure Display_SetLocation (WindowLeft, WindowTop, WindowWidth, WindowHeight: LongInt);
      procedure DualDisplay_SetLocation (WindowLeft, WindowTop, WindowWidth, WindowHeight: LongInt);
      function  DrawBitmapOverFrame (Bitmap: Graphics.TBitmap; LeftLocation: LongInt; TopLocation: LongInt; bmWidth: LongInt; bmHeight: LongInt): Boolean;
      procedure FastForwardPlayer;
      function  FindIndexInListByName (List: String; SearchedString: String; IsSubString: boolean; IgnoreCase: Boolean): LongInt;
      function  GetCameraControl (Setting: TCameraControl): LongInt;
      procedure GetNearestVideoSize (PreferredVideoWidth: LongInt; PreferredVideoHeight: LongInt; var NearestVideoWidth: LongInt; var NearestVideoHeight: LongInt);
      function  GetVideoCompressionSettings (var DataRate, KeyFrameRate, PFramesPerKeyFrame, WindowSize: LongInt; var Quality: Double; var CanQuality, CanCrunch, CanKeyFrame, CanBFrame, CanWindow: Boolean): Boolean;
      function  GetVideoQuality (Setting: TVideoQuality): LongInt;
      function  GetVideoSizeFromIndex (VideoSizeIndex: LongInt; var VideoWidth: LongInt; var VideoHeight: LongInt): Boolean;
      function  IsCameraControlSettingAvailable (Setting: TCameraControl): Boolean;
      function  IsDialogAvailable (Dialog: TDialog): Boolean;
      function  IsVideoQualitySettingAvailable (Setting: TVideoQuality) : Boolean;
      function  IsVideoControlModeAvailable (Mode: TVideoControl): Boolean;

      function  MotionDetector_CellMotionRatio (x, y: LongInt): Double;
      function  MotionDetector_Get2DTextGrid: string;
      function  MotionDetector_Get2DTextMotion: string;
      function  MotionDetector_GetCellSensitivity (x, y: LongInt; var Value: LongInt): Boolean;
      function  MotionDetector_SetCellSensitivity (x, y, Value: LongInt): Boolean;

      function  MotionDetector_SetGridSize (x, y: LongInt): Boolean;
      procedure MotionDetector_GloballyIncOrDecSensitivity (Value: integer);
      procedure MotionDetector_ResetGlobalSensitivity (Value: integer);
      procedure MotionDetector_Reset;
      procedure MotionDetector_ShowGridDialog;
      function  MotionDetector_EnumGridDialogControls (FirstControl: Boolean): TComponent;

      function  OpenPlayer: Boolean;

      //modify by Terry at 2010-06-12 for changed MTV audio channel
      procedure TerryTest(const Ab: Boolean);
      function Test3: boolean;
      //end modify

      function  PauseRecording: Boolean;
      procedure PausePlayer;
      function  ReencodeVideoClip (SourceVideoClip: String; NewVideoClip: string; IncludeVideoStream, IncludeAudioStream, UseFrameGrabber, UseCurrentVideoCompressor, UseCurrentAudioCompressor: Boolean): Boolean;
      function  AVIDuration (AVIFile: String; var Duration: int_64; var FrameCount: int_64): Boolean;
      function  ResumeRecording: Boolean;
      procedure RewindPlayer;
      procedure RunPlayer;
      procedure RunPlayerBackwards;
      function  AnalogVideoStandardIndex (Value: String): LongInt;
      function  AudioCompressorIndex (Value: String): LongInt;
      function  AudioDeviceIndex (Value: String): LongInt;
      function  AudioInputIndex (Value: String): LongInt;
      function  VideoCompressorIndex (Value: String): LongInt;
      function  VideoDeviceIndex (Value: String): LongInt;
      function  VideoInputIndex (Value: String): LongInt;
      function  VideoSizeIndex (Value: String): LongInt;
      function  VideoSubtypeIndex (Value: String): LongInt;
      function  SendDVCommand (DVCommand: TDVCommand): Boolean;
      function  SetCameraControl (Setting: TCameraControl; NewValue: LongInt) : Boolean;
      procedure SetColorKeys (LowestRGBColorValue: TColor; HighestRGBColorValue: TColor);
      procedure SetTextOverlayCustomVar (VarIndex: LongInt; VarText: String);
      function  SetVideoCompressionDefaults: Boolean;
      function  SetVideoCompressionSettings (DataRate, KeyFrameRate, PFramesPerKeyFrame, WindowSize: LongInt; Quality: Double): Boolean;
      function  SetVideoControlMode (Mode: TVideoControlSet): Boolean;
      function  SetVideoQuality (Setting: TVideoQuality; NewValue: LongInt) : Boolean;
      function  ShapeOverlayList (Shape: TShape; Add: Boolean): Boolean;
      function  ShowDialog  (Dialog: TDialog): Boolean;
      function  PausePreview: Boolean;
      //function  PropertyPageSaver_SetProperty (Dialog: TDialog; PropertyIdentifier: String; PropertyValue: String): Boolean;
      //function  PropertyPageSaver_GetProperty (Dialog: TDialog; PropertyIdentifier: String): String;
      function  ResetPreview: Boolean;
      function  ResumePreview: Boolean;
      function  SetLogoFromBMPFile (FileName: string): Boolean;
      function  SetLogoFromJPEGFile (FileName: string): Boolean;
      function  SetLogoFromHBitmap  (Bitmap: HBITMAP): Boolean;
      function  SetLogoFromTBitmap  (Bitmap: TBitmap): Boolean;
      function  SetLogoFromImage  (Image: TImage): Boolean;
      function  StartPreview: Boolean;
      function  StartRecording: Boolean;
      function  StartReencoding: Boolean;
      function  Stop: Boolean;
      procedure StopPreview;
      procedure StopPlayer;
      procedure StopRecording;
      function  StopReencoding: Boolean;
      function  ThirdPartyFilter_AddToList (Location: TThirdPartyFilterList; GUID: TGUID; Name: string; Enable: Boolean; SaveFilterState: Boolean): LongInt;
      function  ThirdPartyFilter_ClearList (Location: TThirdPartyFilterList): Boolean;
      function  ThirdPartyFilter_Enable (Location: TThirdPartyFilterList; Index: LongInt; Enable: Boolean): Boolean;
      function  ThirdPartyFilter_RemoveFromList (Location: TThirdPartyFilterList; Index: LongInt): Boolean;
      function  ThirdPartyFilter_ShowDialog (Location: TThirdPartyFilterList; Index: LongInt): Boolean;
      function  TVGetMinMaxChannels (var MinChannel: LongInt; var MaxChannel: LongInt): Boolean;
      function  TVClearFrequencyOverrides: Boolean;
      function  TVSetChannelFrequencyOverride (TVChannel: LongInt; FrequencyInHz: LongInt): LongInt;
      function  TVStartAutoScan: Boolean;
      function  TVStopAutoScan: Boolean;
      procedure UseNearestVideoSize (PreferredWidth, PreferredHeight: LongInt; Stretch: Boolean);
      function  VDECGetHorizontalLocked(out plLocked: LongInt): Boolean;
      function  VDECGetNumberOfLines(out plNumberOfLines: LongInt): Boolean;
      function  VDECGetOutputEnable(out plOutputEnable: LongInt): Boolean;
      function  VDECGetVCRHorizontalLocking(out plVCRHorizontalLocking: LongInt): Boolean;
      function  VDECPutTVFormat(lAnalogVideoStandard: LongInt): Boolean;
      function  VDECPutOutputEnable(lOutputEnable: LongInt): Boolean;
      function  VDECPutVCRHorizontalLocking(lVCRHorizontalLocking: LongInt): Boolean;

      function  VideoFromImages_CreateSetOfBitmaps: Boolean;

      function  VideoQualityDefault (Setting: TVideoQuality): LongInt;
      function  VideoQualityMin (Setting: TVideoQuality): LongInt;
      function  VideoQualityMax (Setting: TVideoQuality): LongInt;
      function  VideoQualityStep (Setting: TVideoQuality): LongInt;



   protected
      procedure Loaded; override;
      procedure Paint; override;
      procedure WndProc (var Msg: TMessage); override;
      procedure WMERASEBKGND (var Message: TWMERASEBKGND); message WM_ERASEBKGND;
      procedure Notification(AComponent: TComponent; Operation: TOperation); override;
      procedure SetParent(AParent: TWinControl); override;
   public
      constructor Create (Aowner: TComponent); override;
      destructor  Destroy; override;

      property AnalogVideoStandard: LongInt read GetAnalogVideoStandard write SetAnalogVideoStandard;
      property AnalogVideoStandards: string read GetAnalogVideoStandards;
      property AnalogVideoStandardsCount: LongInt read GetAnalogVideoStandardsCount;
      property ASFProfiles: String read GetASFProfiles;
      property ASFProfilesCount: LongInt read GetASFProfilesCount;
      property AudioCompressor: LongInt read GetAudioCompressor write SetAudioCompressor;
      property AudioCompressorName: string read GetAudioCompressorName;
      property AudioCompressors: string read GetGlobal_AudioCompressors;
      property AudioCompressorsCount: LongInt read GetGlobal_AudioCompressorsCount;
      property AudioInputBalance: LongInt read GetAudioInputBalance write SetAudioInputBalance;
      property AudioInputLevel: LongInt read GetAudioInputLevel write SetAudioInputLevel;
      property AudioInputMono: Boolean read GetAudioInputMono write SetAudioInputMono;
      property AudioInput: LongInt read GetAudioInput write SetAudioInput;
      property AudioInputs: string read GetAudioInputs;
      property AudioInputsCount: LongInt read GetAudioInputsCount;
      property AudioDeviceName: string read GetAudioDeviceName;
      property AudioDevices: string read GetGlobal_AudioDevices;
      property AudioDevicesCount: LongInt read GetGlobal_AudioDevicesCount;
      property AudioFormats: string read GetAudioFormats;
      property Busy: Boolean read GetBusy;
      property CameraControlAuto: Boolean read GetCameraControlAuto write SetCameraControlAuto;
      property RecordingDuration: Double read GetRecordingDuration;
      property RecordingFourCC: String read GetRecordingFourCC;
      property CurrentFrameRate: Double read GetCurrentFrameRate;
      property CurrentState: TCurrentState read GetCurrentState;
      property DeliveredFrames: int_64 read GetDeliveredFrames;
      property Display_VideoHeight: LongInt read GetDisplay_VideoHeight;
      property Display_VideoWidth: LongInt read GetDisplay_VideoWidth;
      property Display_VideoWindowHandle: Hwnd read GetDisplay_VideoWindowHandle;
      property DroppedFrames: LongInt read GetDroppedFrameCount;
      property DualDisplay_VideoHeight: LongInt  read GetDualDisplay_VideoHeight;
      property DualDisplay_VideoWidth: LongInt  read GetDualDisplay_VideoWidth;
      property DualDisplay_VideoWindowHandle: Hwnd read GetDualDisplay_VideoWindowHandle;
      property FrameBuffers: LongInt read GetFrameBuffers write SetFrameBuffers;
      property FrameGrabberCurrentRGBFormat: TFrameGrabberRGBFormat read GetFrameGrabberCurrentRGBFormat;
      property FrameGrabberSynchrone: Boolean read GetFrameGrabberSynchrone write SetFrameGrabberSynchrone;
      property FrameRate: Double read GetFrameRate write SetFrameRate;
      property ImageRatio: Double read GetImageRatio;
      property InFrameProgressEvent: Boolean read GetInFrameProgressEvent;
      property IsAnalogVideoDecoderAvailable: Boolean read GetIsAnalogVideoDecoderAvailable;
      property IsAudioCrossbarAvailable: Boolean read GetIsAudioCrossbarAvailable;
      property IsAudioDeviceASoundCard: Boolean read GetIsAudioDeviceASoundCard;
      property IsAudioInputBalanceAvailable: TTriState read GetIsAudioInputBalanceAvailable;
      property IsCameraControlAvailable: Boolean read GetIsCameraControlAvailable;
      property IsDigitalVideoIn: Boolean read GetIsDigitalVideoIn;
      property IsDVCommandAvailable: Boolean read GetIsDVCommandAvailAvailable;
      property IsHorizontalSyncLocked: Boolean read GetIsHorizontalSyncLocked;
      property IsMpegStream: Boolean read GetIsMpegStream;
      property IsPlayerAudioStreamAvailable: TTriState read GetIsPlayerAudioStreamAvailable;
      property IsPlayerPaused: Boolean read GetIsPlayerPaused;
      property IsPlayerPlaying: Boolean read GetIsPlayerPlaying;
      property IsRecordingPaused: Boolean read GetIsRecordingPaused;
      property IsTimeCodeReaderAvailable: Boolean read GetTimeCodeReaderAvailable;
      property IsTVTunerAvailable: Boolean read GetIsTVTunerAvailable;
      property IsTVAutoTuneRunning: Boolean read GetIsTVAutoTuneRunning;
      property IsTVAudioAvailable: Boolean read GetIsTVAudioAvailable;
      property IsVideoControlAvailable: Boolean read GetIsVideoControlAvailable;
      property IsVideoCrossbarAvailable: Boolean read GetIsVideoCrossbarAvailable;
      property IsVideoInterlaced: Boolean read GetIsVideoInterlaced;
      property IsVideoQualityAvailable: Boolean read GetIsVideoQualityAvailable;
      property IsVideoPortAvailable: Boolean read GetIsVideoPortAvailable;
      property IsWDMVideoDriver: Boolean read GetIsWDMVideoDriver;
      property Last_BurstFrameCapture_FileName: string read GetLast_BurstFrameCapture_FileName;
      property Last_CaptureFrameTo_FileName: string read GetLast_CaptureFrameTo_FileName;
      property Last_Recording_FileName: string read GetLast_Recording_FileName;
      property Last_Clip_Played: string read GetLast_Clip_Played;
      property  MotionDetector_GlobalMotionRatio: Double read GetMotionDetector_GlobalMotionRatio;
      property  MotionDetector_GridXCount: LongInt read GetMotionDetector_GridXCount;
      property  MotionDetector_GridYCount: LongInt read GetMotionDetector_GridYCount;
      property  MotionDetector_IsGridValid: Boolean read GetMotionDetector_IsGridValid;
      property MpegStreamType: TMpegStreamType read GetMpegStreamType write SetMpegStreamType;
      property ParentWindow: HWnd read GetParentWindow write SetParentWindow;
      property PlayerAudioCodec: String read GetPlayerAudioCodec;
      property PlayerDuration: int_64 read GetPlayerDuration;
      property PlayerFrameCount: int_64 read GetPlayerFrameCount;
      property PlayerFramePosition: int_64 read GetPlayerFramePosition write SetPlayerFramePosition;
      property PlayerTimePosition: int_64 read GetPlayerTimePosition write SetPlayerTimePosition;
      property PlayerFrameRate: Double read GetPlayerFrameRate;
      property PlayerVideoCodec: String read GetPlayerVideoCodec;
      property RecordingBacktimedFramesCount: LongInt read GetRecordingBacktimedFramesCount write SetRecordingBacktimedFramesCount;
      property RecordingCanPause: Boolean read GetRecordingCanPause write SetRecordingCanPause;
      property RecordingHeight: LongInt read GetRecordingHeight;
      property RecordingWidth: LongInt read GetRecordingWidth;
      //property ShowDialogs: TDialogs read GetShowDialogs write SetShowDialogs;
      property SpeakerBalance: LongInt read GetSpeakerBalance write SetSpeakerBalance;
      property SpeakerVolume: LongInt read GetSpeakerVolume write SetSpeakerVolume;
      property StreamingURL: string read GetStreamingURL;
      property SystemTempPath: string read GetSystemTempPath;
      property TVChannel: LongInt read GetTVChannel write SetTVChannel;
      property TVCountryCode: LongInt read GetTVCountryCode write SetTVCountryCode;
      property TVChannelInfo: TTVChannelInfo read GetTVChannelInfo;
      property TVTunerInputType: TTunerInputType read GetTVTunerInputType write SetTVTunerInputType;
      property VCRHorizontalLocking: Boolean read GetVCRHorizontalLocking write SetVCRHorizontalLocking;
      property VideoCompressor: LongInt read GetVideoCompressor write SetVideoCompressor;
      property VideoCompressorName: string read GetVideoCompressorName;
      property VideoCompressors: string read GetGlobal_VideoCompressors;
      property VideoCompressorsCount: LongInt read GetGlobal_VideoCompressorsCount;
      property VideoInput: LongInt read GetVideoInput write SetVideoInput;
      property VideoInputs: string read GetVideoInputs;
      property VideoInputsCount: LongInt read GetVideoInputsCount;
      property VideoDeviceName: string read GetVideoDeviceName;
      property VideoDevices: string read GetGlobal_VideoDevices;
      property VideoDevicesCount: LongInt read GetGlobal_VideoDevicesCount;
      property VideoQualityAuto: Boolean read GetVideoQualityAuto write SetVideoQualityAuto;
      property VideoHeight: LongInt read GetVideoSourceHeight;
      property VideoWidth: LongInt read GetVideoSourceWidth;
      property VideoSize: LongInt read GetVideoSize write SetVideoSize;
      property VideoSizes: string read GetVideoSizes;
      property VideoSizesCount: LongInt read GetVideoSizesCount;
      property VideoSubtype: LongInt read GetVideoSubtype write SetVideoSubtype;
      property VideoSubtypes: string read GetVideoSubtypes;
      property VideoSubtypesCount: LongInt read GetVideoSubtypesCount;

   published
      property Align;
      property Alignment;
      property Caption;
      property Color;
      property Enabled;
      property FullRepaint;
      property Height;
      property Left;
      property ParentColor;
      property ParentShowHint;
      property PopupMenu;
      property Tag;
      property Top;
      property Visible;
      property Width;

      property OnResize;
      property OnDragDrop;
      property OnDragOver;
      property OnEndDrag;
      property OnStartDrag;

      property Anchors;
      property ParentBiDiMode;
      property OnCanResize;
      property OnConstrainedResize;

      {$IFNDEF DELPHI_OR_BCB_4}
      property OnContextPopup;
      {$ENDIF DELPHI_OR_BCB_4}

      property ASFAudioBitRate: LongInt read GetASFAudioBitRate write SetASFAudioBitRate;
      property ASFAudioChannels: LongInt read GetASFAudioChannels write SetASFAudioChannels;
      property ASFDeinterlaceMode: TASFDeinterlaceMode read GetASFDeinterlaceMode write SetASFDeinterlaceMode;
      property ASFFixedFrameRate: Boolean read GetASFFixedFrameRate write SetASFFixedFrameRate;
      {property ASFJPEGCompressionQuality: LongInt read GetASFJPEGCompressionQuality write SetASFJPEGCompressionQuality;} // not yet implemented
      property ASFMediaServerPublishingPoint: string read GetASFMediaServerPublishingPoint write SetASFMediaServerPublishingPoint;
      property ASFNetworkPort: LongInt read GetASFNetworkPort write SetASFNetworkPort;
      property ASFNetworkMaxUsers: LongInt read GetASFNetworkMaxUsers write SetASFNetworkMaxUsers;
      property ASFProfile: Integer read GetASFProfile write SetASFProfile;
      property ASFProfileFromCustomFile: string read GetASFProfileFromCustomFile write SetASFProfileFromCustomFile;
      property ASFVideoBitRate: LongInt read GetASFVideoBitRate write SetASFVideoBitRate;
      property ASFVideoHeight: LongInt read GetASFVideoHeight write SetASFVideoHeight;
      property ASFVideoMaxKeyFrameSpacing: LongInt read GetASFVideoMaxKeyFrameSpacing write SetASFVideoMaxKeyFrameSpacing;
      property ASFVideoQuality: LongInt read GetASFVideoQuality write SetASFVideoQuality;
      property ASFVideoWidth: LongInt read GetASFVideoWidth write SetASFVideoWidth;
      property NetworkStreaming: TNetworkStreaming read GetNetworkStreaming write SetNetworkStreaming;

      property AssociateAudioAndVideoDevices: Boolean read GetAssociateAudioAndVideoDevices write SetAssociateAudioAndVideoDevices;
      property AutoStartPreview: Boolean read GetAutoStartPreview write SetAutoStartPreview;
      property AudioDevice: LongInt read GetAudioDevice write SetAudioDevice;
      property AudioFormat: TAudioFormat read GetAudioFormat write SetAudioFormat;
      property AudioDeviceRendering: Boolean read GetAudioDeviceRendering write SetAudioDeviceRendering;
      property AudioRecording: Boolean read GetAudioRecording write SetAudioRecording;
      property AutoConnectRelatedPins: Boolean read GetAutoConnectRelatedPins write SetAutoConnectRelatedPins;
      property AutoFileName: TAutoFileName read GetAutoFileName write SetAutoFileName;
      property AutoFilePrefix: string read GetAutoFilePrefix write SetAutoFilePrefix;
      property AutoRefreshPreview: Boolean read GetAutoRefreshPreview write SetAutoRefreshPreview;
      property AutoStartPlayer: Boolean read GetAutoStartPlayer write SetAutoStartPlayer;
      property AVIFormatOpenDML: Boolean read GetAVIFormatOpenDML write SetAVIFormatOpenDML;
      property BackgroundColor: TColor read GetBackgroundColor write SetBackgroundColor;
      property BurstCount: LongInt read GetBurstCount write SetBurstCount;
      property BorderStyle: TBorderStyle read GetBorderStyle write SetBorderStyle;
      property BurstInterval: LongInt read GetBurstInterval write SetBurstInterval;
      property BurstMode: Boolean read GetBurstMode write SetBurstMode;
      property BurstType: TFrameCaptureDest read GetBurstType write SetBurstType;
      property BusyCursor: TCursor read GetBusyCursor write SetBusyCursor;
      property CameraControlSettings: Boolean read GetCameraControlSettings write SetCameraControlSettings;
      property CaptureFileExt: string read GetCaptureFileExt write SetCaptureFileExt;
      property ColorKeyEnabled: Boolean read GetColorKeyEnabled write SetColorKeyEnabled;
      property CompressionMode: TCompressionMode read GetCompressionMode write SetCompressionMode;
      property CompressionType: TCompressionType read GetCompressionType write SetCompressionType;
      property Display_Active: Boolean index vwActive read GetDisplayBoolProperties write SetDisplayBoolProperties;
      property Display_AutoSize: Boolean index vwAutosize read GetDisplayBoolProperties write SetDisplayBoolProperties;
      property Display_KeepAspectRatio: Boolean index vwKeepAspectRatio read GetDisplayBoolProperties write SetDisplayBoolProperties;
      property Display_Embedded: Boolean index vwEmbedded read GetDisplayBoolProperties write SetDisplayBoolProperties;
      property Display_FullScreen: Boolean index vwFullScreen read GetDisplayBoolProperties write SetDisplayBoolProperties;
      property Display_Height: LongInt index vwHeight read GetDisplayLongIntProperties write SetDisplayLongIntProperties;
      property Display_Left: LongInt index vwLeft read GetDisplayLongIntProperties write SetDisplayLongIntProperties;
      property Display_StayOnTop: Boolean index vwStayOnTop read GetDisplayBoolProperties write SetDisplayBoolProperties;
      property Display_Monitor: LongInt index vwMonitor read GetDisplayLongIntProperties write SetDisplayLongIntProperties;
      property Display_MouseMovesWindow: Boolean index vwMouseMovesWindow read GetDisplayBoolProperties write SetDisplayBoolProperties;
      property Display_Top: LongInt index vwTop read GetDisplayLongIntProperties write SetDisplayLongIntProperties;
      property Display_Width: LongInt index vwWidth read GetDisplayLongIntProperties write SetDisplayLongIntProperties;
      property Display_VideoPortEnabled: Boolean index vwVideoPortEnabled read GetDisplayBoolProperties write SetDisplayBoolProperties;
      property DualDisplay_Active: Boolean index vwActive read GetDisplay2BoolProperties write SetDisplay2BoolProperties;
      property DualDisplay_AutoSize: Boolean index vwAutosize read GetDisplay2BoolProperties write SetDisplay2BoolProperties;
      property DualDisplay_KeepAspectRatio: Boolean index vwKeepAspectRatio read GetDisplay2BoolProperties write SetDisplay2BoolProperties;
      property DualDisplay_Embedded: Boolean index vwEmbedded read GetDisplay2BoolProperties write SetDisplay2BoolProperties;
      property DualDisplay_FullScreen: Boolean index vwFullScreen read GetDisplay2BoolProperties write SetDisplay2BoolProperties;
      property DualDisplay_Height: LongInt index vwHeight read GetDisplay2LongIntProperties write SetDisplay2LongIntProperties;
      property DualDisplay_Left: LongInt index vwLeft read GetDisplay2LongIntProperties write SetDisplay2LongIntProperties;
      property DualDisplay_StayOnTop: Boolean index vwStayOnTop read GetDisplay2BoolProperties write SetDisplay2BoolProperties;
      property DualDisplay_Monitor: LongInt index vwMonitor read GetDisplay2LongIntProperties write SetDisplay2LongIntProperties;
      property DualDisplay_MouseMovesWindow: Boolean index vwMouseMovesWindow read GetDisplay2BoolProperties write SetDisplay2BoolProperties;
      property DualDisplay_Top: LongInt index vwTop read GetDisplay2LongIntProperties write SetDisplay2LongIntProperties;
      property DualDisplay_Width: LongInt index vwWidth read GetDisplay2LongIntProperties write SetDisplay2LongIntProperties;
      property DualDisplay_VideoPortEnabled: Boolean index vwVideoPortEnabled read GetDisplay2BoolProperties write SetDisplay2BoolProperties;
      (*property DVEncodingResolution: TDVSize read GetDVEncodingResolution write SetDVEncodingResolution;
      property DVEncodingVideoStandard: TDVVideoStandard read GetDVEncodingVideoStandard write SetDVEncodingVideoStandard;
      property DVEncodingVideoFormat: TDVVideoFormat read GetDVEncodingVideoFormat write SetDVEncodingVideoFormat;*)
      property DVRgb219: Boolean read GetDVRgb219 write SetDVRgb219;
      property DVReduceFrameRate: Boolean read GetDVReduceFrameRate write SetDVReduceFrameRate;
      property EventNotificationSynchrone: Boolean read GetEventNotificationSynchrone write SetEventNotificationSynchrone;
      property FrameCaptureWithoutOverlay: Boolean read GetFrameCaptureWithoutOverlay write SetFrameCaptureWithoutOverlay;
      property FrameCaptureZoomSize: LongInt read GetFrameCaptureZoomSize write SetFrameCaptureZoomSize;
      property FrameGrabber: TFrameGrabber read GetFrameGrabber write SetFrameGrabber;
      property FrameGrabberRGBFormat: TFrameGrabberRGBFormat read GetFrameGrabberRGBFormat write SetFrameGrabberRGBFormat;
      property HoldRecording: Boolean read GetHoldRecording write SetHoldRecording;
      property JPEGPerformance: TJPEGPerformance read GetJPEGPerformance write SetJPEGPerformance;
      property JPEGProgressiveDisplay: Boolean read GetJPEGProgressiveDisplay write SetJPEGProgressiveDisplay;
      property JPEGQuality: TJPEGQualityRange read GetJPEGQuality write SetJPEGQuality;
      property LogoDisplayed: Boolean read GetLogoDisplayed write SetLogoDisplayed;
      property LogoLayout: TLogoLayout read GetLogoLayout write SetLogoLayout;
      property MotionDetector_CompareBlue: Boolean read GetMotionDetector_CompareBlue write SetMotionDetector_CompareBlue;
      property MotionDetector_CompareGreen: Boolean read GetMotionDetector_CompareGreen write SetMotionDetector_CompareGreen;
      property MotionDetector_GreyScale: Boolean read GetMotionDetector_GreyScale write SetMotionDetector_GreyScale;
      property MotionDetector_CompareRed: Boolean read GetMotionDetector_CompareRed write SetMotionDetector_CompareRed;
      property MotionDetector_Enabled: Boolean read GetMotionDetector_Enabled write SetMotionDetector_Enabled;
      property MotionDetector_Grid: string read GetMotionDetector_Grid write SetMotionDetector_Grid;
      property MotionDetector_MaxDetectionsPerSecond: Double read GetMotionDetector_MaxDetectionsPerSecond write SetMotionDetector_MaxDetectionsPerSecond;
      property MotionDetector_ReduceCPULoad: LongInt read GetMotionDetector_ReduceCPULoad write SetMotionDetector_ReduceCPULoad;
      property MotionDetector_ReduceVideoNoise: Boolean read GetMotionDetector_ReduceVideoNoise write SetMotionDetector_ReduceVideoNoise;
      property MultiplexedRole: TMultiplexedRole read GetMultiplexedRole write SetMultiplexedRole;
      property MultiplexedSlaveFrameRate: Double read GetMultiplexedSlaveFrameRate write SetMultiplexedSlaveFrameRate;
      property MultiplexedSlave1ID: LongInt index 0 read GetMultiplexedSlaveID write SetMultiplexedSlaveID;
      property MultiplexedSlave2ID: LongInt index 1 read GetMultiplexedSlaveID write SetMultiplexedSlaveID;
      property MultiplexedSlave3ID: LongInt index 2 read GetMultiplexedSlaveID write SetMultiplexedSlaveID;
      property MultiplexedSlave4ID: LongInt index 3 read GetMultiplexedSlaveID write SetMultiplexedSlaveID;
      property MuteAudioRendering: Boolean read GetMuteAudioRendering write SetMuteAudioRendering;
      property NormalCursor: TCursor read GetNormalCursor write SetNormalCursor;
      property NotificationMethod: TNotificationMethod read GetNotificationMethod write SetNotificationMethod;
      property NotificationSleepTime: LongInt read GetNotificationSleepTime write SetNotificationSleepTime;
      property NotificationPriority: TThreadPriority read GetNotificationPriority write SetNotificationPriority;
      property PlayerAudioRendering: Boolean read GetPlayerAudioRendering write SetPlayerAudioRendering;
      property PlayerDVSize: TDVSize read GetPlayerDVSize write SetPlayerDVSize;
      property PlayerFastSeekSpeedRatio: LongInt read GetPlayerFastSeekSpeedRatio write SetPlayerFastSeekSpeedRatio;
      property PlayerFileName: string read GetPlayerFileName write SetPlayerFileName;
      property PlayerForcedCodec: string read GetPlayerForcedCodec write SetPlayerForcedCodec;
      property PlayerRefreshPausedDisplay: Boolean read GetPlayerRefreshPausedDisplay write SetPlayerRefreshPausedDisplay;
      property PlayerSpeedRatio: Double read GetPlayerSpeedRatio write SetPlayerSpeedRatio;
      property PlayerTrackBar: TTrackBar read GetPlayerTrackBar write SetPlayerTrackBar;
      property PreallocCapFileCopiedAfterRecording: Boolean read GetPreallocCapFileCopiedAfterRecording write SetPreallocCapFileCopiedAfterRecording;
      property PreallocCapFileEnabled: Boolean read GetPreallocCapFileEnabled write SetPreallocCapFileEnabled;
      property PreallocCapFileName: string read GetPreallocCapFileName write SetPreallocCapFileName;
      property PreallocCapFileSizeInMB: LongInt read GetPreallocCapFileSizeInMB write SetPreallocCapFileSizeInMB;
      property PreviewZoomSize: LongInt read GetPreviewZoomSize write SetPreviewZoomSize;
      property PropertyPageSaver: TComponent read GetPropertyPageSaver write SetPropertyPageSaver;
      property RecordingFileName: string read GetRecordingFileName write SetRecordingFileName;
      property RecordingInNativeFormat: Boolean read GetRecordingInNativeFormat write SetRecordingInNativeFormat;
      property RecordingMethod: TRecordingMethod read GetRecordingMethod write SetRecordingMethod;
      property RecordingOnMotion_Enabled: Boolean read GetRecordingOnMotion_Enabled write SetRecordingOnMotion_Enabled;
      property RecordingOnMotion_MotionThreshold: Double read GetRecordingOnMotion_MotionThreshold write SetRecordingOnMotion_MotionThreshold;
      property RecordingOnMotion_NoMotionPauseDelayMs: LongInt read GetRecordingOnMotion_NoMotionPauseDelayMs write SetRecordingOnMotion_NoMotionPauseDelayMs;
      property Reencoding_NewVideoClip: string read GetReencodingNewVideoClip write SetReencodingNewVideoClip;
      property Reencoding_SourceVideoClip: String read GetReencodingSourceVideoClip write SetReencodingSourceVideoClip;
      property Reencoding_StartTime: int_64 read GetReencodingStartTime write SetReencodingStartTime;
      property Reencoding_StopTime: int_64 read GetReencodingStopTime write SetReencodingStopTime;
   published
      property Reencoding_IncludeAudioStream: Boolean read GetReencodingIncludeAudioStream write SetReencodingIncludeAudioStream;
      property Reencoding_IncludeVideoStream: Boolean read GetReencodingIncludeVideoStream write SetReencodingIncludeVideoStream;
      property Reencoding_Method: TRecordingMethod read GetReencodingMethod write SetReencodingMethod;
      property Reencoding_UseAudioCompressor: Boolean read GetReencodingUseAudioCompressor write SetReencodingUseAudioCompressor;
      property Reencoding_UseFrameGrabber: Boolean read GetReencodingUseFrameGrabber write SetReencodingUseFrameGrabber;
      property Reencoding_UseVideoCompressor: Boolean read GetReencodingUseVideoCompressor write SetReencodingUseVideoCompressor;
      property Reencoding_WMVOutput: Boolean read GetReencodingWMVOutput write SetReencodingWMVOutput;
      property SampleCapture_Audio: TSampleCapture read GetSampleCapture_Audio write SetSampleCapture_Audio;
      property SampleCapture_Video: TSampleCapture read GetSampleCapture_Video write SetSampleCapture_Video;
      property SampleCaptureAsyncEvent: Boolean read GetSampleCaptureAsyncEvent write SetSampleCaptureAsyncEvent;
      property ShapeOverlay: TShape read GetShapeOverlay write SetShapeOverlay;
      property ShapeOverlayEnabled: Boolean read GetShapeOverlayEnabled write SetShapeOverlayEnabled;
      property SpeakerControl: Boolean read GetSpeakerControl write SetSpeakerControl;
      property StoragePath: string read GetStoragePath write SetStoragePath stored False;
      property StoreDeviceSettingsInRegistry: Boolean read GetStoreDeviceSettingsInRegistry write SetStoreDeviceSettingsInRegistry;
      property Synchronized: Boolean read GetSynchronized write SetSynchronized;
      property TextOverlay_Enabled: Boolean read GetTextOverlayEnabled write SetTextOverlayEnabled;
      property TextOverlay_Left: LongInt read GetTextOverlayLeft write SetTextOverlayLeft;
      property TextOverlay_Top: LongInt read GetTextOverlayTop write SetTextOverlayTop;
      property TextOverlay_Right: LongInt read GetTextOverlayRight write SetTextOverlayRight;
      property TextOverlay_BkColor: TColor read GetTextOverlayBkColor write SetTextOverlayBkColor;
      property TextOverlay_Align: TTextOverlayAlign read GetTextOverlayAlign write SetTextOverlayAlign;
      property TextOverlay_Font: TFont read GetTextOverlayFont write SetTextOverlayFont;
      property TextOverlay_String: string read GetTextOverlaystring write SetTextOverlaystring;
      property TextOverlay_Transparent: Boolean read GetTextOverlayTransparent write SetTextOverlayTransparent;
      property TranslateMouseCoordinates: Boolean read GetTranslateMouseCoordinates write SetTranslateMouseCoordinates;
      property UniqueID: LongInt read GetUniqueID write SetUniqueID;
      property TVUseFrequencyOverrides: Boolean read GetTVUseFrequencyOverrides write SetTVUseFrequencyOverrides;
      //property UploadToDV_Device: LongInt read GetUploadToDV_Device write SetUploadToDV_Device;
      property Version: string read GetVersion write SetVersion;
      property VideoDevice: LongInt read GetVideoDevice write SetVideoDevice;
      property VideoCompression_KeyFrameRate: LongInt read GetVideoCompression_KeyFrameRate write SetVideoCompression_KeyFrameRate;
      property VideoCompression_PFramesPerKeyFrame: LongInt read GetVideoCompression_PFramesPerKeyFrame write SetVideoCompression_PFramesPerKeyFrame;
      property VideoCompression_Quality: Double read GetVideoCompression_Quality write SetVideoCompression_Quality;
      property VideoCompression_WindowSize: LongInt read GetVideoCompression_WindowSize write SetVideoCompression_WindowSize;
      property VideoControlSettings: Boolean read GetVideoControlSettings write SetVideoControlSettings;
      property VideoFromImages_BitmapsSortedBy: TFileSort read GetVideoFromImages_BitmapsSortedBy write SetVideoFromImages_BitmapsSortedBy;
      property VideoFromImages_RepeatIndefinitely: Boolean read GetVideoFromImages_RepeatIndefinitely write SetVideoFromImages_RepeatIndefinitely;
      property VideoFromImages_SourceDirectory: String read GetVideoFromImages_SourceDirectory write SetVideoFromImages_SourceDirectory stored False;
      property VideoFromImages_TemporaryFile: String read GetVideoFromImages_TemporaryFile write SetVideoFromImages_TemporaryFile;
      property VideoProcessing_Brightness: LongInt read GetVideoProcessingBrightness write SetVideoProcessingBrightness;
      property VideoProcessing_Contrast: LongInt read GetVideoProcessingContrast write SetVideoProcessingContrast;
      property VideoProcessing_Deinterlacing: TVideoDeinterlacing read GetVideoProcessingDeinterlacing write SetVideoProcessingDeinterlacing;
      property VideoProcessing_FlipHorizontal: Boolean read GetVideoProcessingLeftRight write SetVideoProcessingLeftRight;
      property VideoProcessing_FlipVertical: Boolean read GetVideoProcessingTopDown write SetVideoProcessingTopDown;
      property VideoProcessing_GrayScale: Boolean read GetVideoProcessingGrayScale write SetVideoProcessingGrayScale;
      property VideoProcessing_Hue: LongInt read GetVideoProcessingHue write SetVideoProcessingHue;
      property VideoProcessing_InvertColors: Boolean read GetVideoProcessingInvertColors write SetVideoProcessingInvertColors;
      property VideoProcessing_Saturation: LongInt read GetVideoProcessingSaturation write SetVideoProcessingSaturation;
      property VideoProcessing_Rotation: TVideoRotation read GetVideoProcessingRotation write SetVideoProcessingRotation;
      property VideoQualitySettings: Boolean read GetVideoQualitySettings write SetVideoQualitySettings;
      property VideoRenderer: TVideoRenderer read GetVideoRenderer write SetVideoRenderer;
      property VideoSource: TVideoSource read GetVideoSource write SetVideoSource;
      property VideoSource_FileOrURL: String read GetVideoSource_FileOrURL write SetVideoSource_FileOrURL;
      property VideoSource_FileOrURL_StartTime: int_64 read GetVideoSource_FileOrURL_StartTime write SetVideoSource_FileOrURL_StartTime;
      property VideoSource_FileOrURL_StopTime: int_64 read GetVideoSource_FileOrURL_StopTime write SetVideoSource_FileOrURL_StopTime;


      property OnAudioDeviceSelected: TEventNotification read FOnAudioDeviceSelected write FOnAudioDeviceSelected;
      property OnBacktimedFramesCountReached: TEventNotification read FOnBacktimedFramesCountReached write FOnBacktimedFramesCountReached;
      property OnBitmapsLoadingProgress: TOnProgress read FOnBitmapsLoadingProgress write FOnBitmapsLoadingProgress;
      property OnClick: TEventNotification read FOnClick write FOnClick;
      property OnDblClick: TEventNotification read FOnDblClick write FOnDblClick;
      property OnColorKeyChange: TOnColorKeyChange read FOnColorKeyChange write FOnColorKeyChange;
      property OnCopyPreallocDataCompleted: TOnSourceFileToDestFileCompleted read FOnCopyPreallocDataCompleted write FOnCopyPreallocDataCompleted;
      property OnCopyPreallocDataProgress: TOnProgress read FOnCopyPreallocDataProgress write FOnCopyPreallocDataProgress;
      property OnCopyPreallocDataStarted: TOnSourceFileToDestFileStarted read FOnCopyPreallocDataStarted write FOnCopyPreallocDataStarted;
      property OnCreatePreallocFileCompleted: TOnCreatePreallocatedFileCompleted read FOnCreatePreallocFileCompleted write FOnCreatePreallocFileCompleted;
      property OnCreatePreallocFileProgress: TOnProgress read FOnCreatePreallocFileProgress write FOnCreatePreallocFileProgress;
      property OnCreatePreallocFileStarted: TOnFileNotification read FOnCreatePreallocFileStarted write FOnCreatePreallocFileStarted;
      property OnDeviceArrivalOrRemoval: TOnDeviceArrivalOrRemoval read FOnDeviceArrivalOrRemoval write FOnDeviceArrivalOrRemoval;
      property OnDeviceLost: TEventNotification read FOnDeviceLost write FOnDeviceLost;
      property OnDirectNetworkStreamingHostUrl: TOnDirectNetworkStreamingHostUrl read FOnDirectNetworkStreamingHostUrl write FOnDirectNetworkStreamingHostUrl;
      property OnDiskFull: TEventNotification read FOnDiskFull write FOnDiskFull;
      property OnDVCommandCompleted: TOnDVCommandCompleted read FOnDVCommandCompleted write FOnDVCommandCompleted;
      property OnFrameCaptureCompleted: TOnFrameCaptureCompleted read FOnFrameCaptureCompleted write FOnFrameCaptureCompleted;
      property OnFrameOverlayUsingDC: TOnFrameOverlayUsingDC read FOnFrameOverlayUsingDC write SetOnFrameOverlayUsingDC;
      property OnFrameOverlayUsingDIB: TOnFrameOverlayUsingDIB read FOnFrameOverlayUsingDIB write FOnFrameOverlayUsingDIB;
      property OnFrameOverlayUsingVIDEOHDR: TOnFrameOverlayUsingVIDEOHDR read FOnFrameOverlayUsingVIDEOHDR write FOnFrameOverlayUsingVIDEOHDR;
      property OnFrameProgress: TOnFrameProgress read FOnFrameProgress write FOnFrameProgress;
      property OnInactive: TEventNotification read FOnInactive write FOnInactive;
      property OnKeyPress: TOnVideoKeyPress read FOnKeyPress write FOnKeyPress;
      property OnLog: TOnLog read FOnLog write FOnLog;
      property OnMotionDetected: TOnMotionDetected read FOnMotionDetected write FOnMotionDetected;
      property OnMotionNotDetected: TOnMotionNotDetected read FOnMotionNotDetected write FOnMotionNotDetected;
      property OnMouseDown: TOnVideoMouseUpDown read FOnMouseDown write FOnMouseDown;
      property OnMouseMove: TOnVideoMouseMove read FOnMouseMove write FOnMouseMove;
      property OnMouseUp: TOnVideoMouseUpDown read FOnMouseUp write FOnMouseUp;
      property OnNoVideoDevices: TEventNotification read FOnNoVideoDevices write FOnNoVideoDevices;
      property OnPlayerBufferingData: TOnPlayerBufferingData read FOnPlayerBufferingData write FOnPlayerBufferingData;
      property OnPlayerEndOfStream: TEventNotification read FOnPlayerEndOfStream write FOnPlayerEndOfStream;
      property OnPlayerOpened: TEventNotification read FOnPlayerOpened write FOnPlayerOpened;
      property OnPreviewStarted: TEventNotification read FOnPreviewStarted write FOnPreviewStarted;
      property OnRecordingCompleted: TOnRecordingCompleted read FOnRecordingCompleted write FOnRecordingCompleted;
      property OnVideoFromBitmaps_FormatNeeded: TOnVideoFromBitmaps_FormatNeeded read FOnVideoFromBitmaps_FormatNeeded write FOnVideoFromBitmaps_FormatNeeded;
      property OnVideoFromBitmaps_NextFrameNeeded: TOnVideoFromBitmaps_NextFrameNeeded read FOnVideoFromBitmaps_NextFrameNeeded write FOnVideoFromBitmaps_NextFrameNeeded;
      property OnRecordingReadyToStart: TEventNotification read FOnRecordingReadyToStart write FOnRecordingReadyToStart;
      property OnRecordingStarted: TOnFileNotification read FOnRecordingStarted write FOnRecordingStarted;
      property OnReencodingStarted: TOnSourceFileToDestFileStarted read FOnReencodingStarted write FOnReencodingStarted;
      property OnReencodingProgress: TOnProgress read FOnReencodingProgress write FOnReencodingProgress;
      property OnReencodingCompleted: TOnSourceFileToDestFileCompleted read FOnReencodingCompleted write FOnReencodingCompleted;
      property OnReinitializing: TEventNotification read FOnReinitializing write FOnReinitializing;
      property OnResizeVideo: TOnResizeVideo read FOnResizeVideo write FOnResizeVideo;
      property OnSampleCapture_Audio: TOnSampleCapture read FOnSampleCapture_Audio write FOnSampleCapture_Audio;
      property OnSampleCapture_Video: TOnSampleCapture read FOnSampleCapture_Video write FOnSampleCapture_Video;
      property OnThirdPartyFilterConnected: TOnThirdPartyFilterConnected read FOnThirdPartyFilterConnected write FOnThirdPartyFilterConnected;
      property OnTVChannelSelected: TOnTVChannelSelected read FOnTVChannelSelected write FOnTVChannelSelected;
      property OnTVChannelScanCompleted: TEventNotification read FOnTVChannelScanCompleted write FOnTVChannelScanCompleted;
      property OnTVChannelScanStarted: TOnTVChannelScanStarted read FOnTVChannelScanStarted write FOnTVChannelScanStarted;
      property OnVideoCompressionSettings: TOnVideoCompressionSettings read FOnVideoCompressionSettings write FOnVideoCompressionSettings;
      property OnVideoDeviceSelected: TEventNotification read FOnVideoDeviceSelected write FOnVideoDeviceSelected;
   end;

   {$IFNDEF DELPHI_OR_BCB_6_AND_GREATER}
   function StrToFloatDef(const S: string; const Default_: Extended): Extended;
   {$ENDIF DELPHI_OR_BCB_6_AND_GREATER}

   function AudioDevices: string;
   function AudioDevicesCount: LongInt;
   function VideoDevices: string;
   function VideoDevicesCount: LongInt;
   function AudioCompressors: string;
   function AudioCompressorsCount: LongInt;
   function VideoCompressors: string;
   function VideoCompressorsCount: LongInt;
   function IsVideoDeviceConnected (DeviceIndex: LongInt): Boolean;
   function IsAudioDeviceConnected (DeviceIndex: LongInt): Boolean;
   function IsDVDevice (Index: LongInt): Boolean;
   function IsDirectX8OrHigherInstalled: Boolean;
   function MonitorsCount: LongInt;
   function MonitorBounds (MonitorNumber: LongInt; var Bounds: TRect): Boolean;

var
   CleanTVideoGrabberRegistryOnExit: Boolean = false;
   {$IFDEF DISABLECODECS}
   CodecsDisabledFromIDE: Boolean = True;
   {$ELSE DISABLECODECS}
   CodecsDisabledFromIDE: Boolean = False;
   {$ENDIF DISABLECODECS}
   RegRootKey: TRegistryRoot = RR_HKEY_CURRENT_USER;
   {RegRootKey: TRegistryRoot = RR_HKEY_LOCAL_MACHINE;}
   RegKeyId: string = '\Software\' + APPNAME + '\';
   VfwDriversEnabled: Boolean = True;
   CustomEnClsid: pGUID = nil;

implementation

uses SysUtils, Registry, Dialogs, StdCtrls,
     {$IFDEF DELPHI_OR_BCB_6_AND_GREATER}
     Variants,
     {$ENDIF DELPHI_OR_BCB_6_AND_GREATER}
     MultiMon, AxCtrls, Menus;



{$include Inc_DxIntf}

   {$include Inc_DxFltr}

type
   TInitProcess = (ipNotInitialized, ipInitializing, ipInitialized, ipActivated);
   TDirectX8OrHigher = (dx_NotTested, dx_7orLess, dx_8OrHigher);

const
   WMVLibName = 'wmvcore.dll';

   FPREALLOCATEDEXTENSION = '.rec';
   MAXREFRESHFRAMECOUNT = 4;

   REFTIME_MILLISECONDS: int64 = 1000;            // 10 ^ 3
   REFTIME_NANOSECONDS:  int64 = 1000000000;      // 10 ^ 9
   REFTIME_UNITS:        int64 = 10000000;         // 10 ^ 7

   DEFAULTNOTIFICATIONSLEEPTIME = 15;
   DEFAULTAUTOTUNINGSLEEPTIME = 200;
   DEFAULTPLAYERSTEPSLEEPTIME = 100;
   DEFAULTNOTIFICATIONMETHOD = nm_Timer;
   DEFAULTSYNCSLEEPTIME = 300;
var
   DirectX8OrHigher: TDirectX8OrHigher = dx_NotTested;
   OnIdleDone: Boolean = false;
   InitializationStatus: TInitProcess = ipNotInitialized;
   iEnumMonitors: LongInt = 0;
   TempCleanDone: Boolean = false;
   WM_NOTIFYWINDOW: LongWord = 0;
   WMVLib: THandle = 0;
   IsInDesignMode: Boolean = False;
   CoInitializedDone: Boolean = false;




{$include Inc_Log}

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function CreateInstance(clsid: pCLSID; iid: TIID; out BaseFilter; ObjName: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ creates an instance of an interface, logs the result.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
begin
   Hr := CoCreateInstance (clsid^, nil, CLSCTX_INPROC_SERVER or CLSCTX_LOCAL_SERVER, iid, BaseFilter);
   Result := WriteLogBool (Hr = S_OK, sGrey, 'instance: ' + ObjName);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure Msgx (Value: String); overload;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   MessageBox (0, pchar(Value), '', 0);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure Msgx (Value: LongInt); overload;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   MessageBox (0, pchar(IntToStr (Value)), '', 0);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure Msgx (Value: Int64); overload;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   MessageBox (0, pchar(IntToStr (Value)), '', 0);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure CopyGuid (dest, src: pGUID);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Windows.CopyMemory (dest, src, sizeof (TGUID));
end;

var
   Log_Id: String = 'TJxdVideoGrabber v' + TVideoGrabberVersion;

{$include Inc_Devices}

{$include Inc_Tools}

const
   ThirdPartyFilterMaxCount = 10;
   TThirdPartyFilterListBound = 5;
   MAXSTACKARRAY = 40;
   MAINTIMERINTERVAL = 10;
   PAUSEDPLAYERDISPLAYINTERVAL = 3; { 30 fps = 1000 / 10 = 3,33 }
   TVideoGrabberDXFiltersVersion = 7035;
   BASECLOCKVALUE = 60000 / 92;
   BufferFltrId = 8343;
   GUIDLEN = 38;

type

    TVideoFromImages = record
       CreatingSetOfBitmaps: Boolean;
       InUse: Boolean;
       BitmapsFileStream: TFileStream;
       BitmapsFileStreamName: String;
       BitmapsCount: LongWord;
    end;

   TSaveFilterState = class (TStringList)
   private
      OutPinFilter: string;
      OutPinName: string;
   end;

   TSetCurrentState    = set of TCurrentState;

   TGraphState = (gs_None, gs_Building, gs_WaitForSync, gs_CanActivate, gs_Activating, gs_Active);

   pBaseFilter = ^IBaseFilter;

   TASFSettings = record
      AudioBitRate: LongInt;
      AudioChannels: LongInt;
      DeinterlaceMode: LongWord;
      FixedFrameRate: BOOL;
      JPEGCompressionQuality: LongWord;
      VideoBitRate: LongInt;
      VideoQuality: LongInt;
      VideoMaxKeyFrameSpacing: LongInt;
      VideoWidth: LongInt;
      VideoHeight: LongInt;
   end;

   pReencodingSettings = ^TReencodingSettings;
   TReencodingSettings = record
      IncludeVideoStream: Boolean;
      IncludeAudioStream: Boolean;
      NewVideoClip: String;
      Method: TRecordingMethod;
      SourceVideoClip: String;
      StartTime: int64;
      StopTime: int64;
      UseFrameGrabber: Boolean;
      UseVideoCompressor: Boolean;
      UseAudioCompressor: Boolean;
      WMVOutput: Boolean;
   end;

   TVideoEffects = record
      Brightness: LongInt;
      Contrast: LongInt;
      Saturation: LongInt;
      Hue: LongInt;
      GrayScale: Boolean;
      InvertColors: Boolean;
      Deinterlacing: Boolean;
      LeftRight: Boolean;
      TopDown: Boolean;
      Enabled: Boolean;
   end;

   TThirdPartyFilterData = record
      FilterGUID: TGUID;
      FilterName: string;
      Enabled: Boolean;
      SavedFilterState: Boolean;
      Filter: IBaseFilter;
      FilterIntf: IUnknown;
   end;

   pFrameBitmapData = ^TFrameBitmapData;
   TFrameBitmapData = record
      FrameBitmap: Graphics.TBitmap;
      FrameDibSection: TDibSection;
      FrameBitmapNumber: LongInt;
      FrameBitmapTime: int64;
   end;

   pSampleCaptureInfo = ^TSampleCaptureInfo;
   TSampleCaptureInfo = record
      FrameBuffer: pByte;
      FrameBufferSize: LongInt;
      FrameDataLength: LongInt;
      FormatType: TFormatType;
      pbmi: pBitmapInfoHeader;
      pFormat: pointer;
      Capturing: Boolean;
      Processing: Boolean;
      FrameAvail: Boolean;
      FrameStartTime: int64;
      FrameEndTime: int64;
   end;

   TExternalSourceFrameData = record
      FrameData: pByte;
      CanCreateNewFrame: Boolean;
      CanAccessFrame: Boolean;
   end;

   TSlaveMultiplexedFrameBitmapData = record
      LastFrameData: pByte;
      pCxMediaType_OwnedByMaster: PAM_MEDIA_TYPE;
      CanCreateLastFrame: Boolean;
      CanAccessLastFrame: Boolean;
   end;

   pCurrentFrameInfo = ^TCurrentFrameInfo;
   TCurrentFrameInfo = record
      FrameBitmapData: TFrameBitmapData;
      FrameInfo: TFrameInfo;
      CurrentFrameNumber: LongInt;
      CurrentFrameTime: int64;
      PlayerNewPosition: int64;
   end;

   TPlayerPausedType = (ppt_None, ppt_Begin, ppt_Current, ppt_End);

   pCurrentFrameData = ^TCurrentFrameData;
   TCurrentFrameData = record
      ThreadOldPosition: int64;
      ThreadOldReencodingPercent: LongInt;
      ThreadOldFrameNumber: LongInt;
      ThreadNewFrameNumber: LongInt;
      ThreadPausedPlayerRefreshCount: LongInt;
      ThreadAMExtTransportRefreshCount: LongInt;
      ThreadTransportOldState: LongInt;
      ThreadReencodingRefreshCount: LongInt;
      RecordingOnMotionNextTickCountTime: Dword;

      PlayerStepClockCount: LongInt;
      PlayerStepClocki: LongInt;
      PlayerDoNotNotifyNextFrame: Boolean;

      DVDataAvailable: Boolean;
      SettingNewPosition: Boolean;
      NewFrameNotNotifiedByFrameGrabber: Boolean;
      NewFrameAvailable: Boolean;
      ReturnOneShotFrame: Boolean;
      ReturnBurstModeFrame: Boolean;
      OneShotDest: TFrameCaptureDest;
      OneShotFileName: string;
      OneShotSampleAvailable: Boolean;
      MustPausePreview: Boolean;
      OneShotCaptureWaiting: Boolean;
      OneShotCaptureSuccess: Boolean;
      PreviousFrameBitmapData: TFrameBitmapData;
      RequestLastFrame: Boolean;
      LastFrameAvailable: Boolean;
      DrawingOverFrames: Boolean;
      DrawingOverFramesDxDc: Hdc;
      DVCommandState: LongInt;

      OldDVTimeCode: TDVTimeCode;

      InitialFrameNumber: LongInt;
      InitialDroppedCount: LongInt;
      InitialFrameTime: int64;
      RealFrameTime: int64;
      HoldStreamingFrameTime: int64;
      PausedFrameTime: int64;

      PlayerTrackBarNewPosition: LongInt;
      PlayerTrackBarNewPositionSet: Boolean;
      PlayerPausedType: TPlayerPausedType;
      PlayerPausedNewPosition: LongInt;
      PlayerFrameInterval: LongInt;
      PlayerFastSeek: Boolean;
      PLayerSeekBackwards: Boolean;
      PlayerEmulateSpeedRatio: Boolean;
      PlayerEndOfStreamReached: Boolean;
      gfNotifyPreviousTick: dword;
      PlayerEmulateSpeedRatioTickCountInterval: DWORD;
      PlayerStepClockLastTickCount: longword;
      PlayerStepClockLastPosition: int64;
      PlayerStepClockCalculatedNewPositionShift_100ns: int64;
      AVIFrameCapturePaused: Boolean;


   end;

   TShapeOverlay = class (TShape)
   end;

const
   MAXTextOverlaystring = 1000;
   MAXMONITORS = 10;

PackedYUV: array[0..29] of string = (
           'dvsd',
           'I420',
           'YV12',
           'YVU9',
           'CLJR',
           'cyuv',
           'GREY',
           'IRAW',
           'IUYV',
           'IY41',
           'IYU1',
           'IYU2',
           'UYNV',
           'UYVP',
           'UYVY',
           'V422',
           'V655',
           'VYUY',
           'Y411',
           'Y422',
           'YUY2',
           'YUNV',
           'YVYU',
           'Y41P',
           'Y211',
           'Y41T',
           'Y42T',
           'YUVP',
           'Y800',
           'Y8  '
           );

type
   TVarParseText       = (ptNone,
                          ptTimeCode,
                          ptCurrentFrameNumber,
                          ptTime100Ns,
                          ptTimeSec,
                          ptFullTime,
                          ptSysTime,
                          ptDVTime,
                          ptCustom0,
                          ptCustom1,
                          ptCustom2,
                          ptCustom3,
                          ptCustom4,
                          ptCustom5,
                          ptCustom6,
                          ptCustom7,
                          ptCustom8,
                          ptCustom9);

const
   MAXCUSTOMVARS = 9;

type
   TMasterStream       = (ms_VideoMaster, ms_AudioMaster, ms_NoMaster);
   TAutoFileNameType   = (afn_BmpFile, afn_JpegFile, afn_Custom);

   TGlobalId = (
      _LastRecordingFileName,
      _LastClipPlayed
   );

   TAudioId = (
      _A_DeviceDiscovered,
      _AudioInputs,
      _AudioInput,
      _AudioInputBalance,
      _AudioInputLevel,
      _AudioInputMono,
      _AudioInputName,
      _SpeakerVolume,
      _SpeakerBalance,
      _AudioMute,
      _AIsSoundCard,

      _AUDIO_MAYNOTBESAVED,

      _AIsAudioCrossbarAvail
      );

   TVideoId = (
      _AudioDeviceAssociated,
      _AudioInputAssociated,
      _AudioInputBalanceAssociated,
      _AudioInputLevelAssociated,
      _AudioInputMonoAssociated,
      _AudioInputNameAssociated,
      _SpeakerVolumeAssociated,
      _SpeakerBalanceAssociated,
      _DeviceDiscovered,
      _IsVfw,
      _IsDigitalVideoIn,
      _IsDVPal,
      _IsVideoPortAvailable,
      _IsVideoInterlaced,
      _IsTVTunerAvail,
      _IsTVAudioAvail,
      _IsAnalogVideoDecoderAvail,
      _IsVCRHorizontalLockingAvail,
      _IsAudioCrossbarAvail,
      _IsVideoCrossbarAvail,
      _IsVideoQualityAvail,
      _IsCameraControlAvail,
      _IsVideoControlAvail,
      _IsMpegStream,
      _VideoControlCaps,
      _VfwCaptureDialogFormat,
      _VfwCaptureDialogSource,
      _VfwCaptureDialogDisplay,
      _VideoInputs,
      _ExtTransportAvail,
      _TimeCodeReaderAvail,
      _ANVTVFormats,
      _VIDEOCROSSBARAVAIL,
      _AUDIOCROSSBARAVAIL,

      _VIDEO_MAYNOTBESAVED,

      _VideoSize,
      _VideoInput,
      _VideoInputName,
      _VideoRenderer,
      _VideoSubtype,
      _VideoControlMode,

      _TVChannel,
      _TVChannelFreq,
      _TVInputType,
      _TVConnectInput,
      _TVTuningSpace,
      _TVCountryCode,
      _TVMode,

      _ANVTVFormat,
      _ANVVCRHorzLocking,
      _ANVOutputEnable,
      _AMVideoCrossbar,
      _AMAudioCrossbar,
      _VideoQuality_Auto,
      _VideoQuality_Values,
      _CameraControl_Auto,
      _CameraControl_Values
      );

   TValue = (tvNone, tvLongInt, tvstring, tvBoolean, tvFloat, tvBuffer);

   pRegistryData = ^TRegistryData;
   TRegistryData = record
      RegId: string;
      t: TValue;
      i: LongInt;
      s: string;
      b: Boolean;
      d: Double;
      Data: pointer;
      DataSize: LongInt;
   end;

   TCrossbarPinInfo = packed record
      Related: SmallInt;
      Routed: SmallInt;
   end;

   TCrossbar = class (TObject)
   private
      FInBound, FOutBound: LongInt;
      F_Crossbar: IAMCrossbar;
      InputList: TstringList;
      OutputList: TstringList;
   public
      constructor Create;
      destructor Destroy; override;
      procedure Clear;
      procedure ReadCrossbar (var pCrossbar: IAMCrossbar);
   end;

   TRouting = class (TObject)
   public
       pLeftRouting: TRouting;
       pRightRouting: TRouting;
       VideoInputIndex: LongInt;
       VideoOutputIndex: LongInt;
       AudioInputIndex: LongInt;
       AudioOutputIndex: LongInt;
       pXbar: IAMCrossbar;
       InputPhysicalType: LongInt;
       OutputPhysicalType: LongInt;
       Depth: LongInt;
   end;

   TCrossbarTree = class (TObject)
   private
      m_pStartingPin: IPin;
      m_RoutingRoot: TRouting;
      m_RoutingList: TList;
      m_RoutingItems: TList;
      m_CurrentRoutingIndex: LongInt;

      function BuildRoutingList (pStartingInputPin: IPin; pRouting: TRouting; Depth: LongInt): HRESULT;
      function SaveRouting (pRoutingNew: TRouting): HRESULT;

      function GetCrossbarIPinAtIndex(pXbar: IAMCrossbar; PinIndex: LongInt; IsInputPin: BOOL; var ppPin: IPin): HRESULT;
      function GetCrossbarIndexFromIPin(pXbar: IAMCrossbar; PinIndex: pLongInt; IsInputPin: BOOL; ppPin: IPin): HRESULT;
   public
      constructor Create (pStartingInputPin: IPin);
      destructor Destroy; override;

       function GetInputCount (pCount: pLongInt): HRESULT;
       function GetInputType  (Index: LongInt; PhysicalType: pLongInt): HRESULT;
       function GetInputName  (Index: LongInt; var Name: string): HRESULT;
       procedure SetCurrentInputFromCrossbar (Crossbar: IAMCrossbar);
       function SetInputIndex (Index: LongInt): HRESULT;
       function GetInputIndex (Index: pLongInt): HRESULT;
   end;

   pVideoRegSave = ^TVideoRegSave;
   TVideoRegSave = array[low (TVideoId)..high(TVideoId)] of TRegistryData;

   pAudioRegSave = ^TAudioRegSave;
   TAudioRegSave = array[low (TAudioId)..high(TAudioId)] of TRegistryData;

   pGlobalRegSave = ^TGlobalRegSave;
   TGlobalRegSave = array [low (TGlobalId)..high(TGlobalId)] of TRegistryData;


   TSettings = record
      Available: Boolean;
      Value, Min, Max, SteppingDelta, Default_: LongInt;
   end;

   p_VideoQualitySettings = ^T_VideoQualitySettings;
   T_VideoQualitySettings = array[low(TVideoQuality)..high(TVideoQuality)] of TSettings;

   p_CameraControlSettings = ^T_CameraControlSettings;
   T_CameraControlSettings = array[low(TCameraControl)..high(TCameraControl)] of TSettings;

   TTextOverlayData = record
      TextStack: array[0..MAXSTACKARRAY] of string;
      VarStack: array[0..MAXSTACKARRAY] of TVarParseText;
      iStack: LongInt;
      Assigning: Boolean;
      Processing: Boolean;
   end;

const
   ODOA = char(13) + Char(10);
   CLSID_GrabberSample: TGUID = '{4c952308-e817-43f6-8725-6e508a0a8564}';
   CLSID_GrabberSampleNoModify: TGUID = '{C1562517-DC9B-4920-8F92-E797F0082A59}';
   CLSID_Frw: TGUID = '{FB1BE208-FD98-46e7-99FB-98EA61DAF535}';
   CLSID_CustomClk: TGUID = '{37FCA8C9-FE28-49a5-BE5A-64B59479A1B2}';
   CLSID_Transform: TGUID = '{538E41A1-CDAB-4233-92BB-6B4271BFFF84}';
   CLSID_PushSource: TGUID = '{78E9BF6E-DD67-432d-A618-124AEDEA2E3F}';

type
   TOnNotifyEventChain = record
      Obj: TObject;
      Event: TNotifyEvent;
   end;

   TCustomTransform = function (GrabberData: Pointer; pIn: IMediaSample; pOut: IMediaSample):HRESULT; stdcall;
   TCustomCalculateMediaType = function (GrabberData: Pointer; out pmt: PAM_MEDIA_TYPE):HRESULT; stdcall;

   pTransformConfig = ^TTransformConfig;
   TTransformConfig = record
      GrabberData: Pointer;
      VideoRotation: TVideoRotation;
      VideoRotation_90_or_270: Boolean;
      VideoHalfDeinterlacing: Boolean;
      Enabled: Boolean;
      CustomSubtype: Boolean;
      CustomSubtypeGUID: TGUID;
      CustomTransform: TCustomTransform;
      CustomCalculateMediaType: TCustomCalculateMediaType;
   end;

   pAudioRendering = ^TAudioRendering;
   TAudioRendering = record
      CaptureGraphBuilder2: ICaptureGraphBuilder2;
      FilterGraph2: IFilterGraph2;
      GraphBuilder: IGraphBuilder;
      pBDummy: pBoolean;
      AudioDevice: IBaseFilter;
      MediaControl: IMediaControl;
   end;

   TGetVideoFormatBmiInfoCB = function (VidGrab: Pointer; out cbBitmapInfo: dword; out pBmi: pBitmapInfo; out Buffer: pByte): HRESULT; stdcall;
   TGetVideoFormatPMediaTypeCB = function (VidGrab: Pointer; out pmt: PAM_MEDIA_TYPE; var CanDeleteMediaType: Boolean): HRESULT; stdcall;
   TGetSampleDataCB = function (VidGrab: Pointer; Buffer: pByte; BufferSize: LongInt; out EndOfData: Boolean; var DataLength: LongInt): HRESULT; stdcall;

   pPushSourceConfig = ^TPushSourceConfig;
   TPushSourceConfig = packed record
      Vdgr: Pointer;
      FrameRate: Double;
      GetVideoFormatBmiInfoCB: TGetVideoFormatBmiInfoCB;
      GetVideoFormatPMediaTypeCB: TGetVideoFormatPMediaTypeCB;
      GetSampleDataCB: TGetSampleDataCB;
   end;

   TWMCommandOrNotification = (
      WMDeviceLost,
      WMPlayerSetPosition,
      WMPausePlayer,
      WMStopPlayer,
      WMProcessNotifyEvent, // below are synchrone
      WMPlayerSetTrackBarPosition,
      WMProcessStartTVAutoScan,
      WMProcessContinueTVAutoScan,
      WMStopGraph,
      WMStartPreview,
      WMPlayStartByStep,
      WMStartRecording,
      WMStartReencoding,
      WMOpenPlayer
   );

   pGrabberControl = ^TGrabberControl;
   TGrabberControl = record
      ProcessRGBFrame: Pointer;
      SampleGrabber: Pointer;
      SampleGrabberEnabled: Boolean;
      NotifyFrame: Pointer;
      NotifyFrameEnabled: Boolean;
      NotifyDVData: Pointer;
      NotifyDVDataEnabled: Boolean;
      Component: Pointer;
      BufferCount: LongInt;
      LockState: Boolean;
      ClearFrame: Boolean;
      AutoSelectRGBFormat: Boolean;
      UpdateFrameRate: Boolean;
      ForceRGBFormat: TFrameGrabberRGBFormat;
      Effects: TVideoEffects;
      PixelSizeX2: LongInt;
      RowSize: LongInt;
      CheckVersion: LongInt;
      CanCaptureAndNotifyFrame: Boolean;
      LockAVIFrameNumber: int64;
   end;

   TGrabberFilterType = (gf_Sample, gf_Dummy, gf_Notify, gf_Lock, gf_LockAndShift, gf_DVData, gf_ClearFrame, gf_CxPreferredFormat, gf_RGB, gf_RGB2432);

   TVideoWindow = class;

   pRenderer = ^TRendererW;

   TDisplayForm = class (TForm)
   private
      TVGOwner: Pointer;
      AssociatedRenderer: pRenderer;
      VideoRect: TRect;
      FOldWndProc: TWndMethod;
   protected
      destructor Destroy; override;
      procedure WMPAINT (var Message: TWMPAINT); message WM_PAINT;
      procedure WMSIZE (var Message: TWMSIZE); message WM_SIZE;
      procedure NewWndProc (var Message: TMessage);
   end;

   TRendererW = record
      FAssociatedWindow: TVideoWindow;
      Display: TDisplayForm;
      CurrentDisplayBounds: TRect;
      RenderFilter: IBaseFilter;
      VideoWindow: IVideoWindow;
      DisplayInUse: Boolean;
      IsOverlay: Boolean;
      RenderHandle: HWND;
      OldWindowPoint: TPoint;
   end;

   TMonitorInfo = class (TObject)
   protected
      FAvailable: Boolean;
      FBounds: TRect;
      FHandle: HMONITOR;
      FDc: HDC;
      FIndex: LongInt;
   public
      constructor Create (Index: LongInt);
   end;

   TDualThread = class (TThread)
   private
      FId: String;
      FTimer: TTimer;
      FInTimer: Boolean;
      FIsStopped: Boolean;
      FMethod: TNotificationMethod;
      FSleepTime: LongWord;
      FMustWaitFor: Boolean;
      procedure SetNotificationMethod (Value: TNotificationMethod);
      procedure SetSleepTime (Value: LongInt);
   public
      procedure DoResume;
      procedure DoSuspend;
      procedure OnTimer (Sender: TObject); virtual; abstract;
      procedure SuspendOrTerminateIfDestroying (Destroying: Boolean);
      constructor Create(Id: String; CreateSuspended: Boolean; Priority: TThreadPriority; NotificationMethod: TNotificationMethod; SleepTime: LongInt); reintroduce;
      destructor Destroy; override;
   end;

   TVidGrabThread = class (TDualThread)
      FIntf: TJxdVideoGrabber;
      constructor Create(Id: String; CreateSuspended: Boolean; Priority: TThreadPriority; NotificationMethod: TNotificationMethod; Intf: TJxdVideoGrabber; SleepTime: LongInt); reintroduce;
   end;

   TSyncManager = class;

   TSyncTimer = class (TTimer)
   private
      FiVidgrabNext: LongInt;
      FInTimer: Boolean;
      FSyncManager: TSyncManager;
      procedure OnTimerSync (Sender: TObject);
      constructor Create (AOwner: TComponent; SyncManager: TSyncManager); reintroduce;
   end;

   TCSList = class (TList)
      CriticalSection: TRTLCriticalSection;
      function First (var iNext: LongInt): Pointer;
      function Next (var iNext: LongInt): Pointer;
      procedure Lock;
      procedure Unlock;
      constructor Create;
      function Add (Item: Pointer): Integer;
      function Remove(Item: Pointer): Integer;
      destructor Destroy; override;
   end;

   TTaskThread = class (TVidGrabThread)
      procedure Execute; override;
      procedure OnTimer (Sender: TObject); override;
   end;

   TAutoTuningStepThread = class (TVidGrabThread)
      procedure Execute; override;
      procedure OnTimer (Sender: TObject); override;
   end;

   TOnVideoWindowNotify = procedure (Sender: TObject; Notification: TVideoWindowNotify; Param: LongWord) of object;

   TVideoWindow = class (TObject)
      private
         FBool: array[vwActive..vwVideoPortEnabled] of Boolean;
         FLongInt: array[vwMonitor..vwTop] of LongInt;

         FId: LongInt;
         FAssociatedRenderer: pRenderer;
         FPrevMousePoint: TPoint;
         FKeyPressed: Char;
         FAlternateVideoWindow: TVideoWindow;
         FActivated: Boolean;
         FHandleForIVideoWindow: HWND;

         FOnVideoWindowNotify: TOnVideoWindowNotify;

         function  GetLongIntProperties (Index: LongInt): LongInt;
         function  GetBoolProperties (Index: LongInt): Boolean;

         procedure SetBoolProperties (Index: LongInt; Value: Boolean);
         procedure SetLongIntProperties (Index: LongInt; Value: LongInt);
         procedure HandleWndMethod (var Msg: TMessage);
      public
         constructor Create (Id: LongInt; IsActive: Boolean; IsExternal: Boolean; VideoWidth, VideoHeight, WindowLeft, WindowTop, WindowWidth, WindowHeight: LongInt);
         destructor  Destroy; override;
         procedure   SetLocation (WindowLeft, WindowTop, WindowWidth, WindowHeight: LongInt);
      published
         property Active: Boolean index vwActive read GetBoolProperties write SetBoolProperties;
         property AutoSize: Boolean index vwAutosize read GetBoolProperties write SetBoolProperties;
         property KeepAspectRatio: Boolean index vwKeepAspectRatio read GetBoolProperties write SetBoolProperties;
         property Embedded: Boolean index vwEmbedded read GetBoolProperties write SetBoolProperties;
         property FullScreen: Boolean index vwFullScreen read GetBoolProperties write SetBoolProperties;
         property Height: LongInt index vwHeight read GetLongIntProperties write SetLongIntProperties;
         property Left: LongInt index vwLeft read GetLongIntProperties write SetLongIntProperties;
         property StayOnTop: Boolean index vwStayOnTop read GetBoolProperties write SetBoolProperties;
         property Monitor: LongInt index vwMonitor read GetLongIntProperties write SetLongIntProperties;
         property MouseMovesWindow: Boolean index vwMouseMovesWindow read GetBoolProperties write SetBoolProperties;
         property Top: LongInt index vwTop read GetLongIntProperties write SetLongIntProperties;
         property Width: LongInt index vwWidth read GetLongIntProperties write SetLongIntProperties;
         property VideoPortEnabled: Boolean index vwVideoPortEnabled read GetBoolProperties write SetBoolProperties;
      published
   end;

   ITransformConfig = interface(IUnknown)
    ['{47F3C4F6-69BD-4e89-846D-C60F5FC4FAAA}']
    function get_TransformConfig (Config: pTransformConfig): HResult; stdcall;
    function put_TransformConfig (Config: pTransformConfig): HResult; stdcall;
   end;

   IPushSourceConfig = interface(IUnknown)
    ['{30EBD212-CBB7-4570-B22F-FCE62D194A72}']
    function get_PushSourceConfig (Config: pPushSourceConfig): HResult; stdcall;
    function put_PushSourceConfig (Config: pPushSourceConfig): HResult; stdcall;
   end;

   IFrameSample = interface (IUnknown)
    ['{7DE39A9D-8B2B-4c54-9F0B-495AEA7DEE82}']
       function Configure (GrabberFilterType: TGrabberFilterType; out GrabberControl: pGrabberControl): HRESULT; stdcall;
       function SetAcceptedMediaType (pType: PAM_MEDIA_TYPE): HRESULT; stdcall;
       function GetProcAddr (i: LongInt; out ProcAd: pointer): HRESULT; stdcall;
       function GetRefCount (RefCount: pLongInt): HRESULT; stdcall;
  end;

   ICustomClock = interface (IUnknown)
    ['{75C4FD0A-98CF-4b6d-9198-151DF6A98435}']
       function SetClock (Value: longword): HRESULT; stdcall;
  end;

  TGrabberHandlers = (gh_SampleVideo, gh_SampleAudio, gh_RGB, gh_DummyRGB, gh_LockingVideo, gh_LockingAudio, gh_ClearVideo, gh_ClearAudio, gh_CxPreferredFormat, gh_ConfDm, gh_CustClk, gh_RwCap, gh_SampleDummy, gh_SampleNotify, gh_NotifyDVData, gh_Transform, gh_PushSource);

   pGrabberHandler = ^TGrabberHandler;
   TGrabberHandler = record
      Handle:  HMODULE;
      Grabber: IBaseFilter;
      FrameSample: IFrameSample;
      Control: pGrabberControl;
   end;

   TCurrentParams = record
      PreallocCapFileEnabled: Boolean;
      PreallocCapFileCopiedAfterRecording: Boolean;
      FrameCaptureWithoutOverlay: Boolean;
      FrameGrabber: TFrameGrabber;
      FrameRate: LongInt;
      FrameGrabberRGBFormat: TFrameGrabberRGBFormat;
      MultiplexedSlaveFrameRate: LongInt;
      CompressionMode: TCompressionMode;
      CompressionType: TCompressionType;
      RecordingCanPause: Boolean;
      RecordingInNativeFormat: Boolean;
      AudioDeviceRendering: Boolean;
      PlayerAudioRendering: Boolean;
      AudioDevice: LongInt;
      AudioRecording: Boolean;
      BurstCount: LongWord;
      BurstInterval: LongInt;
      HoldRecording: Boolean;
      VideoDevice: LongInt;
      VideoSource: TVideoSource;
      SpeakerControl: Boolean;
      VideoRenderer: TVideoRenderer;
      RecordingMethod: TRecordingMethod;
      NetworkStreaming: TNetworkStreaming;
      MotionDetectorEnabled: Boolean;
      VideoSubtypeIndex: LongInt;
      VideoRecording: Boolean;
      RecordingOnMotion_MotionThreshold: Double;
      RecordingOnMotion_Enabled: Boolean;
      RecordingOnMotion_NoMotionPauseDelayMs: Dword;
   end;

   pPpSaver = ^TPpSaver;
   TPpSaver = record
      ppInstance: TPropertyPageSaverBase;
      ppSaveProperties: Boolean;
      ppRestoreProperties: Boolean;
   end;

   TCanSetAudioPinLevel = (apNotTested, apCanSet, apCannotSet);

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{
{                                TSyncManager
{ manage global events, like device connect/disconnect
{
{………………………………………………………………………………………………………………………………………………………………………………………………………………}

   TDeviceNotifyStep = (dnsWaiting, dnsReceived, dnsProcessing);

   (*TSyncTimer = class (TDualThread)
      SyncManager: TSyncManager;
      procedure Execute; override;
   end;*)

   TSyncGlobalMessages = class (TCustomForm)
      procedure WMDeviceChangeMsg (var Message: TMessage); message WM_DEVICECHANGE;
   end;

   TSyncManager = class (TObject)
   private
      FSyncTimer: TSyncTimer;
      FActivatingApp: Boolean;
      FVideoGrabberList: TCsList;
      FAutoFileSequentialCount: TStringList;
      FOldOnIdle: TIdleEvent;
      FSyncGlobalMessages: TSyncGlobalMessages;
      FNotifyTime: Dword;
      FTempFiles: TStringList;
      FDeviceNotifyStep: TDeviceNotifyStep;

      procedure CheckAndActivateSync;
      function  CreateTempFile (Prefix: String): string;
      procedure DeviceNotify;
      function  FindTempFileByPrefix (Prefix: String): String;
      procedure ProcessAutoStartPreview;
      procedure OnIdle (Sender: TObject; var Done: Boolean);
      procedure ProcessDeviceChange;
      procedure RefreshAutoFileSequentialCount (Dir: string; Prefix: string; Capture_FileExt: String);
      function  GetNextFileSequentialCount (Dir: string; Prefix: string; Ext: string; var AutoFileSequentialCountIndex: LongInt): LongInt;
      function  GetAutoFileSequentialCount (AutoFileSequentialCountIndex: LongInt): LongInt;
      procedure DecAutoFileSequentialCount (AutoFileSequentialCountIndex: LongInt);

   public
      constructor Create (NotificationPriority: TThreadPriority);
      destructor Destroy; override;
   end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{
{                             TIMPLMOTIONDETECTOR
{               implementation part of the TVideoGrabber class
{   stores VideoDevices, AudioDevices, VideoCompressors, AudioCompressors
{………………………………………………………………………………………………………………………………………………………………………………………………………………}


const
   Bc = 0;
   Gc = 1;
   Rc = 2;

type
   TBgr = array[0..2] of byte;
   pTBgr = ^TBgr;

   T2DIntArray = array of array of Integer;

   TGrid = record
      Grid_0_9: T2DIntArray;
      MotionPixelDetected: T2DIntArray;
      MotionPixelTotal: T2DIntArray;
      Sensitivity_0_256: T2DIntArray;
      xStep: array of integer;
      yStep: array of integer;
      xCount, yCount: double;
   end;

  TImplMotionDetector = class;

  TfrmGridDialog = class(TForm)
    btnOK: TButton;
    imgGrid: TImage;
    edtCurrentLevel: TEdit;
    updCurrentLevel: TUpDown;
    btnCancel: TButton;
    popSetLevel: TPopupMenu;
    N11: TMenuItem;
    N21: TMenuItem;
    N31: TMenuItem;
    N41: TMenuItem;
    N51: TMenuItem;
    N61: TMenuItem;
    N71: TMenuItem;
    N81: TMenuItem;
    N91: TMenuItem;
    btnClearAll: TButton;
    btnEnableAll: TButton;
    updGlobalLevel: TUpDown;
    lblClickLevel: TLabel;
    lblGlobalLevel: TLabel;
    procedure btnOKClick(Sender: TObject);
    procedure updCurrentLevelClick(Sender: TObject; Button: TUDBtnType);
    procedure imgGridMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure UpdatePopup(Sender: TObject);
    procedure btnClearAllClick(Sender: TObject);
    procedure btnEnableAllClick(Sender: TObject);
    procedure updGlobalLevelClick(Sender: TObject; Button: TUDBtnType);
    procedure btnCancelClick(Sender: TObject);
    procedure imgGridMouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure imgGridMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
  private
     FimgGridProc: TWndMethod;
     DlgDet: TImplMotionDetector;
     FMouseXY: TPoint;
     FMouseDown: Boolean;
     FMouseMoved: Boolean;
     FMouseDownClickValue: word;
     procedure FindBestCurrentLevel;
     procedure ImgGridWndProc(var Message: TMessage);
     procedure RedrawMatricedBitmap;
     procedure DisplayGrid (Canvas: TCanvas; w, h, xstep, ystep, NoBorderMargin: integer);
     procedure DisplayCoefs (Canvas: TCanvas; w, h, xsize, ysize, xstep, ystep: integer);
     function SetOrRetrieveGridValueFromFrameCoordinates (x, y, FrameWidth, FrameHeight: word; SetValue: Integer = -1): word;
  end;

   TImplMotionDetector = class (TObject)
   private

      FEnabled: Boolean;
      FReleaseFrame: Boolean;

      FCurrentLevel: integer;
      FChangedCompareCriterias: Boolean;
      FCompareBlue: Boolean;
      FCompareGreen: Boolean;
      FGreyScale: Boolean;
      FCompareRed: Boolean;
      FDialogBitmap: TBitmap;
      FGrid: string;
      FGridDialog: TfrmGridDialog;
      FiEnumGridDialogControls: LongInt;
      FInternalGrid: TGrid;
      FIsGridValid: Boolean;
      FLatestFrameTime: int64;
      FMaxDetectionsPerSecond: Double;
      FMaxFrameTimeInterval100ns: int64;
      FMotionRatio: Double;
      FReduceCPULoad: dword;
      FReduceCPULoadValue: LongWord;
      FReduceVideoNoise: Boolean;
      FReset: Boolean;
      FRGBSize: LongWord;
      FStepsFound: Boolean;
      FGridXBound, FGridYBound: integer;
      FGridXSize, FGridYSize: integer;

      constructor Create;
      destructor Destroy; override;
      procedure CalculateReduceCPULoad (Width, Height: LongInt);
      procedure ClearMotionResults;
      procedure FindSteps (Width, Height: LongInt);
      procedure ModifyColorsToGreyScale (DIB: pDibSection; BitmapBits: LongWord; Width, Height, HeightBound: LongInt);
      procedure ReduceVideoNoiseImage (SrcBitmapBits: LongWord; DestDIB: pDibSection; DestBitmapBits: LongWord; Width, Height, HeightBound: LongInt);
      procedure DoReduceVideoNoiseImage (DIB: pDibSection; BitmapBits: LongWord; Width, Height, HeightBound: LongInt);
      procedure InitGrid (Level: integer);
      function  IsGridValid (Value: string): Boolean;
      procedure RebuildGridFromInternal;
      procedure SetMotionDetector_Grid (Value: string);
      function  SetCellCount (ValueX, ValueY: integer): Boolean;
      procedure SetInternalGridValue (i, j, Value_0_9: integer);
      procedure ResetGlobalSensitivity (Value: integer);
      procedure GloballyIncOrDecSensitivity (Value: integer);
      procedure LoadGridDialogIfNotLoaded (Owner: TComponent);
      function GetCellSensitivity (x, y: word; var Value: LongInt): Boolean;
      function SetCellSensitivity (x, y, Value: LongInt): Boolean;
      function DetectMotion (OldDib, NewDib: pDibSection; NewFrameTime: int64): Boolean;
   end;



   TRecordingFromBitmap = class (TObject)
   private
      FDibSection: TDibSection;
      FIsValidFormat: Boolean;
      constructor Create;
   end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{
{                                    TVdgr
{               implementation part of the TVideoGrabber class
{   stores VideoDevices, AudioDevices, VideoCompressors, AudioCompressors
{………………………………………………………………………………………………………………………………………………………………………………………………………………}

type
   TPObj = procedure of Object;

   TBufferLoaderFunction = function (out Buffer: pByte; out BufferSize: LongWord): Boolean;

   TVdgr = class;

   pTaskData = ^TTaskData;
   TTaskData = record
      Task: TWMCommandOrNotification;
   end;

   pEventData = ^TEventData;
   TEventData = record
      Event: Pointer;
      Vdgr: TVdgr;
   end;

   TExternalVideoGrabber = record
      Vdgr: TVdgr;
      UniqueID: LongInt;
   end;

   TVdgr = class (TObject)
    private
      Intf: TJxdVideoGrabber;

      // BEGIN EXPOSED PROPERTIES
      FASFSettings: TASFSettings;
      FASFMediaServerPublishingPoint: String;
      FASFNetworkMaxUsers: LongInt;
      FASFNetworkPort: LongInt;
      FASFProfile: Integer;
      FASFProfileFromCustomFile: String;
      FAssociateAudioAndVideoDevices: Boolean;
      FAudioCompressor: LongInt;
      FAutoConnectRelatedPins: Boolean;
      FAudioDevice: LongInt;
      FAudioDeviceRendering: Boolean;
      FAudioRecording: Boolean;
      FAutoFilePrefix: string;
      FAutoFileName: TAutoFileName;
      FAudioFormat: TAudioFormat;
      FAutoRefreshPreview: Boolean;
      FAutoStartPlayer: Boolean;
      FAutoStartPreview: Boolean;
      FAVIFormatOpenDML: Boolean;
      FBackgroundColor: TColor;
      FBorderStyle: TBorderStyle;
      FBurstCount: LongInt;
      FBurstInterval: LongInt;
      FBurstMode: Boolean;
      FBurstType: TFrameCaptureDest;
      FBusy: Boolean;
      FBusyCursor: TCursor;
      FCameraControlSettings: Boolean;
      FCaptureFileExt: string;
      FCheckVMR7Location: Boolean;
      FColorKeyEnabled: Boolean;
      FUniqueID: LongInt;
      FCompressionMode: TCompressionMode;
      FCompressionType: TCompressionType;
      FDVRgb219: Boolean;
      //FDVEncodingResolution: TDVSize; DVENCODE
      //FDVEncodingVideoStandard: TDVVideoStandard; DVENCODE
      //FDVEncodingVideoFormat: TDVVideoFormat; DVENCODE
      FDVReduceFrameRate: Boolean;
      FEventNotificationSynchrone: Boolean;
      FFrameBuffers: LongInt;
      FFrameCaptureWithoutOverlay: Boolean;
      FFrameCaptureZoomSize: LongInt;
      FFrameGrabber: TFrameGrabber;
      FFrameGrabberCurrentRGBFormat: TFrameGrabberRGBFormat;
      FFrameGrabberRGBFormat: TFrameGrabberRGBFormat;
      FFrameGrabberSynchrone: Boolean;
      FHoldRecording: Boolean;
      FInitializedAtRuntime: Boolean;
      FIsRecordingPaused: Boolean;
      FIsAudioInputBalanceAvailable: TTriState;
      FIsPlayerAudioStreamAvailable: TTriState;
      FIsTVAutoTuneRunning: Boolean;
      FIsTunerInputSelected: Boolean;
      FJPEGPerformance: TJPEGPerformance;
      FJPEGProgressiveDisplay: Boolean;
      FJPEGQuality: TJPEGQualityRange;
      FLast_BurstFrameCapture_FileName: string;
      FLast_CaptureFrameTo_FileName: string;
      FLogoDisplayed: Boolean;
      FLogoLayout: TLogoLayout;
      FLogoBitmap: TBitmap;
      FMpegStreamType: TMpegStreamType;
      FMultiplexedSlave: array[MULTIPLEXEDSLAVE_MINBOUND..MULTIPLEXEDSLAVE_MAXBOUND] of TExternalVideoGrabber;
      FMultiplexedSlaveFrameRate: LongInt;
      FMultiplexedRole: TMultiplexedRole;
      FMuteAudioRendering: Boolean;
      FNetworkStreaming: TNetworkStreaming;
      FNormalCursor: TCursor;
      FNotificationMethod: TNotificationMethod;
      FNotificationPriority: TThreadPriority;
      FNotificationSleepTime: LongInt;
      FNotificationSleepTimeUsed: LongInt;
      FPlayerAudioCodec: String;
      FPlayerAudioRendering: Boolean;
      FPlayerDVSize: TDVSize;
      FPlayerDuration: Int64;
      FPlayerFastSeekSpeedRatio: LongInt;
      FPlayerFileName: string;
      FPlayerFrameCount: Int64;
      FPlayerForcedCodec: string;
      FPlayerRefreshPausedDisplay: Boolean;
      FPlayerSpeedRatio: Double;
      FPlayerTrackBar: TTrackBar;
      FPlayerVideoCodec: String;
      FPreallocCapFileCopiedAfterRecording: Boolean;
      FPreallocCapFileEnabled: Boolean;
      FPreallocCapFileName: string;
      FPreallocCapFileSizeInMB: LongInt;
      FPreviewZoomSize: LongInt;
      FRecordingBacktimedFramesCount: LongWord;
      FRecordingCanPause: Boolean;
      FRecordingFileName: string;
      FRecordingInNativeFormat: Boolean;
      FRecordingMethod: TRecordingMethod;
      FRecordingOnMotion_MotionThreshold: Double;
      FRecordingOnMotion_Enabled: Boolean;
      FRecordingOnMotion_NoMotionPauseDelayMs: LongInt;
      FReencodingSettings: TReencodingSettings;
      FSampleCapture_Audio: TSampleCapture;
      FSampleCapture_Video: TSampleCapture;
      FSampleCaptureAsyncEvent: Boolean;
      FShapeOverlay: TShape;
      FShapeOverlayEnabled: Boolean;
      //FShowDialogs: TDialogs;
      FSpeakerControl: Boolean;
      FStoragePath: String;
      FStoreDeviceSettingsInRegistry: Boolean;
      FStreamingURL: String;
      FSynchronized: Boolean;
      FTextOverlayAlign: TTextOverlayAlign;
      FTextOverlayBkColor: TColor;
      FTextOverlayEnabled: Boolean;
      FTextOverlayFont: TFont;
      FTextOverlayLeft: LongInt;
      FTextOverlayRight: LongInt;
      FTextOverlayString: string;
      FTextOverlayTop: LongInt;
      FTextOverlayTransparent: Boolean;
      FTranslateMouseCoordinates: Boolean;
      FTVChannelInfo: TTVChannelInfo;
      FTVUseFrequencyOverrides: Boolean;
      FVideoCompression_KeyFrameRate: LongInt;
      FVideoCompression_PFramesPerKeyFrame: LongInt;
      FVideoCompression_Quality: Double;
      FVideoCompression_WindowSize: LongInt;
      FVideoCompressor: LongInt;
      FVideoControlSettings: Boolean;
      FVideoDevice: LongInt;
      FVideoEffects: TVideoEffects;
      FVideoFromImages_RepeatIndefinitely: Boolean;
      FVideoFromImages_SourceDirectory: String;
      FVideoFromImages_TemporaryFile: String;
      FVideoFromImages_BitmapsSortedBy: TFileSort;
      FVideoQualitySettings: Boolean;
      FVideoRenderer: TVideoRenderer;
      FVideoSource: TVideoSource;
      FVideoSource_FileOrURL: String;
      FVideoSource_FileOrURL_StartTime: int_64;
      FVideoSource_FileOrURL_StopTime: int_64;
      FVideoSourceHeight: LongInt;
      FVideoSourceWidth: LongInt;
      FUploadToDV_Device: LongInt;
      // END EXPOSED PROPERTIES

      F_AMGraphStreams: IAMGraphStreams;
      F_AMAnalogVideoDecoder: IAMAnalogVideoDecoder;
      F_AMAudioCrossbar: IAMCrossbar;
      F_AMAudioDevCrossbar: IAMCrossbar;
      F_AMDroppedFrames: IAMDroppedFrames;
      F_AMExtTransport: IAMExtTransport;
      F_AMTimeCodeReader: IAMTimeCodeReader;
      F_AMTVAudio: IAMTVAudio;
      F_AMTVTuner: IAMTvTuner;
      F_AMVideoControl: IAMVideoControl;
      F_AMVideoCrossbar: IAMCrossbar;
      F_AMVideoQuality: IAMVideoProcAmp;
      F_AMCameraControl: IAMCameraControl;
      F_AMVideoStreamConfig: IAMStreamConfig;
      F_AMAudioInputMixerPin: IAMAudioInputMixer;
      F_AMAudioInputMixerGeneral: IAMAudioInputMixer;
      F_PushSourceConfig: IPushSourceConfig;
      F_AudioCompressor: IBaseFilter;
      F_AudioDevice: IBaseFilter;
      F_AudioRenderPin: IPin;
      F_CaptureGraphBuilder2: ICaptureGraphBuilder2;
      F_CustomClock: ICustomClock;
      F_FilterGraph2: IFilterGraph2;
      F_AVIFileMux: IBaseFilter;
      F_AVIFileSink: IFileSinkFilter;
      F_ASFFileMux: IBaseFilter;
      F_ASFFileSink: IFileSinkFilter;
      F_GraphBuilder: IGraphBuilder;
      F_IQualProp: IQualProp;
      F_MediaControl: IMediaControl;
      F_MediaSeeking: IMediaSeeking;
      F_MediaEventEx: IMediaEventEx;
      F_ReferenceClock: IReferenceClock;
      F_ScCapturePinAudio: IPin;
      F_ScCapturePinVideo: IPin;
      F_VideoCompressor: IBaseFilter;
      F_VideoDevice: IBaseFilter;
      F_VideoDeviceKsPropertySet: IKsPropertySet;
      //F_VideoDevicePinKsPropertySet: IKsPropertySet;
      F_VideoDeviceSelectedPin: IPin;
      F_VideoCapturePin: IPin;
      F_AudioRecordingPin: IPin;
      F_VideoPreviewPin: IPin;
      F_VideoFrameStep: IVideoFrameStep;
      F_Overlay: IOverlay;
      F_ScPreviewPin: IPin;
      F_GraphVideoWindow: IVideoWindow;
      F_TransformConfig: ITransformConfig;

      F_WMWriterNetworkSink: IWMWriterNetworkSink;
      F_WMWriterPushSink: IWMWriterPushSink;

      FApplyingSetAudioDevice: Boolean;
      FApplyingSetAudioDeviceDone: Boolean;
      FApplyingSetVideoDevice: Boolean;
      FApplyingSetVideoDeviceDone: Boolean;
      FAudioRegSave: TAudioRegSave;
      FGlobalRegSave: TGlobalRegSave;
      FAudioRendering: TAudioRendering;
      FAutoTuningStepThread: TAutoTuningStepThread;
      FBorderThickness: LongInt;
      FCameraControl: T_CameraControlSettings;
      FColorKeyLow: TColor;
      FColorKeyHigh: TColor;
      FColorKeysDefault: Boolean;
      FCopyingPreallocData: Boolean;
      FCrossbar: array[0..1] of TCrossbar;
      FCrossbarAutoRouter: TCrossbarTree;
      FCurrent: TCurrentParams;
      FCurrentFrameData: TCurrentFrameData;
      FCurrentParamsInitialized: Boolean;
      FDestroying: Boolean;
      FDiscovering: Boolean;
      FDynamicallyCreatedDone: Boolean;
      FExternalSourceFrameData: TExternalSourceFrameData;
      FFrameRate: LongInt;
      FFilterState: TFilter_State;
      FFrameGrabberMediaType: PAM_MEDIA_TYPE;
      FFrameInfo_Current: TCurrentFrameInfo;
      FFrameInfo_Grabber: TCurrentFrameInfo;
      FFrameInfo_Transmit: TCurrentFrameInfo;
      FGetTimeFromClock: Boolean;
      FGraphAccessAllowed: Boolean;
      FGraphState: TGraphState;
      FGraphType: TCurrentState;
      FGrabberHandlers: array[low (TGrabberHandlers) .. high (TGrabberHandlers)] of TGrabberHandler;
      FInFrameProgressRunning: Boolean;
      FLastPreviewFailed: Boolean;
      FLastReencodingSourceFileName: String;
      FLastReencodingNewFileName: String;
      FMotionDetector: TImplMotionDetector;
      FMPEGWriterBaseFilterName: String;
      FMPEGWriterFilter: String;
      FMPEGWriterPropertySet: String;
      FMultiplexedMaster: TExternalVideoGrabber;
      FMustReencodeRecordedFile: Boolean;
      FMutedSPKDevice: Integer;
      FMutedSPKDeviceInput: Integer;
      FNeedFrameOverlayDC: Boolean;
      FNotifyingFrame: Boolean;
      FOutputFileName: String;
      FOverlayRendererW: TRendererW;
      FPlayerBackwardTimerEnabled: Boolean;
      FPlayerBufferingData: Boolean;
      FPlayerCanRefreshPosition: Boolean;
      FPlayerCanSeek: Boolean;
      FPlayerFailedToInsertFrameGrabber: Boolean;
      //FPpSaver_VideoDevice: TPpSaver;
      FPpSaver_MPEGWriter: TPpSaver;
      FPreallocatedFileCancelCreation: Boolean;
      FPreallocatedFileSuccessfullyCreated: Boolean;
      FPreferredVideoHeight: LongInt;
      FPreferredVideoWidth: LongInt;
      FProcessingCommand: Boolean;
      FProcessingRGBFrame: Boolean;
      FProcessingStopGraph: Boolean;
      FPropertyPageSaver: TPropertyPageSaverBase;
      FpVideoDeviceInUse: pBoolean;
      FPushSourceConfig: TPushSourceConfig;
      FRaiseBacktimedFramesCountReached: Boolean;
      FRaiseBacktimedFramesCountReachedDone: Boolean;
      FRaiseDeviceLost: Boolean;
      FRaiseDiskFull: Boolean;
      FRaiseEndOfStream: Boolean;
      FRaiseGraphError: Boolean;
      FRaisePlayerStartBuffering: Boolean;
      FRaisePlayerEndBuffering: Boolean;
      FRaiseReencodingStreamControlStopped: Boolean;
      FRealFrameRate: LongInt;
      FRealRecordingFileName: string;
      FRecordingAutoFileSequentialCountIndex: LongInt;
      FRecordingBacktimedFramesArray: TList;
      FRecordingBacktimedFramesArrayIndex: LongWord;
      FRecordingDuration: Int64;
      FRecordingFromBitmap: TRecordingFromBitmap;
      FRecordingResultNotifiedAfterReencoding: Boolean;
      FRecordingStarted: Boolean;
      FRecordingSubtype: TGUID;
      FRecordingSuccessful: Boolean;
      FReencodeOrRecopyDataSucceeded: Boolean;
      FReencodingProgressEndTime: int64;
      FReencodingProgressInfo: TProgressInfo;
      FReencodingCopyingPreallocatedFile: Boolean;
      FRenderingAudio: Boolean;
      FResizingWindow: Boolean;
      FRestartingGraph: Boolean;
      FSampleInfoAudio: TSampleCaptureInfo;
      FSampleInfoVideo: TSampleCaptureInfo;
      FSavedBalance: LongInt;
      FSavedVolume: LongInt;
      FSaveSequentialFileCount: LongInt;
      FShapeOverlayList: TList;
      FSlaveMultiplexedData: TSlaveMultiplexedFrameBitmapData;
      FStoragePath_DoUpdate: Boolean;
      FStreamingHostName: String;
      FStreamingHostPort: Word;
      FStretchPreferredVideoSize: Boolean;
      FTaskThread: TTaskThread;
      FTaskList: TCsList;
      FEventList: TCsList;
      FTemporaryRecordingFileName: string;
      FTextOverlayCustomVars: array[0..MAXCUSTOMVARS] of String;
      FTextOverlayData: array[0..1] of TTextOverlayData;
      FTextOverlayDataInUse: LongInt;
      FThirdPartyFilter: array[0..TThirdPartyFilterListBound, 0..ThirdPartyFilterMaxCount - 1] of TThirdPartyFilterData;
      FTimerActivateReadyToStart: TTimer;
      FTransmitFrameInfoSection: TRTLCriticalSection;
      FTransformConfig: TTransformConfig;
      FTVFrequencyOverrideInUse: Boolean;
      FTVProcessingTVAutoScan: Boolean;
      FTVScanCurrentChannel: LongInt;
      FTVScanCurrentCountryCode: LongInt;
      FTVScanCurrentTunerInputType: LongInt;
      FTVScanMaxChannel: LongInt;
      FTVScanStopRequest: Boolean;
      FVideoFromImages: TVideoFromImages;
      FVideoPinCategoryUsed: pGUID;
      FVideoPortHeight: LongInt;
      FVideoPortWidth: LongInt;
      FVideoRegSave: TVideoRegSave;
      FVideoRendererW: TRendererW;
      FVideoRendererW2: TRendererW;
      FVideoQuality: T_VideoQualitySettings;
      FVideoSizes: TstringList;
      FVideoSubtypes: TstringList;
      FVideoWindow: TVideoWindow;
      FVideoWindow2: TVideoWindow;
      FUseMasterStream: TMasterStream;
      FUsedPreallocFileName: String;

      //modify by terry at 2010-06-12
      a: TAudioFilter;
      isV: Boolean;
      //end modify



      constructor Create (VideoGrabber: TJxdVideoGrabber; IsInDesignMode: Boolean);
      destructor Destroy; override;

      function  ActivateAudioInputAndSetValues: Boolean;
      function ActivateGraph: Boolean;
      procedure AddDefaultFormats;
      //function  AddDVMuxAndDVDevice (out MuxFilter: IBaseFilter): Boolean;  DVENCODE
      function  AddFilter (pFilter: IBaseFilter; DeviceName: string): Boolean;
      function  AddFilterByName (ClassId: pGUID; FilterName: String; MonikerNameId: TMonikerNameId; out Filter: IBaseFilter): Boolean;
      function  AddFilterGetInput (ClsidFilter: pGUID; FilterName: string; out Filter: IBaseFilter; out FilterIn: IPin): Boolean;
      function  AddFilterGetInput2Outputs (ClsidFilter: pGUID; FilterName: string; out Filter: IBaseFilter; out FilterIn: IPin; out FilterOut1, FilterOut2: IPin): Boolean;
      function  AddFileWriterFilter: Boolean;
      procedure AddFormatInList (List: TStringList; x, y: LongInt);
      function  AddRendererFilter (FilterName: string; Renderer: pRenderer; CanUseVMR: Boolean; var VMRUsed: Boolean): Boolean;
      function  AddRendererFilterGetPin (FilterName: string; Renderer: pRenderer; out FilterIn: IPin; CanUseVMR: Boolean; var VMRUsed: Boolean): Boolean;
      procedure AddSubtypeInList (List: TstringList; pmt: PAM_MEDIA_TYPE);
      procedure AddSubtypesFromPin (var Pin: IPin);
      function  AddTransform (var Filter: IBaseFilter; VideoRotation: Boolean; HalfSizeDeinterlacing: Boolean; CustomSubtype: Boolean; CustomSubtypepGUID: pGUID; CustomTransform: TCustomTransform; CustomCalculateMediaType: TCustomCalculateMediaType): Boolean;
      procedure AdjustVideoCompressionSettings;
      function  Allow (Options: TSetCurrentState; Level: LongInt; RequireLiveDevices: Boolean): Boolean;
      procedure ApplyNotificationSleepTime;
      procedure ApplyPlayerSpeedRatio (Value: Double);
      function  ApplyReencodingPositions (ReencodingSettings: pReencodingSettings): Boolean;
      function  ApplySetAudioDevice: Boolean;
      function  ApplySetVideoDevice: Boolean;
      procedure ApplyVideoControlMode;
      procedure AssignPpSaver (ppSaver: pPpSaver; InterfaceId: String; RegInterfaceId: String);
      procedure AssociateVideoWindows;
      function  AudioCompressorDialog: Boolean;
      function  AudioDeviceDialog: Boolean;
      function  AudioInputsCount: LongInt;
      procedure AudioStreamConfigSetFormat (var Pin: IPin);
      function  AutoGenerateFileName (AutoFileNameType: TAutoFileNameType; Extension: string; var AutoFileSequentialCountIndex: LongInt): string;
      function  BindAndAddCompressor (var FilterGraph: IFilterGraph2; var DeviceClass: TDevices; var CurrentDevice: LongInt; ForcedName: String; out DeviceFilter: IBaseFilter; DoLogInfo: Boolean): Boolean;
      function  BindAndAddDevice (var FilterGraph: IFilterGraph2; var DeviceClass: TDevices; var CurrentDevice: LongInt; ForcedName: String; out DeviceFilter: IBaseFilter; CheckSingleBindedDevice: Boolean; var pSingleBindedDevice: pBoolean; DoLogInfo: Boolean; InputName: String): Boolean;
      procedure BindAudioSection;
      function  BindPpSaver (ppSaver: pPpSaver; ppInterface: IUnknown): Boolean;
      function  BindPushSource (var VideoOut: IPin; GetVideoFormatBmiInfoCB: TGetVideoFormatBmiInfoCB; GetVideoFormatPMediaTypeCB: TGetVideoFormatPMediaTypeCB; GetSampleDataCB: TGetSampleDataCB): Boolean;
      function  Build_Capture_And_Preview: Boolean;
      function  Build_Capture_DVMode1: Boolean;
      function  Build_File_Rendering (FileNameOrUrl: String; InsertAudioTee: Boolean; var VideoOut: IPin; var AudioOut: IPin) : Boolean;
      function  Build_NotNativeDVPreview: Boolean;
      function  Build_Player_Rendering: Boolean;
      function  Build_Preview: Boolean;
      function  Build_RawCapture: Boolean;
      function  BuildNonVisibleVideoGraph: Boolean;
      procedure CalcSize (var w, h: LongInt);
      function  CanAssociateAudioAndVideoDevices: Boolean;
      function  CanInvokeEvent (Event: TPObj): Boolean;
      function  CanInvokeEventWithoutHandle (Event: TPObj): Boolean;
      function  CanCompressAudio: Boolean;
      function  CanCompressVideo: Boolean;
      function  CanPerformSetVideoFormatOnThisDevice: Boolean;
      procedure ChangeBusyStateAndCursor (Value: Boolean);
      procedure ChangeDisplayParent (Renderer: pRenderer; UnSetParent: Boolean);
      procedure ChangeDVResolution (DVDecFilter: IBaseFilter);
      function  ChangeGraphState (NewState: TFilter_State; LogTrace: String): Boolean;
      procedure CheckApplySetAudioVideoDevices;
      procedure ClearMutedAudioDeviceInput;
      procedure ClearPpSaver (ppSaver: pPpSaver);
      function  ConfDm (Graph: IGraphBuilder; OutPin: IPin; out Pin1, Pin2: IPin): Boolean;
      function  ConfDMux (var Filter: IBaseFilter; pmt: PAM_MEDIA_TYPE; PinName: String; StrId: ULONG; var OutPin: IPin): Boolean;
      function  ConnectPins (FilterOut: IBaseFilter; PinOutName: String; PinOutIsSub: Boolean; FilterIn: IBaseFilter; PinInName: string; PinInIsSub: Boolean): Boolean; overload;
      function  ConnectPins (var PinOut: IPin; FilterIn: IBaseFilter; PinInName: string; PinInIsSub: Boolean): Boolean; overload;
      function  ConnectPins (FilterOut: IBaseFilter; PinOutName: String; PinOutIsSub: Boolean; PinIn: IPin): Boolean; overload;
      function  ConnectMPEGWriter: Boolean;
      function  CheckAndOrCreatePreallocatedFile (CaptureGraphBuilder2: ICaptureGraphBuilder2; PreallocFileName: String): Boolean;
      function  CheckCustomMPEGRecording (CheckAnyWay: Boolean) : String;
      function  CheckDualDisplay: Boolean;
      function  CheckFileNameExtension (FileName: string; FileNameType: TAutoFileNameType): string;
      procedure ClearGraph (ClearGraphState: Boolean);
      procedure ClearGrabberHandlers (Init: Boolean);
      procedure ClearOldSavedFrame;
      procedure ClearWindow (Renderer: pRenderer);
      function  CompleteGraphBuilding (CanActivateThreads: Boolean; FileMuxSetMasterStream: Boolean) : Boolean;
      procedure ConfCxHap;
      function  Connect (var OutPin, InPin: IPin): Boolean;
      function  ConnectIn (IsASF: Boolean; var OutPin: IPin; ToFilter: IBaseFilter; MajorType: pGUID): Boolean;
      function  ConnectInAndControl (IsASF: Boolean; var OutPin: IPin; ToFilter: IBaseFilter; MajorType: pGUID; var ControlledPin: IPin; UsePmt: PAM_MEDIA_TYPE): Boolean;
      function  ConnectVideoPort: Boolean;
      function  CreateDeviceGraph: Boolean;
      procedure CreateDisplayForm (Renderer: pRenderer);
      function  CreateGrabberFilter (GrabberFilterType: TGrabberFilterType; FrameGrabberRGBFormat: TFrameGrabberRGBFormat; GrabberHandler: pGrabberHandler; UseConnectionMediaType: PAM_MEDIA_TYPE): Boolean;
      function  CreateBaseGraph: Boolean;
      function  CreateFilterGraph: Boolean;
      function  CreateSetOfBitmaps: Boolean;
      function  CurrentCaptureFileExt: String;
      function  CurrentStoragePath: String;
      function  DecodeVideoSize (FormatIndex: LongInt; var x, y : LongInt): Boolean;
      function  DecodeVideoSizeUsingDefault (FormatIndex: LongInt; var x, y : LongInt): Boolean;
      function  DecodeVideoSubtype (var Subtype: TGUID): Boolean;
      function  DetectCxHap: Boolean;
      function  DiscoverAudioDevice: Boolean;
      function  DiscoverVideoDevice: Boolean;
      function  DoGrabFrame (UsedBurstType: TFrameCaptureDest; FileName: string; IsCaptureFrameTo: Boolean; MustReturnFrame: Boolean): Boolean;
      procedure DoPausePlayer (Stopped: Boolean);
      procedure DoProcessEvent (EventData: pEventData);
      function  DoReencoding (ReencodingSettings: pReencodingSettings): Boolean;
      procedure DrawOverBitmap (CurrentFrameInfo: pCurrentFrameInfo; Bitmap: HBITMAP);
      procedure DynamicallyCreated;
      procedure EnableDisableVideoEffects;
      procedure EnableDisableVideoTransform;
      function  ExtractRenderingPins (var  Filter: IBaseFilter; out VideoPin: IPin; out AudioPin: IPin): Boolean;
      procedure ExtractTimeInfo (CurrentFrameInfo: pCurrentFrameInfo);
      procedure FileMuxSettings (SetMasterStream: Boolean);
      function  FindRenderer(pMediaType: PGUID; out ppFilter: IBaseFilter; out ppInputPin: IPin; GetVideoSizes: Boolean): Boolean;
      procedure FindScPins;
      procedure FindVideoWindow (Renderer: pRenderer);
      function  DistributeSlaveMediaType: Boolean;
      function  LinkSlaves: Boolean;
      function  SlavesNeedMotionDetection: Boolean;
      function  GetAudioInputName: String;
      function  GETDVDateTime (CurrentFrameInfo: pCurrentFrameInfo; var DVDateTime: TDateTime): Boolean;
      function  GetPMTFromSubtype_MustBeFreed (var Pin: IPin; RequiredFormatType: pGUID): PAM_MEDIA_TYPE;
      procedure GetWindowHandle (Renderer: pRenderer);
      function  GetCurrentSubtypeGUID (var SubtypeGUID: String): Boolean;
      function  HoldStreaming: Boolean;
      procedure IdentifyCodecs;
      procedure InitAudioRegSave (AudioRegSave: pAudioRegSave);
      procedure InitGlobalRegSave (GlobalRegSave: pGlobalRegSave);
      procedure InitVideoRegSave (VideoRegSave: pVideoRegSave);
      function  InsertASFRecording (UseSmartTee: Boolean; var VideoOut: IPin): Boolean;
      procedure InsertAudioDeviceRendering;
      function  InsertNullRenderer (var VideoOut: IPin; RetrieveVideoFormat: Boolean): Boolean;
      function  InsertExistingFilter (var Filter: IBaseFilter; var OutputPin: IPin): Boolean;
      function  InsertFilterInlineGetFilter (CLSID: pGUID; FilterName: string; var BaseFilter: IBaseFilter; RequiredOutputMediaType: pGUID; var OutputPin: IPin): Boolean;
      function  InsertFilterInline (CLSID: pGUID; FilterName: string; RequiredOutputMediaType: pGUID; var OutputPin: IPin): Boolean;
      procedure InsertOverlayMixer (var OutputPin: IPin);
      function  InsertSmartTee (CLSID: pGUID; FilterName: string; var OutputPin: IPin; var CaptureOut, PreviewOut: IPin): Boolean;
      function  InsertSmartTeeBeforeFilter (FilterName: String; var ScPin: IPin): Boolean;
      function  InsertAudioRenderer (var OutputPin: IPin; FilterName: string): Boolean;
      function  InsertVideoDisplay (var VideoOut: IPin): Boolean;
      function  InsertVideoRenderer (var OutputPin: IPin): Boolean;
      function  InsertFilter (CLSID: pGUID; var OutputPin: IPin; FilterName: string; var BaseFilter: IBaseFilter): Boolean;
      function  InsertGrabberFilterDerived (CLSID_IntermFilter: pGUID; var OutputPin: IPin; GrabberFilterType: TGrabberFilterType; GrabberHandler: pGrabberHandler): Boolean;
      function  InsertGrabberFilter (var OutputPin: IPin; GrabberFilterType: TGrabberFilterType; FrameGrabberRGBFormat: TFrameGrabberRGBFormat; GrabberHandler: pGrabberHandler; UseConnectionMediaType: PAM_MEDIA_TYPE): Boolean;
      procedure InsertThirdPartyFilters (Location: TThirdPartyFilterList; var OutputPin: IPin);
      function  InsertTransform (var VideoOut: IPin; VideoRotation: Boolean; HalfSizeDeinterlacing: Boolean; CustomSubtype: Boolean; CustomSubtypepGUID: pGUID; CustomTransform: TCustomTransform; CustomCalculateMediaType: TCustomCalculateMediaType): Boolean;
      procedure InstallClk;
      function  InsertASFFilter: Boolean;
      function  IsASFRecordingOrStreaming: Boolean;
      function  InstallDisplay (var OutputPin: IPin; CanUseVMR: Boolean): Boolean;
      function  IsDVSource: Boolean;
      function  IsLiveVideoSource: Boolean;
      function  IsMPEGSource: Boolean;
      function  IsPlayerStreaming: Boolean;
      function  IsSynchronized: Boolean;
      function  IsWindowEmbedded (VideoWindow: TVideoWindow): Boolean;
      function  LoadCurrentAudioDeviceSettingsFromRegistry: Boolean;
      function  LoadCurrentVideoDeviceSettingsFromRegistry: Boolean;
      function  LoadGlobalSettingsFromRegistry: Boolean;
      function  LoadFilter (clsid: pCLSID; Prefix: String; BufferLoaderFunction: TBufferLoaderFunction; var Handle: HMODULE; ProcName: String; var Filter: IBaseFilter; ObjName: string): Boolean;
      function  LoadSettingsAndVideoStreamConfigCapabilitiesFromRegistry: Boolean;
      function  LoadWMVASFNetLib: Boolean;
      function  LogB (Test: Boolean; Level: LongInt; LogType: TLogType; Msg: string): Boolean;
      function  LogH (Hr: Hresult; Level: LongInt; LogType: TLogType; Msg: string): Boolean;
      procedure LogTrees;
      function  MouseEventIsMovingWindow (Renderer: pRenderer): Boolean;
      function  MustResizeControl (VideoWindow: TVideoWindow): Boolean;
      procedure NewCaptureFileDuringRecording;
      function  NativeRecording: Boolean;
      function  NativeRecordingSplitterRequired: Boolean;
      function  NativeRawCapture: Boolean;
      function  NoDevicesOrIndexOutOfRange (Index: LongInt; Count: LongInt; DeviceType: String) : Boolean;
      procedure OnDisplayFormClick (Sender: TObject);
      procedure OnDisplayFormDblClick (Sender: TObject);
      procedure OnDisplayFormKeyUp (Sender: TObject; var Key: Word; Shift: TShiftState);
      procedure OnDisplayFormKeyPress (Sender: TObject; var Key: Char);
      procedure OnDisplayFormMouseDown (Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: LongInt);
      procedure OnDisplayFormMouseMove (Sender: TObject; Shift: TShiftState; X, Y: LongInt);
      procedure OnDisplayFormMouseUp (Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: LongInt);
      procedure  PerformDetectMotion (var MustReturnFrame: Boolean);
      procedure PerformSetVideoInput (Value: LongInt);
      function  PlayerNetworkStreaming: Boolean;
      procedure PlayerTrackBarChange (Sender: TObject);
      procedure PostCommand (WMCommand: TWMCommandOrNotification);
      procedure PostEvent (Event: Pointer);
      procedure PostStopGraphMessage;
      procedure PrepareAudioRendering;
      function  PrepareRecordingFile (var RecordingFile: String): Boolean;
      function  PreviewStreamRequired: Boolean;
      procedure ProcessCrossbars;
      function  ProcessCommand: Boolean;
      function  ProcessEvent: Boolean;
      function  ProcessExtTransport: Boolean;
      procedure ProcessFrameOverlays (CurrentFrameInfo: pCurrentFrameInfo; Bitmap: HBitmap; Dib: pDibSection);
      procedure ProcessFrameTime (CurrentFrameInfo: pCurrentFrameInfo; StartTime: int64);
      procedure ProcessGrabFrames;
      procedure ProcessGraphNotify;
      procedure ProcessGraphRunning;
      procedure ProcessReencoding;
      function  ProcessNotifyFrame: Boolean;
      procedure ProcessNotifyEvent;
      procedure ProcessNotifyDVCommandCompleted;
      procedure ProcessOnReadyToStart (Sender: TObject);
      procedure ProcessOverlayColorKey;
      procedure ProcessPlayByStep (Initial: Boolean);
      function  ProcessPlayerNewPosition (Position: int64): int64;
      procedure ProcessStopGraph;
      procedure ProcessTaskCommand (WMCommand: TWMCommandOrNotification);
      procedure ProcessTVStartAutoScan;
      procedure ProcessTVScanning;
      function  QueryPlayerMediaSeeking: Boolean;
      function  QueryReencodingMediaSeeking: Boolean;
      procedure ReadStoredInterfaceValues;
      function  ReadTimeCode (CurrentFrameInfo: pCurrentFrameInfo): Boolean;
      function  RecordingAndCompressingVideo: Boolean;
      procedure RecordingStartedPostProcessing;
      procedure ReduceDVFrameRate (var DVSplitter: IBaseFilter);
      function  ReencodeOrRecopyFile (ReencodingSettings: pReencodingSettings; CopyingPreallocatedFile: Boolean; UserReencoding: Boolean): Boolean;
      function  ReencodeCapturedFileIfRequired: Boolean;
      procedure RefreshPreview (LogTrace: String);
      procedure RefreshWindowPos (Renderer: pRenderer);
      function  ReinitCurrentParams (FirstInitialization: Boolean): Boolean;
      procedure ReinitCurrentFrameData;
      procedure ReinitFrameInfos;
      function  ReleaseStreaming: Boolean;
      procedure RemoveFilters;
      function  RenderAudioDevice: Boolean;
      procedure ResizeRenderer (Renderer: pRenderer);
      procedure ResizeVideoWindows (ProcessMessages: Boolean);
      function  RestartGraph (NewState: TCurrentState): Boolean;
      function  RestoreGraph (State: TSaveFilterState; out OutPin: IPin): Boolean;
      procedure RestoreCameraControlSettingsFromRegistry;
      procedure RestoreVideoQualitySettingsFromRegistry;
      procedure RetrieveCameraControlCurrentSettings;
      function  RetrieveCommonInterfaces (var Pin: IPin): Boolean;
      function  RetrieveDVSignalType (var AvgTimePerFrame: LongInt): Boolean;
      procedure RetrieveVideoControlCaps (var Pin: IPin);
      procedure RetrieveVideoFormatInfo (var InPin: IPin);
      function  RetrieveVideoPins: Boolean;
      procedure RetrieveVideoQualityCurrentSettings;
      function  ReturnCrossbarInput: LongInt;
      function  ReturnCrossbarInputs: string;
      procedure ReturnRawFrameAsync (IsVideo: Boolean; SampleCaptureInfo: pSampleCaptureInfo);
      procedure RouteAudioRelatedPin;
      procedure RunEmulatedPlayback;
      procedure SaveGlobalSettingsToRegistry;
      procedure SaveCurrentAudioDeviceSettingsToRegistry;
      procedure SaveCurrentVideoDeviceSettingsToRegistry;
      procedure SaveFrameGrabberMediaType;
      procedure ScanFormatBound (AcceptedList, RejectedList: TstringList; DevPin: iPin; pmt: PAM_MEDIA_TYPE; MWidth, MHeight, Min_W, Min_H, Max_W, Max_H: LongInt);
      procedure ScanFormatBounds (AcceptedList, RejectedList: TstringList; DevPin: IPin; pmt: PAM_MEDIA_TYPE; Mid_W, Mid_H, Min_W, Min_H, Max_W, Max_H: LongInt);
      function  ControlPinByEnabled (Pin: IPin; sType: String; Enable: Boolean): Boolean;
      function  ControlPinByTime (Pin: IPin; sType: String; StartTime, StopTime: int64; StartCookie: LongInt; StopCookie: LongInt): Boolean;
      function  SearchAudioOutOnVideoFilter (CurrentFilter: IBaseFilter; var AudioOut: IPin): Boolean;
      function  SearchNearestVideoSize (RequestedW, RequestedH: LongInt): LongInt;
      function  SearchNearestVideoSizeUsingRatio (RequestedW, RequestedH: LongInt): LongInt;
      function  SelectIndexFromList (ListValues: String; FindValue: String): LongInt;
      procedure SetAudioInputValues;
      procedure SetGraphStateBuilt;
      Procedure SetNeedFrameOverlayDC;
      procedure SetPlayer_FramePosition (Value: Int64);
      procedure SetPlayer_TimePosition (Value: Int64);
      procedure ShowDisplays;
      procedure ShowFilterDialog (Filter: IUnknown);
      function  SnapGraph (var OutPin: IPin): TSaveFilterState;
      procedure StartPlayerForwards;
      procedure StartPlayerBackwards;
      function  ThirdPartyFilterRegKeyId (GUID: TGUID): string;
      procedure TVInitState;
      procedure TVRetrieveState;
      function  TVDoSetChannel(lChannel, lVideoSubChannel, lAudioSubChannel: LongInt): Boolean;
      procedure UpdateSpeakersControl;
      procedure VFW_DiscoverVideoFormats (var Pin: IPin);
      function  VideoCompressorDialog_InLine: Boolean;
      function  VideoCompressorDialog_Rendered: Boolean;
      function  VideoDeviceDialog (Dialog: TDialog): Boolean;
      function  VideoStreamDialog: Boolean;
      function  VideoStreamConfigGetFrameRate (var FrameRateFound: LongInt): Boolean;
      procedure VideoStreamConfigGetFormat;
      procedure VideoStreamConfigGetRealFrameRate;
      function  VideoStreamConfigSetPmtFrameRate (FormatType: TFormatType; pmt: PAM_MEDIA_TYPE): Boolean;
      function  VideoStreamConfigSetFrameRate: Boolean;
      function  VideoStreamConfigSetFormat (var Pin: IPin): Boolean;
      function  VideoStreamConfigSetFormat2: Boolean;
      procedure VideoStreamConfigSetDVFormat;
      procedure VideoWindowNotify (Sender: TObject; Notification: TVideoWindowNotify; Param: LongWord);
      procedure WDM_DiscoverVideoFormats (var Pin: IPin);
      function  WDM_SetFormatFromStreamCaps (var Pin: IPin; var AMStreamConfig: IAMStreamConfig; SearchedSubtype: pGUID; SearchedWidth, SearchedHeight: LongInt): Boolean;
      function  WDMDialog (UnkFilter: IUnknown): Boolean;


end;

const
   MAXAUDIORATEGROUPS = 29;
   MAXVIDEORATEGROUPS = 18;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetCrossbarstring (Value: LongInt): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := '';
   case Value of
      PhysConn_Video_Tuner	            : Result := 'Tuner';
      PhysConn_Video_Composite	        : Result := 'Composite';
      PhysConn_Video_SVideo	            : Result := 'SVideo';
      PhysConn_Video_RGB	              : Result := 'RGB';
      PhysConn_Video_YRYBY	            : Result := 'YRYBY';
      PhysConn_Video_SerialDigital	    : Result := 'Serial Digital';
      PhysConn_Video_ParallelDigital	  : Result := 'Parallel Digital';
      PhysConn_Video_SCSI	              : Result := 'SCSI';
      PhysConn_Video_AUX	              : Result := 'AUX';
      PhysConn_Video_1394	              : Result := '1394';
      PhysConn_Video_USB	              : Result := 'USB';
      PhysConn_Video_VideoDecoder	      : Result := 'Video Decoder';
      PhysConn_Video_VideoEncoder	      : Result := 'Video Encoder';
      PhysConn_Video_SCART	            : Result := 'SCART';
      PhysConn_Video_Black	            : Result := 'black';
      PhysConn_Audio_Tuner	            : Result := 'Audio Tuner';
      PhysConn_Audio_Line	              : Result := 'Audio Line';
      PhysConn_Audio_Mic	              : Result := 'Audio Mic';
      PhysConn_Audio_AESDigital	        : Result := 'Audio AES Digital';
      PhysConn_Audio_SPDIFDigital	      : Result := 'Audio SPDIF Digital';
      PhysConn_Audio_SCSI	              : Result := 'Audio SCSI';
      PhysConn_Audio_AUX	              : Result := 'Audio AUX';
      PhysConn_Audio_1394	              : Result := 'Audio 1394';
      PhysConn_Audio_USB	              : Result := 'Audio USB';
      PhysConn_Audio_AudioDecoder	      : Result := 'Audio Decoder';
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TCrossbarTree.Create (pStartingInputPin: IPin);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   m_pStartingPin:= pStartingInputPin;
   m_CurrentRoutingIndex:= 0;
   m_RoutingList := TList.Create;
   m_RoutingItems := TList.Create;

   if m_pStartingPin = nil then Exit;

   m_RoutingRoot := TRouting.Create;

    if assigned (m_RoutingList) then begin
       BuildRoutingList(m_pStartingPin, m_RoutingRoot, 0);
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
destructor TCrossbarTree.Destroy;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pCurrent: TRouting;
begin
   while m_RoutingItems.Count > 0 do begin
      pCurrent := m_RoutingItems[0];
      pCurrent.Free;
      m_RoutingItems.Delete (0);
   end;
   m_RoutingRoot.Free;
   m_RoutingList.Free;
   m_RoutingItems.Free;
   inherited Destroy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCrossbarTree.BuildRoutingList (pStartingInputPin: IPin; pRouting: TRouting; Depth: LongInt): HRESULT;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
    hr: HRESULT;
    InputIndexRelated: LongInt;
    InputPhysicalType: LongInt;
    OutputIndexRelated: LongInt;
    OutputPhysicalType: LongInt;
    pPin: IPin;
    pStartingOutputPin: IPin;
    RoutingNext: TRouting;
    Inputs: LongInt;
    Outputs: LongInt;
    InputIndex: LongInt;
    OutputIndex: LongInt;
    pinInfo: TPIN_INFO;
    pXbar: IAMCrossbar;
begin
    Result := E_NOTIMPL;


    if not assigned (pStartingInputPin) then Exit;
    if not assigned (pRouting) then Exit;

    hr := pStartingInputPin.ConnectedTo (pStartingOutputPin);
    if (hr <> S_OK) then begin
       if Depth = 0 then begin
          Result := E_FAIL;
       end
       else begin
          Result := S_false;
       end;
       Exit;
    end;

    hr := pStartingOutputPin.QueryPinInfo(pinInfo);
    if hr = S_OK then begin
      if pinInfo.dir = PINDIR_OUTPUT then begin
        hr := pinInfo.pFilter.QueryInterface(IAMCrossbar, pXbar);
        if (hr = S_OK) then begin
            pXbar.Get_PinCounts(Outputs, Inputs);

            GetCrossbarIndexFromIPin (
                                    pXbar,
                                    @OutputIndex,
                                    false,
                                    pStartingOutputPin);

            pXbar.get_CrossbarPinInfo(
                                    false,
                                    OutputIndex,
                                    OutputIndexRelated,
                                    OutputPhysicalType);

            for InputIndex := 0 to Inputs - 1 do begin
                pXbar.get_CrossbarPinInfo(
                                        true, { Input? }
                                        InputIndex,
                                        InputIndexRelated,
                                        InputPhysicalType);

                if (InputPhysicalType < PhysConn_Audio_Tuner) then begin
                    if pXbar.CanRoute(OutputIndex, InputIndex) = S_OK then begin
                        GetCrossbarIPinAtIndex (
                                        pXbar,
                                        InputIndex,
                                        true,
                                        pPin);

                        RoutingNext := TRouting.Create;
                        m_RoutingItems.Add (RoutingNext);

                        RoutingNext.pRightRouting := pRouting;

                        pRouting.pLeftRouting := RoutingNext;

                        pRouting.pXbar := pXbar;
                        pRouting.VideoInputIndex := InputIndex;
                        pRouting.VideoOutputIndex := OutputIndex;
                        pRouting.AudioInputIndex := InputIndexRelated;
                        pRouting.AudioOutputIndex := OutputIndexRelated;
                        pRouting.InputPhysicalType := InputPhysicalType;
                        pRouting.OutputPhysicalType := OutputPhysicalType;
                        pRouting.Depth := Depth;

                        hr := BuildRoutingList (
                                    pPin,
                                    RoutingNext,
                                    Depth + 1);

                        if assigned (pPin) then pPin := nil;

                        if hr = S_OK then begin
                        end
                        else if hr = S_false then begin
                            pRouting.pLeftRouting := nil;
                            SaveRouting (pRouting);
                        end
                        else if (hr = E_FAIL) then begin
                        end;
                    end;
                end;
            end;
            pXbar:= nil;
        end
        else begin
            { Doesn't support IAMCrossbar, is a terminal pin }
            if Depth = 0 then begin
               Result := E_FAIL;
            end
            else begin
               Result := S_false;
            end;
        end;

      end;
      if assigned (pinInfo.pFilter) then pinInfo.pFilter := nil;
    end;

    if assigned (pStartingOutputPin) then pStartingOutputPin := nil;

    if Result = E_NOTIMPL then begin
       Result := S_OK;
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCrossbarTree.SaveRouting (pRoutingNew: TRouting): HRESULT;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   j, Depth: LongInt;
   prPrev: TRouting;
   pCurrent: TRouting;
begin
    Result := E_FAIL;
    if not assigned (pRoutingNew) then Exit;

    Depth := pRoutingNew.Depth + 1;

    pCurrent := pRoutingNew;

    for j := 0 to Depth - 1 do begin
      m_RoutingList.Add (pCurrent);
      if assigned (pCurrent.pXbar) then begin
        prPrev := pCurrent;
        pCurrent := pCurrent.pRightRouting;
        if assigned (pCurrent) then begin

           pCurrent.pLeftRouting := prPrev;
           pCurrent.pRightRouting := pCurrent;

           if j = 0 then begin
              pCurrent.pLeftRouting := nil;
           end;
           if j = Depth - 1 then begin
               pCurrent.pRightRouting := nil;
           end;
        end;
      end;
    end;
    Result := S_OK;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCrossbarTree.GetCrossbarIPinAtIndex(pXbar: IAMCrossbar; PinIndex: LongInt; IsInputPin: BOOL; var ppPin: IPin): HRESULT;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
    cntInPins, cntOutPins: LongInt;
    n: ULONG;
    hr: HResult;
    trueIndex: LongInt;
    i: LongInt;
    Done: Boolean;

    pFilter: IBaseFilter;
    pins: IEnumPins;

begin
  Result := E_FAIL;
  try
    ppPin := nil;

    if pXbar.Get_PinCounts(cntOutPins, cntInPins) <> S_OK then Exit;

    if IsInputPin then begin
       trueIndex := PinIndex;
    end
    else begin
       trueIndex := PinIndex + cntInPins;
    end;

    hr := pXbar.QueryInterface(IBaseFilter, pFilter);

    if hr = S_OK then begin
       hr := pFilter.EnumPins(pins);
       if hr = S_OK then begin
            i := 0;
            Done := false;
            while(pins.Next(1, ppPin, @n) = S_OK)  and (not Done) do begin
               if i = trueIndex then begin
                  Done := true;
                  Result := S_OK;
               end
               else begin
                  ppPin := nil;
               end;
               inc (i);
            end;
            Pins := nil;
        end;
        pFilter:= nil;
    end;
    if assigned (ppPin) then begin
       Result := S_OK;
    end;
  finally
     if assigned (pFilter) then pFilter := nil;
     if assigned (pins) then pins := nil;
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCrossbarTree.GetCrossbarIndexFromIPin(pXbar: IAMCrossbar; PinIndex: pLongInt; IsInputPin: BOOL; ppPin: IPin): HRESULT;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
    cntInPins, cntOutPins: LongInt;
    pP: IPin;
    pFilter: IBaseFilter;
    pins: IEnumPins;
    n: ULONG;
    fOK: Boolean;
    hr: HRESULT;
    i: LongInt;
    Done: Boolean;

begin
  fOK := false;
  Result := E_FAIL;
  try

    if pXbar.Get_PinCounts(cntOutPins, cntInPins) <> S_OK then Exit;

    hr := pXbar.QueryInterface(IBaseFilter, pFilter);

    if hr = S_OK then begin
       hr := pFilter.EnumPins(pins);
       if hr = S_OK then begin
            i := 0;
            Done := false;
            while(pins.Next(1, pP, @n) = S_OK)  and (not Done) do begin
               if ppPin = pP then begin
                  if IsInputPin then begin
                     PinIndex^ := i;
                  end
                  else begin
                     PinIndex^ := i - cntInPins;
                  end;
                  Done := true;
                  FOk := true;
               end;
               inc (i);
               pP := nil;
            end;
            Pins := nil;
        end;
        pFilter:= nil;
    end;
    if assigned (ppPin) then begin
       Result := S_OK;
    end;
    if fOK then begin
       Result := S_OK;
    end;
  finally
     if assigned (pP) then pP := nil;
     if assigned (pFilter) then pFilter := nil;
     if assigned (pins) then pins := nil;
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCrossbarTree.GetInputCount (pCount: pLongInt): HRESULT;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
    pCount^ := m_RoutingList.Count;
    Result := S_OK;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCrossbarTree.GetInputType  (Index: LongInt; PhysicalType: pLongInt): HRESULT;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pCurrent: TRouting;
begin
   Result := E_FAIL;

   if Index >= m_RoutingList.Count then Exit;

   if Index < m_RoutingList.Count then begin
      pCurrent := m_RoutingList.Items[Index];
      if assigned (pCurrent) then begin
         PhysicalType^ := pCurrent.InputPhysicalType;
         result := S_OK;
      end;
   end
   else begin
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCrossbarTree.GetInputName  (Index: LongInt; var Name: string): HRESULT;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pCurrent: TRouting;
begin
   Result := E_FAIL;
   if m_RoutingList.Count = 0 then Exit;
   if Index >= m_RoutingList.Count then Exit;
   pCurrent := m_RoutingList.Items[Index];
   if pCurrent = nil then Exit;
   Name := GetCrossbarstring (pCurrent.InputPhysicalType);
   Result := S_OK;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TCrossbarTree.SetCurrentInputFromCrossbar (Crossbar: IAMCrossbar);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   InputIndexPin: LongInt;
   PinIndexRelated: LongInt;
   PhysicalType: LongInt;
   pCurrent: TRouting;
   i: LongInt;
   Done: Boolean;
begin
   if Crossbar.get_IsRoutedTo(0, InputIndexPin) = S_OK then begin
      if Crossbar.get_CrossbarPinInfo (true, InputIndexPin, PinIndexRelated, PhysicalType) = S_OK then begin
         Done := false;
         i := 0;
         while not Done do begin
            if i = m_RoutingList.Count then begin
               Done := true;
            end
            else begin
               pCurrent := m_RoutingList[i];
               if pCurrent.InputPhysicalType = PhysicalType then begin
                  SetInputIndex (i);
                  Done := true;
               end;
               inc (i);
            end;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCrossbarTree.SetInputIndex (Index: LongInt): HRESULT;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   hr: HRESULT;
   pCurrent: TRouting;
   j: LongInt;
   Depth: LongInt;
begin
   Result := E_FAIL;

   if Index >= m_RoutingList.Count then Exit;
   if Index < 0 then Exit;

   pCurrent := m_RoutingList.Items[Index];

   if pCurrent = nil then Exit;

   Depth := pCurrent.Depth + 1;

   for j := 0 to Depth - 1 do begin
      hr := pCurrent.pXbar.Route (pCurrent.VideoOutputIndex, pCurrent.VideoInputIndex);
      if hr = S_OK then begin

         if (pCurrent.AudioOutputIndex <> -1) and (pCurrent.AudioInputIndex <> -1) then begin
            if pCurrent.pXbar.Route (pCurrent.AudioOutputIndex, pCurrent.AudioInputIndex) = S_OK then begin
               Result := S_OK;
            end;
         end;
      end;
      if (Index + j) < m_RoutingList.Count then begin
         pCurrent := m_RoutingList.Items[Index + j];
      end;
   end;

   m_CurrentRoutingIndex := Index;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCrossbarTree.GetInputIndex (Index: pLongInt): HRESULT;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Index^ := m_CurrentRoutingIndex;
   Result := S_OK;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetstringListCount (Text: string): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TstringList;
begin
      List := TstringList.Create;
      List.Text := Text;
      Result := List.Count;
      List.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function SLocation (Location: TThirdPartyFilterList): String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   case Location of
      tpf_VideoSource: Result := 'video source';
      tpf_VideoPreview: Result := 'video preview';
      tpf_VideoCapture: Result := 'video capture';
      tpf_AudioSource: Result := 'audio source';
      tpf_AudioRender: Result := 'audio render';
      tpf_AudioRecording: Result := 'audio capture';
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure FlushMessages;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not (csDestroying in Application.ComponentState) then begin
      Application.ProcessMessages;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function FindPosLastChar (c: Char; s: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Done: Boolean;
   i: LongInt;
begin
   Result := 0;
   i := Length(s);
   Done := False;
   while not Done do begin
      if i = 0 then begin
         Done := True;
      end
      else begin
         if s[i] = c then begin
            Result := i;
            Done := True;
         end
         else begin
            dec (i);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function RetrieveFileSize (const FileName: String): Int64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FileHandle: THandle;
   FindFileData: TWin32FindData;
begin
   Result := -1;
   FileHandle := FindFirstFile(PChar(FileName), FindFileData);
   if (FileHandle <> INVALID_HANDLE_VALUE) then begin
     Windows.FindClose(FileHandle);
     Int64Rec(Result).Lo := FindFileData.nFileSizeLow;
     Int64Rec(Result).Hi := FindFileData.nFileSizeHigh;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function AddOrReplaceFileNameExtension (Extension: String; FileName: String): String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   p: LongInt;
begin
   p := FindPosLastChar ('.', FileName);
   if p > 0 then begin
      Result := Copy (FileName, 1, p) + Extension;
   end
   else begin
      Result := FileName + '.' + Extension;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TSyncManager.FindTempFileByPrefix (Prefix: String): String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Done: Boolean;
   i: LongInt;
begin
   Result := '';
   i := 0;
   Done := False;
   while not Done do begin
      if i >= FTempFiles.Count then begin
         Done := True;
      end
      else begin
         if pOleStr (FTempFiles.Objects[i]) = Prefix then begin
            Result := FTempFiles[i];
            Done := True;
         end;
         inc (i);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TSyncManager.CreateTempFile (Prefix: String): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TempPath, TempFileName: PChar;
   pPrefix: array[0..10] of Char;
   i: LongInt;
begin
   Result := FindTempFileByPrefix (Prefix);
   if Result = '' then begin
      GetMem (TempPath, MAX_PATH);
      GetMem (TempFileName, MAX_PATH);
      if GetTempPath (MAX_PATH, TempPath) <> 0 then begin
         strPCopy (pPrefix, Copy (Prefix, 1, 9));
         if GetTempFileName (TempPath, pPrefix, 0, TempFileName) <> 0 then begin
            Result := TempFileName;
            i := FTemPFiles.Add (TempFileName);
            FTempFiles.Objects[i] := Pointer (StringToOLeStr (Prefix));
         end;
      end;
      FreeMem (TempPath);
      FreeMem (TempFileName);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function FindLibraryMethod (Module: HModule; ProcName: String; out RegProc: Pointer): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   RegProc := GetProcAddress(Module, PChar (ProcName));
   Result := Assigned (RegProc);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetScreenColorCount: integer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   DeviceContents: HDC;
   ColorCount: integer;
begin
   DeviceContents := GetDC(0);
   ColorCount := GetDeviceCaps(DeviceContents, BitsPixel) * GetDeviceCaps(DeviceContents, Planes);
   ReleaseDC(0, DeviceContents);
   Result := ColorCount;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function Int64ToOleVariant (Value: int64): OleVariant;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
    OleVal: OleVariant;
begin
    TPropVariant (OleVal).vt := VT_I8;
    TPropVariant (OleVal).hVal := LARGE_INTEGER (Value);
    Result := OleVal;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function OleVariantToInt64 (value: OleVariant): int64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   case TPropVariant (Value).vt of
      VT_I2     : Result := int64 (TPropVariant (Value).iVal);
      VT_I4     : Result := int64 (TPropVariant (Value).lVal);
      VT_I1     : Result := int64 (TPropVariant (Value).bVal);
      VT_UI1    : Result := int64 (TPropVariant (Value).bVal);
      VT_UI2    : Result := int64 (TPropVariant (Value).uiVal);
      VT_UI4    : Result := int64 (TPropVariant (Value).ulVal);
      VT_I8     : Result := int64 (TPropVariant (Value).hVal);
      VT_UI8    : Result := int64 (TPropVariant (Value).uhVal);
      VT_INT    : Result := int64 (TPropVariant (Value).lVal);
      VT_UINT   : Result := int64 (TPropVariant (Value).ulVal);
   else
      Result := 0;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function StructToOleVariant ( pStruct: pointer; StructSize: LongInt) : OleVariant;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
    pDest : Pointer;
begin
    Result := VarArrayCreate([0, StructSize - 1], varByte);
    pDest := VarArrayLock(Result);
    move (pStruct^, pDest^, StructSize );
    VarArrayUnlock(Result);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function OleVariantToStruct (OleStruct: OleVariant; pStruct: pointer): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
    iMax : Integer;
    pSource : Pointer;
begin
    if VarType( OleStruct ) = VarArray + VarByte then begin
       iMax := VarArrayHighBound (OleStruct, 1);
       pSource := VarArrayLock (OleStruct);
       Move(pSource^, pStruct^, iMax);
       VarArrayUnlock (OleStruct);
       Result := True;
    end
    else begin
       Result := False;
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ MPEG Stream type
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
   PROPSETID_Hap_ENCODE_CONFIG_PROPERTIES: TGUID = '{432A0DA4-806A-43a0-B426-4F2A234AA6B8}';

   Hap_ECP_SYSTEM_StreamType	=   0;

   Hap_Sys_StreamType_Program	     = 101;
   Hap_Sys_StreamType_Program_DVD    = 102;
   Hap_Sys_StreamType_Program_DVD_MC = 103;
   Hap_Sys_StreamType_Program_SVCD   = 104;
   Hap_Sys_StreamType_MPEG1          = 201;
   Hap_Sys_StreamType_MPEG1_VCD      = 202;

function StreamType (Value: dword): TMpegStreamType;
begin
   case Value of
      Hap_Sys_StreamType_Program        : Result := mpst_Program;
      Hap_Sys_StreamType_Program_DVD    : Result := mpst_Program_DVD;
      Hap_Sys_StreamType_Program_DVD_MC : Result := mpst_Program_DVD_MC;
      Hap_Sys_StreamType_Program_SVCD   : Result := mpst_Program_SVCD;
      Hap_Sys_StreamType_MPEG1          : Result := mpst_MPEG1;
      Hap_Sys_StreamType_MPEG1_VCD      : Result := mpst_MPEG1_VCD;
   else
      Result := mpst_Default;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function FindPinByName (Filter: IBaseFilter; PinDirection: TPin_Direction; LabelSearched: String; IsSubString: Boolean; Unconnected: Boolean; out PinFound: IPin): HRESULT;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ Closes the stream in the downstream direction starting from Filter
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FilterPin: IPin;
   Pins: IEnumPins;
   hr: HRESULT;
   cFetched: ULONG;
   Direction: TPin_Direction;
   Done: Boolean;
   CxPin: IPin;
   Continue: Boolean;
   PinInfo: TPin_Info;
   UpPinName: String;
   UpSearched: String;
   Found: Boolean;
begin
   Result := E_FAIL;
   if not assigned (Filter) then Exit;
   Hr := Filter.EnumPins(Pins);
   if Hr <> S_OK then Exit;
   if Pins = nil then Exit;
   UpSearched := uppercase (LabelSearched);
   Pins.Reset;
   Found := False;
   Done := false;
   while not Done do begin
      if Pins.Next(1, FilterPin, @cFetched) = S_OK then begin
         if assigned (FilterPin) then begin

            Continue := True;

            FilterPin.QueryDirection (Direction);

            if Continue then begin
               Continue := Direction = PinDirection;
            end;
            if Continue and UnConnected then begin
               if FilterPin.ConnectedTo (CxPin) = S_OK then begin
                  CxPin := nil;
                  Continue := False;
               end;
            end;
            if Continue then begin
               if FilterPin.QueryPinInfo (PinInfo) = S_OK then begin
                  PinInfo.pFilter := nil;
                  UpPinName := uppercase (PinInfo.achName);
                  if IsSubString then begin
                     if Pos (UpSearched, UpPinName) > 0 then begin
                        Found := True;
                     end;
                  end
                  else begin
                     if UpSearched = UpPinName then begin
                        Found := True;
                     end;
                  end;
               end;
            end;
            if Found then begin
               Done := True;
               PinFound := FilterPin;
               Result := S_OK;
            end
            else begin
               FilterPin := nil;
            end;
         end;
      end
      else begin
         Done := true;
      end;
   end;
   Pins:= nil;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function EnableDisableMuteInputVolume (IdDevice: Integer; IdInput: Integer; DoSet_else_Get: Boolean; var Mute: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   MxCtrld: TMIXERCONTROLDETAILS;
   MxLCtrls: MIXERLINECONTROLS;
   MxCtrl: MIXERCONTROL;
   MxCtrlDetailsB: MIXERCONTROLDETAILS_Boolean;
   hMix: HMIXER;
begin
   Result := False;

   if mixerOpen(@hMix, IdDevice, 0, 0, 0) <> MMSYSERR_NOERROR then Exit;

   ZeroMemory(@MxLCtrls, SizeOf(MIXERLINECONTROLS));
   with MxLCtrls do begin
      cbStruct := SizeOf(MIXERLINECONTROLS);
      dwLineID := IdInput;
      dwControlType := MIXERCONTROL_CONTROLTYPE_MUTE;
      cControls := 1;
      cbmxctrl := SizeOf(MxCtrl);
      pamxctrl := @MxCtrl;
   end;
   if mixerGetLineControls(hMix, @MxLCtrls, MIXER_GETLINECONTROLSF_ONEBYTYPE) = MMSYSERR_NOERROR then begin
      ZeroMemory(@MxCtrld, SizeOf(MxCtrld));
      with MxCtrld do begin
         cbStruct := SizeOf(TMIXERCONTROLDETAILS);
         dwControlID := MxCtrl.dwControlID;
         cChannels := 1;
         cbDetails := SizeOf(MIXERCONTROLDETAILS_Boolean);
         paDetails := @MxCtrlDetailsB;
      end;
      if DoSet_else_Get then begin
         MxCtrlDetailsB.fValue := Integer (Mute);
         Result := mixerSetControlDetails(hMix, @MxCtrld, MIXER_SETCONTROLDETAILSF_VALUE) = MMSYSERR_NOERROR;
      end
      else begin
         Result := mixerGetControlDetails(hMix, @MxCtrld, MIXER_GETCONTROLDETAILSF_VALUE) = MMSYSERR_NOERROR;
         Mute := Boolean (MxCtrlDetailsB.fValue);
      end;
   end;
   mixerClose(hMix);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
Function MixerVolume( var Volume, Balance: Integer; SetValue: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
type
   T2Unsigned = array [0..1] of TMixerControlDetailsUnsigned;
var
   hMixer: Integer;
   MixerLine: TMixerLine;
   MixerLineControls: TMixerLineControls;
   MixerControl: TMixerControl;
   MixerControlDetails : TMixerControlDetails;
   Data2Unsigned: T2Unsigned;
   Coeff: Double;
   LeftValue, RightValue: LongInt;
begin

   Result := False;

   if mixerOpen( PHMIXER( @hMixer ) ,0,0,0,0) <> MMSYSERR_NOERROR then Exit;

   ZeroMemory (@MixerLine, SizeOf(MixerLine));

   MixerLine.cbStruct := Sizeof(Mixerline);
   MixerLine.dwComponentType := MIXERLINE_COMPONENTTYPE_DST_SPEAKERS;
   if mixerGetLineInfo( hMixer, @MixerLine, MIXER_GETLINEINFOF_COMPONENTTYPE) = MMSYSERR_NOERROR then begin

      ZeroMemory (@MixerLineControls, SizeOf (MixerLineControls));
      ZeroMemory (@MixerControl, SizeOf (MixerControl));
      MixerControl.cbStruct := SizeOf(MixerControl);
      with MixerLineControls do begin
         cbStruct := SizeOf(MixerLineControls);
         dwLineID := MixerLine.dwLineID;
         dwControlType := MIXERCONTROL_CONTROLTYPE_VOLUME;
         cControls := 1;
         cbmxctrl := sizeof(MixerControl);
         pamxctrl := @MixerControl;
      end;
      if MixerGetLineControls(hMixer, @MixerlineControls, MIXER_GETLINECONTROLSF_ONEBYTYPE) = MMSYSERR_NOERROR then begin
         ZeroMemory (@MixerControlDetails, SizeOf (MixerControlDetails));
         ZeroMemory (@Data2UnSigned, SizeOf (T2Unsigned));
         with MixerControlDetails do begin
            cbStruct := SizeOf(MixerControlDetails);
            cbDetails := SizeOf(TMixerControlDetailsUnsigned);
            dwControlID := MixerControl.dwControlID;
            paDetails := @Data2Unsigned;
            cChannels := 2;
         end;

         if not SetValue then begin
           if MixerGetControlDetails(hMixer, @MixerControlDetails, MIXER_GETCONTROLDETAILSF_VALUE) = MMSYSERR_NOERROR then begin
              LeftValue := Data2UnSigned[0].dwValue;
              RightValue := Data2UnSigned[1].dwValue;
              if LeftValue = RightValue then begin
                 Volume := LeftValue;
                 Balance := 0;
              end
              else if LeftValue > RightValue then begin
                 Volume := LeftValue;
                 Coeff := RightValue / Volume;
                 Balance := Round ((Coeff * 32767) - 32768);
              end
              else begin
                 Volume := RightValue;
                 Coeff := LeftValue / Volume;
                 Balance := Round (32767 - (Coeff * 32767));
              end;
              Result := True;
           end
         end
         else begin
            if Balance > 0 then begin
               Coeff := (32767 - Balance) / 32767;
               Data2UnSigned[0].dwValue := Round (Volume * Coeff);
               Data2UnSigned[1].dwValue := Volume;
            end
            else begin
               Coeff := (Balance + 32768) / 32767;
               Data2UnSigned[0].dwValue := Volume;
               Data2UnSigned[1].dwValue := Round (Volume * Coeff);
            end;
            Result := MixerSetControlDetails( hMixer, @MixerControlDetails, MIXER_GETCONTROLDETAILSF_VALUE)  = MMSYSERR_NOERROR;
         end;
      end;
    end;
    MixerClose( hMixer );
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
Function GetMixerVolume(var Volume, Balance: Integer): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := MixerVolume (Volume, Balance, False);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
Function SetMixerVolume(Volume, Balance: Integer): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := MixerVolume (Volume, Balance, True);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function MuteInputVolume (IdDevice: Integer; IdInput: Integer; DoMute: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Mute: Boolean;
begin
   Mute := DoMute;
   Result := EnableDisableMuteInputVolume (IdDevice, IdInput, True, Mute);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetAudioDeviceInputIDs (sIdDevice: String; sIdInput: String; var IdDevice: Integer; var IdInput: Integer): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
   MAXSRC = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 15;
var
   i: Integer;
   hMix: HMIXER;
   MxLine: TMixerLine;
   Done: Boolean;
   MixerCaps: TMixerCaps;
   nDev: Integer;
begin
   Result := False;
   IdDevice := -1;
   IdInput:= -1;
   nDev := mixerGetNumDevs();
   if nDev < 1 then Exit;

   Done := False;
   i := 0;
   while not Done do begin
      if i >= nDev then begin
         Done := True;
      end
      else begin
           if mixerGetDevCaps(i, @MixerCaps, sizeof (TMixerCaps)) = MMSYSERR_NOERROR then begin
              if MixerCaps.cDestinations > 1 then begin { has audio input + output }
                 if pos (MixerCaps.szPname, sIdDevice) > 0 then begin
                    IdDevice := i;
                    Done := True;
                 end;
              end;
           end;
         inc (i);
      end;
   end;

   if IdDevice <> -1 then begin
      if mixerOpen(@hMix, IdDevice, 0, 0, 0) <> MMSYSERR_NOERROR then Exit;
      Done := False;
      i := MIXERLINE_COMPONENTTYPE_SRC_FIRST;
      while not Done do begin
         if i > MAXSRC then begin
            Done := True;
         end
          else begin
            ZeroMemory (@MxLine, sizeof (TMixerLine));
            MxLine.cbStruct := SizeOf(MxLine);
            MxLine.dwComponentType := i;
            if mixerGetLineInfo(hMix, @MxLine, MIXER_GETLINEINFOF_COMPONENTTYPE) = MMSYSERR_NOERROR then begin
               if MxLine.szShortName = sIdInput then begin
                  IdInput := MxLine.dwLineID;
                  Done := True;
                  Result := True;
               end;
            end;
            inc (i);
         end;
      end;
      mixerClose(hMix);
   end;
   if IdInput = -1 then begin { all failed }
      IdDevice := -1;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetListItemNameByIndex (sList: String; Index: Integer): String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TStringList;
begin
   List := TStringList.Create;
   List.Text := sList;
   if Index < List.Count then begin
      Result := List[Index];
   end
   else begin
      Result := '';
   end;
   List.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetPinNames (SearchedDirection: TPin_Direction; Filter: IBaseFilter): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FilterPin: IPin;
   Pins: IEnumPins;
   hr: HRESULT;
   cFetched: ULONG;
   Direction: TPin_Direction;
   Done: Boolean;
   List: TstringList;
   PinInfo: TPin_Info;
begin
   List := TstringList.Create;
   if Filter = nil then Exit;
   Pins:= nil;
   Hr := Filter.EnumPins(Pins);
   if Hr <> S_OK then Exit;
   if Pins = nil then Exit;
   Pins.Reset;
   Done := false;
   while not Done do begin
      if Pins.Next(1, FilterPin, @cFetched) = S_OK then begin
         if assigned (FilterPin) then begin
            FilterPin.QueryDirection (Direction);
            if Direction = SearchedDirection then begin
               if FilterPin.QueryPinInfo (PinInfo) = S_OK then begin
                  List.Add (PinInfo.achName);
                  PinInfo.pFilter := nil;
               end;
            end;
            FilterPin := nil;
         end;
      end
      else begin
         Done := true;
      end;
   end;
   Pins:= nil;
   Result := List.Text;
   List.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function FindPinByTypeAndSubtype (Filter: IBaseFilter; SearchedDirection: TPin_Direction; pMajorType: pGUID; pSubtype: pGUID; var Pin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Pins: IEnumPins;
   hr: HRESULT;
   cFetched: ULONG;
   Direction: TPin_Direction;
   Done: Boolean;
   EnumMedias: IEnumMediaTypes;
   MediasDone: Boolean;
   PinFound: Boolean;
   pmt: PAM_MEDIA_TYPE;
   ulFound: LongInt;
   pininfo: tpin_info;
   Ok: Boolean;
begin
   Result := False;
   if Filter = nil then Exit;
   Hr := Filter.EnumPins(Pins);
   if Hr <> S_OK then Exit;
   if Pins = nil then Exit;
   Pins.Reset;
   PinFound := False;
   Done := false;
   while not Done do begin
      if Pins.Next(1, Pin, @cFetched) = S_OK then begin
         if assigned (Pin) then begin
            Pin.QueryDirection (Direction);
            if Direction = SearchedDirection then begin

               if Pin.EnumMediaTypes (EnumMedias) = S_OK then begin
                  if assigned (EnumMedias) then begin
                     EnumMedias.Reset;
                     MediasDone := false;
                     while not MediasDone do begin
                        if EnumMedias.Next(1, pmt, @ulFound) <> S_OK then begin
                           MediasDone := True;
                        end
                        else begin
                           Ok := IsEqualGUID (pmt^.MajorType, pMajorType^);
                           if Ok then begin
                              if assigned (pSubtype) then begin
                                 Ok := IsEqualGUID (pmt^.SubType, pSubtype^);
                              end;
                           end;
                           if Ok then begin
                              pin.querypininfo (pininfo);
                              MediasDone := True;
                              PinFound := True;
                              Done := True;
                           end;
                           DeleteMediaType (pmt);
                        end;
                     end;
                     EnumMedias := nil;
                  end;
               end;
            end;
            if not PinFound then begin
               Pin := nil;
            end;
         end;
      end
      else begin
         Done := true;
      end;
   end;
   Pins:= nil;
   Result := PinFound;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function FindConnectedPinsTypeAndSubtype (Filter: IBaseFilter; SearchedDirection: TPin_Direction; pMajorType: pGUID; pSubtype: pGUID; var Pin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Pins: IEnumPins;
   hr: HRESULT;
   cFetched: ULONG;
   Direction: TPin_Direction;
   Done: Boolean;
   PinFound: Boolean;
   pininfo: tpin_info;
   Ok: Boolean;
   mt: TAM_MEDIA_TYPE;
begin
   Result := False;
   if Filter = nil then Exit;
   Hr := Filter.EnumPins(Pins);
   if Hr <> S_OK then Exit;
   if Pins = nil then Exit;
   Pins.Reset;
   PinFound := False;
   Done := false;
   while not Done do begin
      if Pins.Next(1, Pin, @cFetched) = S_OK then begin
         if assigned (Pin) then begin
            Pin.QueryDirection (Direction);
            if Direction = SearchedDirection then begin
               if Succeeded (Pin.ConnectionMediaType (@mt)) then begin
                  Ok := IsEqualGUID (mt.MajorType, pMajorType^);
                  if Ok then begin
                     if assigned (pSubtype) then begin
                        Ok := IsEqualGUID (mt.SubType, pSubtype^);
                     end;
                  end;
                  if Ok then begin
                     pin.querypininfo (pininfo);
                     PinFound := True;
                     Done := True;
                  end;
                  FreeMediaType (@mt);
               end;
            end;
            if not PinFound then begin
               Pin := nil;
            end;
         end;
      end
      else begin
         Done := true;
      end;
   end;
   Pins:= nil;
   Result := PinFound;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function RetrievePinByName (SearchedDirection: TPin_Direction; Filter: IBaseFilter; PinName: string; IsSubString: Boolean; out Pin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FilterPin: IPin;
   Pins: IEnumPins;
   hr: HRESULT;
   cFetched: ULONG;
   Direction: TPin_Direction;
   Done: Boolean;
   Found: Boolean;
   PinInfo: TPin_Info;
   Match: Boolean;
begin
   Result := False;
   if Filter = nil then Exit;
   Pins:= nil;
   Hr := Filter.EnumPins(Pins);
   if Hr <> S_OK then Exit;
   if Pins = nil then Exit;
   Pins.Reset;
   Found := False;
   Done := false;
   while not Done do begin
      if Pins.Next(1, FilterPin, @cFetched) = S_OK then begin
         if assigned (FilterPin) then begin
            FilterPin.QueryDirection (Direction);
            if Direction = SearchedDirection then begin
               if FilterPin.QueryPinInfo (PinInfo) = S_OK then begin
                  if IsSubString then begin
                     Match := Pos (PinName, PinInfo.achName) > 0;
                  end
                  else begin
                     Match := PinInfo.achName = PinName;
                  end;
                  if Match then begin
                     Done := True;
                     Found := True;
                     Pin := FilterPin;
                  end;
                  PinInfo.pFilter := nil;
               end;
            end;
            if not Found then begin
               FilterPin := nil;
            end;
         end;
      end
      else begin
         Done := true;
      end;
   end;
   Pins:= nil;
   Result := Found;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure SetRectEmpty(Rect: pRect);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with Rect^ do begin
      Left := 0;
      Top := 0;
      Right := 0;
      Bottom := 0;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{                               CROSSBAR class
{ manages the input and output list of pins
{………………………………………………………………………………………………………………………………………………………………………………………………………………}

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TCrossbar.Create;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FInBound:= 0;
   FOutBound:= 0;
   InputList := TstringList.Create;
   OutputList := TstringList.Create;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
destructor TCrossbar.Destroy;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   InputList.Free;
   OutputList.Free;
   inherited Destroy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TCrossbar.Clear;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if assigned (F_Crossbar) then F_Crossbar := nil;
   FInBound:= 0;
   FOutBound:= 0;
   InputList.Clear;
   OutputList.Clear;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TCrossbar.ReadCrossbar (var pCrossbar: IAMCrossbar);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
   procedure BuildList (List: TstringList; Count: LongInt; IsInput: Boolean);
   var
      j: LongInt;
      iList: LongInt;
      iRelated: LongInt;
      CrossbarPinInfo: TCrossbarPinInfo;
      PhysicalType: LongInt;
   begin
      List.Clear;
      for j := 0 to Count - 1 do begin
         if F_Crossbar.Get_CrossbarPinInfo (IsInput, j, iRelated, PhysicalType) = S_OK then begin
            iList := List.Add (GetCrossbarstring (PhysicalType));
            CrossbarPinInfo.Related := iRelated;
            List.Objects[iList] := Pointer (CrossbarPinInfo);
         end;
      end;
   end;
var
   i: LongInt;
   InputPinIndex: LongInt;
   CrossbarPinInfo: TCrossbarPinInfo;
begin
exit;
   FInBound := 0;
   FOutBound := 0;
   if not assigned (pCrossbar) then Exit;
   F_Crossbar := pCrossbar;

   if F_Crossbar.Get_PinCounts (FOutBound, FInBound) = S_OK then begin

      BuildList (InputList, FInBound, true);

      BuildList (OutputList, FOutBound, false);

      for i := 0 to FOutBound - 1 do begin
         InputPinIndex := -1;
         if F_Crossbar.Get_IsRoutedTo (i, InputPinIndex) <> S_OK then begin
            InputPinIndex := -1;
         end;
         CrossbarPinInfo.Routed := InputPinIndex;
         OutputList.Objects[i] := Pointer (CrossbarPinInfo);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TMonitorInfo.Create (Index: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   inherited Create;
   FAvailable:= False;
   FIndex := Index;
   ZeroMemory (@FBounds, sizeof (TRect));
   FHandle:= 0;
   FDc:= 0;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TVideoWindow.Create (Id: LongInt; IsActive: Boolean; IsExternal: Boolean; VideoWidth, VideoHeight, WindowLeft, WindowTop, WindowWidth, WindowHeight: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   inherited Create;
   FId := Id;
   FAssociatedRenderer := nil;

   FBool[vwActive] := IsActive;
   FBool[vwStayOnTop] := False;
   FBool[vwMouseMovesWindow] := True;
   FBool[vwFullScreen] := False;
   FBool[vwVideoPortEnabled] := True;
   FBool[vwKeepAspectRatio] := True;
   FBool[vwAutoSize] := True;
   FBool[vwEmbedded] := IsExternal;

   FLongInt[vwMonitor] := 0;

   FLongInt[vwVideoWidth] := VideoWidth;
   FLongInt[vwVideoHeight] := VideoHeight;

   FLongInt[vwLeft] := WindowLeft;
   FLongInt[vwTop] := WindowTop;
   FLongInt[vwWidth] := WindowWidth;
   FLongInt[vwHeight] := WindowHeight;

   FActivated := False;

   FPrevMousePoint.x := -1;
   FKeyPressed := ' ';

   FHandleForIVideoWindow := AllocateHwnd (HandleWndMethod);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVideoWindow.HandleWndMethod (var Msg: TMessage);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Msg.Result := DefWindowProc(FHandleForIVideoWindow, Msg.Msg, Msg.WParam, Msg.LParam);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVideoWindow.SetLocation (WindowLeft, WindowTop, WindowWidth, WindowHeight: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FLongInt[vwLeft] := WindowLeft;
   FLongInt[vwTop] := WindowTop;
   FLongInt[vwWidth] := WindowWidth;
   FLongInt[vwHeight] := WindowHeight;
   if assigned (FOnVideoWindowNotify) then FOnVideoWindowNotify (Self, vwLocation, LongInt(True));
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
destructor TVideoWindow.Destroy;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   DeAllocateHwnd (FHandleForIVideoWindow);
   inherited Destroy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVideoWindow.GetLongIntProperties (Index: LongInt): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := FLongInt[TVideoWindowNotify(Index)];
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVideoWindow.SetLongIntProperties (Index: LongInt; Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FLongInt[TVideoWindowNotify(Index)] = Value then Exit;
   FLongInt[TVideoWindowNotify(Index)] := Value;
   if assigned (FOnVideoWindowNotify) then FOnVideoWindowNotify (Self, TVideoWindowNotify(Index), Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVideoWindow.GetBoolProperties (Index: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := FBool[TVideoWindowNotify(Index)];
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVideoWindow.SetBoolProperties (Index: LongInt; Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FBool[TVideoWindowNotify(Index)] = Value then Exit;
   FBool[TVideoWindowNotify(Index)] := Value;

   if TVideoWindowNotify(Index) in [vwFullScreen, vwVideoPortEnabled, vwEmbedded] then begin
      if Value then begin
         if assigned (FAlternateVideoWindow) then begin
            if FAlternateVideoWindow.FBool[TVideoWindowNotify(Index)] then begin
               FAlternateVideoWindow.FBool[TVideoWindowNotify(Index)] := False; { these options cannot be active on both windows }
            end;
         end;
      end;
   end;

   if TVideoWindowNotify(Index) in [vwFullScreen, vwEmbedded] then begin
      FPrevMousePoint.x := -1; { reset mouse motion when changing embedding or fullscreen }
   end;

   if assigned (FOnVideoWindowNotify) then FOnVideoWindowNotify (Self, TVideoWindowNotify(Index), LongWord (Value));
end;

function GetArrayValue (var s: string): LongInt;
var
   p: LongInt;
begin
   Result := MAXINT;
   if length(s) = 0 then Exit;
   p := pos ('!', s);
   if p > 1 then begin
      Result := StrToIntDef (copy (s, 1, p - 1), MAXINT);
      s := copy (s, p + 1, MAXINT);
   end;
end;

function GetIntArrayFromstring (Arry: pLongInt; ArrySize: LongInt; s: string): Boolean;
var
   nbItems: LongInt;
   Tempstring: string;
   i: LongInt;
begin
   Result := false;
   Tempstring := s;
   nbItems := GetArrayValue (Tempstring);
   if nbItems = MAXINT then Exit;
   if nbItems <> ArrySize then Exit;
   Result := true;
   for i := 0 to ArrySize - 1 do begin
      Arry^ := GetArrayValue (Tempstring);
      if Arry^ = MAXINT then begin
         Result := false;
      end;
      inc (Arry);
   end;
end;

function SaveIntArrayTostring (Arry: pLongInt; ArrySize: LongInt): string;
var
   i: LongInt;
begin
   Result := IntToStr (ArrySize) + '!';
   for i := 0 to ArrySize - 1 do begin
      Result := Result + IntToStr (Arry^) + '!';
      inc (Arry^);
   end;
end;

function SaveCrossbarState (Crossbar: IAMCrossbar): string;
var
   i: LongInt;
   InBound, OutBound: LongInt;
   InPinIndex: LongInt;
   BaseArry, Arry: pLongInt;
begin
   Result := '';
   try
      if not assigned (Crossbar) then Exit;
      Crossbar.Get_PinCounts (OutBound, InBound);
      GetMem (BaseArry, sizeof (LongInt) * OutBound);
      Arry := BaseArry;
      for i := 0 to OutBound - 1 do begin
         Crossbar.get_IsRoutedTo (i, InPinIndex);
         Arry^ := InPinIndex;
         inc (Arry);
      end;
      Result := SaveIntArrayTostring (BaseArry, OutBound);
      FreeMem (BaseArry);
   finally
      Crossbar := nil;
   end;
end;

procedure RestoreCrossbarState (Crossbar: IAMCrossbar; s: string);
var
   i: LongInt;
   InBound, OutBound: LongInt;
   InPinIndex: LongInt;
   BaseArry, Arry: pLongInt;
begin
   try
      if not assigned (Crossbar) then Exit;
      Crossbar.Get_PinCounts (OutBound, InBound);
      GetMem (BaseArry, sizeof (LongInt) * OutBound);
      Arry := BaseArry;
      if GetIntArrayFromstring (BaseArry, OutBound, s) then begin
         for i := 0 to OutBound - 1 do begin
             InPinIndex := Arry^;
             inc (Arry);
             Crossbar.Route (i, InPinIndex);
         end;
      end;
      FreeMem (BaseArry);
   finally
      Crossbar := nil;
   end;
end;

var
   AMComponent              : string = 'TVGComp';
   BusyCursorCount          : LongInt = 0;

   _AudioFormats            : string = '';
   _AudioCompressors        : TDevices = nil;
   _AudioDevices            : TDevices = nil;
   _VideoDevices            : TDevices = nil;
   _VideoCompressors        : TDevices = nil;
   _SyncManager             : TSyncManager = nil;
   _Monitors                : array[0..MAXMONITORS - 1] of TMonitorInfo;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function MonitorsCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
   Count: LongInt;
begin
   Count := 0;
   if assigned (_Monitors[MAXMONITORS - 1]) then begin
      for i := 0 to MAXMONITORS - 1 do begin
         if _Monitors[i].FAvailable then begin
            inc (Count);
         end;
      end;
   end;
   Result := Count;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function MonitorBounds (MonitorNumber: LongInt; var Bounds: TRect): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   if MonitorNumber >= MAXMONITORS then Exit;
   if not assigned (_Monitors[MAXMONITORS - 1]) then Exit;
   with _Monitors[MonitorNumber] do begin
      if FAvailable then begin
         CopyRect (Bounds, FBounds);
      end;
      Result := FAvailable;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function MonitorEnumProc (HandleMon: HMONITOR; HdcMon: HDC; RectMon: PRect; dwData: LPARAM): Boolean; stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with _Monitors[iEnumMonitors] do begin
      if FIndex = iEnumMonitors then begin
         FAvailable := True;
         FHandle := HandleMon;
         CopyRect (FBounds, RectMon^);
      end;
      Result := True;
   end;
   inc (iEnumMonitors);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetWindowsPaths (var ProgramFilesPath: String; var CommonFilesPath: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Registry: TRegistry;
begin
   ProgramFilesPath := '';
   CommonFilesPath := '';
   Registry := nil;
   try
      Result := False;
      Registry := TRegistry.Create;
      Registry.RootKey := HKEY_LOCAL_MACHINE;
      if Registry.OpenKeyReadOnly ('\Software\Microsoft\Windows\CurrentVersion') then begin
         ProgramFilesPath := Registry.ReadString ('ProgramFilesDir');
         CommonFilesPath := Registry.ReadString ('CommonFilesDir');
      end;
      Result := True;
   finally
      if assigned (Registry) then Registry.Free;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure DisablePBCodecs;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   szstring: PChar;
   Path: string;
   ProgramFilesPath: String;
   CommonFilesPath: String;
begin
   GetMem (szstring, 301);
   if GetSystemDirectory (szstring, 300) <> 0 then begin
      Path := szString;
      if Length(Path) > 1 then begin
         if Path[length(Path)] <> '\' then begin
            Path := Path + '\';
         end;
      end;
      RenameFile (Path + 'vct3216.acm', Path + 'vct3216_bak.acm');
      RenameFile (Path + 'vct3216.dll', Path + 'vct3216_bak.dll');
      RenameFile (Path + 'msms001.vwp', Path + 'msms001_bak.vwp');

      if GetWindowsPaths (ProgramFilesPath, CommonFilesPath) then begin
         RenameFile (CommonFilesPath + '\Ahead\DSFilter\NeVideo.ax', CommonFilesPath + '\Ahead\DSFilter\NeVideo_bak.ax');
      end;
   end;
   FreeMem (szstring);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure RestorePBCodecs;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   szstring: PChar;
   Path: string;
   ProgramFilesPath: String;
   CommonFilesPath: String;
begin
   GetMem (szstring, 301);
   if GetSystemDirectory (szstring, 300) <> 0 then begin
      Path := szString;
      if Length(Path) > 1 then begin
         if Path[length(Path)] <> '\' then begin
            Path := Path + '\';
         end;
      end;
      RenameFile (Path + 'vct3216_bak.acm', Path + 'vct3216.acm');
      RenameFile (Path + 'vct3216_bak.dll', Path + 'vct3216.dll');
      RenameFile (Path + 'msms001_bak.vwp', Path + 'msms001.vwp');

      if GetWindowsPaths (ProgramFilesPath, CommonFilesPath) then begin
         RenameFile (CommonFilesPath + '\Ahead\DSFilter\NeVideo_bak.ax', CommonFilesPath + '\Ahead\DSFilter\NeVideo.ax');
      end;
   end;
   FreeMem (szstring);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{                                    VFW
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
  AVICAPDLL      = 'AVICAP32.dll';

  function capCreateCaptureWindow (
	  	      lpszWindowName  : PChar;
                      dwStyle         : DWord;
     	  	      x, y            : LongInt;
		      nWidth, nHeight : LongInt;
    		      hwndParent      : THandle;
        	      nID             : LongInt ) : THandle; stdcall; external AVICAPDLL name 'capCreateCaptureWindowA';

 function capGetDriverDescription (
  		    	wDriverIndex : DWord;
		        lpszName     : PChar;
		        cbName       : LongInt;
		        lpszVer      : PChar;
		        cbVer        : LongInt ) : Boolean; stdcall; external AVICAPDLL name 'capGetDriverDescriptionA';


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function VFW_BuildDriverList: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
  DeviceName: array [0..100] of Char;
  DeviceVer: array [0..100] of Char;
  List: TStringList;
  i: LongInt;
begin
   List := TStringList.Create;
   for i := 0 to 9 do begin
       if CapGetDriverDescription (i, DeviceName, sizeof(DeviceName), DeviceVer, sizeof(DeviceVer)) then begin
          List.Add (DeviceName);
       end
       else begin
          List.Add ('.');
       end;
   end;
   Result := List.Text;
   List.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure GetWaveFormatFromIndex(nIndex: LongInt; pwfx: pWaveFormatEx);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ generates the TWaveFormatEx values for the selected audio format
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with pwfx^ do begin
      case nIndex of
          0: begin nSamplesPerSec :=  22050; wBitsPerSample := 16;  nChannels := 2; end;
          1: begin nSamplesPerSec :=  8000; wBitsPerSample :=  8;  nChannels := 1; end;
          2: begin nSamplesPerSec :=  8000; wBitsPerSample :=  8;  nChannels := 2; end;
          3: begin nSamplesPerSec :=  8000; wBitsPerSample := 16;  nChannels := 1; end;
          4: begin nSamplesPerSec :=  8000; wBitsPerSample := 16;  nChannels := 2; end;
          5: begin nSamplesPerSec :=  11025; wBitsPerSample :=  8;  nChannels := 1; end;
          6: begin nSamplesPerSec :=  11025; wBitsPerSample :=  8;  nChannels := 2; end;
          7: begin nSamplesPerSec :=  11025; wBitsPerSample := 16;  nChannels := 1; end;
          8: begin nSamplesPerSec :=  11025; wBitsPerSample := 16;  nChannels := 2; end;
          9: begin nSamplesPerSec :=  16000; wBitsPerSample :=  8;  nChannels := 1; end;
         10: begin nSamplesPerSec :=  16000; wBitsPerSample :=  8;  nChannels := 2; end;
         11: begin nSamplesPerSec :=  16000; wBitsPerSample := 16;  nChannels := 1; end;
         12: begin nSamplesPerSec :=  16000; wBitsPerSample := 16;  nChannels := 2; end;
         13: begin nSamplesPerSec :=  22050; wBitsPerSample :=  8;  nChannels := 1; end;
         14: begin nSamplesPerSec :=  22050; wBitsPerSample :=  8;  nChannels := 2; end;
         15: begin nSamplesPerSec :=  22050; wBitsPerSample := 16;  nChannels := 1; end;
         16: begin nSamplesPerSec :=  22050; wBitsPerSample := 16;  nChannels := 2; end;
         17: begin nSamplesPerSec :=  32000; wBitsPerSample :=  8;  nChannels := 1; end;
         18: begin nSamplesPerSec :=  32000; wBitsPerSample :=  8;  nChannels := 2; end;
         19: begin nSamplesPerSec :=  32000; wBitsPerSample := 16;  nChannels := 1; end;
         20: begin nSamplesPerSec :=  32000; wBitsPerSample := 16;  nChannels := 2; end;
         21: begin nSamplesPerSec :=  44100; wBitsPerSample :=  8;  nChannels := 1; end;
         22: begin nSamplesPerSec :=  44100; wBitsPerSample :=  8;  nChannels := 2; end;
         23: begin nSamplesPerSec :=  44100; wBitsPerSample := 16;  nChannels := 1; end;
         24: begin nSamplesPerSec :=  44100; wBitsPerSample := 16;  nChannels := 2; end;
         25: begin nSamplesPerSec :=  48000; wBitsPerSample :=  8;  nChannels := 1; end;
         26: begin nSamplesPerSec :=  48000; wBitsPerSample :=  8;  nChannels := 2; end;
         27: begin nSamplesPerSec :=  48000; wBitsPerSample := 16;  nChannels := 1; end;
         28: begin nSamplesPerSec :=  48000; wBitsPerSample := 16;  nChannels := 2; end;
      end;
      nBlockAlign := (nChannels * wBitsPerSample) div 8;
      nAvgBytesPerSec := nBlockAlign * nSamplesPerSec;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure CleanTempFiles;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TempPath: PChar;
   Search: TSearchRec;
   More: LongInt;
   Year, Month, Day: Word;
   NowYear, NowMonth, NowDay: Word;
begin
   DecodeDate (Now, NowYear, NowMonth, NowDay);
   GetMem (TempPath, MAX_PATH);
   if GetTempPath (MAX_PATH, TempPath) <> 0 then begin
      More := FindFirst (TempPath + 'v~*', faAnyFile, Search);
      if More = 0 then begin
         while More = 0 do begin
            DecodeDate (FileDateToDateTime(Search.Time), Year, Month, Day);
            if (Day <> NowDay) or ((Day = NowDay) and (Month <> NowMonth)) then begin
               DeleteFile (TempPath + Search.Name);
            end;
            More := FindNext (Search);
         end;
         FindClose (Search);
      end;
      More := FindFirst (TempPath + 'tv*', faAnyFile, Search);
      if More = 0 then begin
         while More = 0 do begin
            DecodeDate (FileDateToDateTime(Search.Time), Year, Month, Day);
            if (Day <> NowDay) or ((Day = NowDay) and (Month <> NowMonth)) then begin
               DeleteFile (TempPath + Search.Name);
            end;
            More := FindNext (Search);
         end;
         FindClose (Search);
      end;
      FreeMem (TempPath);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GenerateAudioFormats: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ generates the list of the authorized audio formats
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TstringList;
   Line: string;
   wfx: TWAVEFORMATEX;
   iIndex: LongInt;
begin
   List := TstringList.Create;
   List.Add ('default');
   for iIndex := 1 to MAXAUDIORATEGROUPS do begin
      GetWaveFormatFromIndex(iIndex, @wfx);
      if wfx.nChannels = 1 then begin
         Line := Format ('%u Hz, %u-bit Mono', [wfx.nSamplesPerSec, wfx.wBitsPerSample]);
      end
      else begin
         Line := Format ('%u Hz, %u-bit Stereo', [wfx.nSamplesPerSec, wfx.wBitsPerSample]);
      end;
      List.Add (Line);
   end;
   Result := List.Text;
   List.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function IsDebuggerPresent: BOOL; external kernel32 name 'IsDebuggerPresent';

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function SingleText (Id: string): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := id + IntToStr (Random (MAXINT));
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure CheckDevInit;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TempAudioDevices: TDevices;
   TempVideoDevices: TDevices;
   TempVideoCompressors: TDevices;
   TempAudioCompressors: TDevices;
   i: LongInt;
   RegisterWindowMsg: array[0..50] of Char;
   sTickCount: String;
begin
      if IsInDesignMode then Exit;
      if InitializationStatus <> ipNotInitialized then Exit;
      InitializationStatus := ipInitializing;

      CleanTempFiles;

      Randomize;

      if IsLibrary then begin
         CoInitialize (nil);
         CoInitializedDone := True;
      end;

      sTickCount := IntToStr (GetTickCount);
      if WM_NOTIFYWINDOW = 0 then begin
         StrPCopy (RegisterWindowMsg, 'WMNW' + sTickCount);
         WM_NOTIFYWINDOW := RegisterWindowMessage (RegisterWindowMsg);
      end;

      (*if WM_NOTIFYEVENT = 0 then begin
         StrPCopy (RegisterWindowMsg, 'WMNE' + sTickCount);
         WM_NOTIFYEVENT := RegisterWindowMessage (RegisterWindowMsg);
      end;*)

      (*if WM_NOTIFYFRAME = 0 then begin
         StrPCopy (RegisterWindowMsg, 'WMNF' + sTickCount);
         WM_NOTIFYFRAME := RegisterWindowMessage (RegisterWindowMsg);
      end;*)

      WriteLog (nil, sBlue, 'creating devs');

      if IsDebuggerPresent then begin
         DisablePBCodecs;
      end;

      for i := 0 to MAXMONITORS - 1 do begin
         _Monitors[i] := TMonitorInfo.Create (i);
      end;

      EnumDisplayMonitors (0, nil, Pointer(@MonitorEnumProc), 0);

      TempAudioDevices:= TDevices.Create(dc_AudioDevices, 'audio device', CLSID_AudioInputDeviceCategory, 0, '', false, '', true, nil);
      TempVideoDevices:= TDevices.Create(dc_VideoDevices, 'video device', CLSID_VideoInputDeviceCategory, 0, '', false, VFW_BuildDriverList, true, TempAudioDevices);
      TempVideoCompressors:= TDevices.Create(dc_VideoCompressors, 'video compressor', CLSID_VideoCompressorCategory, 0, ExcludeVideoCompressorList, true, '', false, nil);
      TempAudioCompressors:= TDevices.Create(dc_AudioCompressors, 'audio compressor', CLSID_AudioCompressorCategory, 0, ExcludeAudioCompressorList, true, '', false, nil);

      _AudioFormats := GenerateAudioFormats;

      _AudioDevices := TempAudioDevices;
      _VideoDevices := TempVideoDevices;
      _VideoCompressors := TempVideoCompressors;
      _AudioCompressors := TempAudioCompressors;

      InitializationStatus := ipInitialized;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function AudioDevices: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   CheckDevInit;
   Result := _AudioDevices.List;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function AudioDevicesCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   CheckDevInit;
   Result := _AudioDevices.Count;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function VideoDevices: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   CheckDevInit;
   Result := _VideoDevices.List;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function VideoDevicesCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   CheckDevInit;
   Result := _VideoDevices.Count;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function IsDVDevice (Index: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   CheckDevInit;
   if Index < 0 then Exit;
   if Index >= _VideoDevices.Count then Exit;
   Result := TCapDeviceInfo(_VideoDevices.FDevices.Objects[Index]).IsDVDevice;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function IsDirectX8OrHigherInstalled: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   CaptureGraphBuilder2: ICaptureGraphBuilder2;
begin
   Result := False;
   if DirectX8OrHigher = dx_NotTested then begin
      if CreateInstance (@CLSID_CaptureGraphBuilder2, ICaptureGraphBuilder2, CaptureGraphBuilder2, 'Graph Builder') then begin
         CaptureGraphBuilder2 := nil;
         DirectX8OrHigher := dx_8orHigher;
         Result := True;
      end
      else begin
         DirectX8OrHigher := dx_7orLess;
      end;
   end
   else begin
      Result := DirectX8OrHigher = dx_8orHigher;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function IsVideoDeviceConnected (DeviceIndex: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   CheckDevInit;
   if DeviceIndex < 0 then Exit;
   if DeviceIndex >= _VideoDevices.FDevices.Count then Exit;
   Result := TCapDeviceInfo(_VideoDevices.FDevices.Objects[DeviceIndex]).Connected;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function IsAudioDeviceConnected (DeviceIndex: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   CheckDevInit;
   if DeviceIndex < 0 then Exit;
   if DeviceIndex >= _AudioDevices.FDevices.Count then Exit;
   Result := TCapDeviceInfo(_VideoDevices.FDevices.Objects[DeviceIndex]).Connected;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function AudioCompressors: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   CheckDevInit;
   Result := _AudioCompressors.List;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function AudioCompressorsCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   CheckDevInit;
   Result := _AudioCompressors.Count;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function VideoCompressors: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   CheckDevInit;
   Result := _VideoCompressors.List;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function VideoCompressorsCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   CheckDevInit;
   Result := _VideoCompressors.Count;
end;

{$IFNDEF DELPHI_OR_BCB_6_AND_GREATER}
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function StrToFloatDef(const S: string; const Default_: Extended): Extended;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ converts a string to a float without error
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
  if not TextToFloat(PChar(S), Result, fvExtended) then
    Result := Default_;
end;
{$ENDIF DELPHI_OR_BCB_6_AND_GREATER}

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetDrv (Path: string; Drv: pChar): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ gets the drive from the path
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   CurrDir: string;
   Ok: Boolean;
begin
   Ok := false;
   if Length(Path) > 1 then begin
      if Path[2] = ':' then begin
         Drv[0] := Path[1];
         Drv[1] := ':';
         Drv[2] := char(0);
         Ok := true;
      end;
   end;
   if not Ok then begin
      CurrDir := GetCurrentDir;
      if Length(CurrDir) > 1 then begin
         if CurrDir[2] = ':' then begin
            Drv[0] := CurrDir[1];
            Drv[1] := ':';
            Drv[2] := char(0);
            Ok := true;
         end;
      end;
   end;
   Result := Ok;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function CheckFreeDiskSpace (Path: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ checks for at least 25 Mo free space on the current path
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   dSectorsPerCluster, dBytesPerSector, dFreeClusters, dTotalNumberOfClusters: DWord;
   lFreeSpace: Int64;
   Drv: array[0..3] of Char;
   Ok: Boolean;
begin
   Result := False;
   if Path = '' then Exit;
   Result := True;
   Ok := GetDrv (Path, Drv);
   if Ok then begin
      if GetDiskFreeSpace (Drv, dSectorsPerCluster, dBytesPerSector, dFreeClusters, dTotalNumberOfClusters)  then begin
         lFreeSpace := int64(dSectorsPerCluster) * int64(dBytesPerSector) * int64(dFreeClusters);
         if lFreeSpace < 25000000 then begin
            Result := false;
         end;
      end;
   end;
end;

type

TStorageType = (st_Normal, st_Network, st_ReadOnly);

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetStorageType (StoragePath: string): TStorageType;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ detects if the path used for storage is network drive
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Drivetype: LongInt;
   Drv: array[0..3] of Char;
   Ok: Boolean;
begin
   Result := st_Normal;
   Ok := GetDrv (StoragePath, Drv);
   if Ok then begin
      DriveType := GetDriveType (Drv);
      case DriveType of
         DRIVE_REMOTE: begin
            Result := st_Network;
         end;
         DRIVE_CDROM: begin
            Result := st_ReadOnly;
         end;
      end;
   end;
end;

{$IFDEF DELPHI_OR_BCB_4}
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function IsPathDelimiter(const S: string; Index: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
  Result := (Index > 0) and (Index <= Length(S)) and (S[Index] = '\')
    and (ByteType(S, Index) = mbSingleByte);
end;

function ExcludeTrailingBackslash(const S: string): string;
begin
  Result := S;
  if IsPathDelimiter(Result, Length(Result)) then
    SetLength(Result, Length(Result)-1);
end;
{$ENDIF DELPHI_OR_BCB_4}

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ReturnDVCommand (DVCommand: TDVCommand): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ translate and enumerated DV command in its constant code
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := 0;
   case DVCommand of
      dv_Play: Result := ED__MODE_PLAY;
      dv_Stop: Result := ED__MODE_STOP;
      dv_Freeze: Result := ED__MODE_FREEZE;
      dv_Thaw: Result := ED__MODE_THAW;
      dv_Ff: Result := ED__MODE_FF;
      dv_Rew: Result := ED__MODE_REW;
      dv_Record: Result := ED__MODE_RECORD;
      dv_RecordFreeze: Result := ED__MODE_RECORD_FREEZE;
      dv_RecordStrobe: Result := ED__MODE_RECORD_STROBE;
      dv_StepFwd: Result := ED__MODE_STEP_FWD;
      dv_StepRev: Result := ED__MODE_STEP_REV;
      dv_ModeShuttle: Result := ED__MODE_SHUTTLE;
      dv_PlayFastestFwd: Result := ED__MODE_PLAY_FASTEST_FWD;
      dv_PlaySlowestFwd: Result := ED__MODE_PLAY_SLOWEST_FWD;
      dv_PlayFastestRev: Result := ED__MODE_PLAY_FASTEST_REV;
      dv_PlaySlowestRev: Result := ED__MODE_PLAY_SLOWEST_REV;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetVCRStateText (Value: LongInt): String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   case Value of
      ED__MODE_PLAY : Result := 'play';
      ED__MODE_STOP : Result := 'stop';
      ED__MODE_FREEZE : Result := 'freeze';
      ED__MODE_THAW : Result := 'thaw';
      ED__MODE_FF : Result := 'ff';
      ED__MODE_REW : Result := 'rew';
      ED__MODE_RECORD : Result := 'record';
      ED__MODE_RECORD_FREEZE : Result := 'record freeze';
      ED__MODE_RECORD_STROBE : Result := 'record strobe';
      ED__MODE_STEP_FWD : Result := 'fwd';
      ED__MODE_STEP_REV : Result := 'rev';
      ED__MODE_SHUTTLE : Result := 'shuttle';
      ED__MODE_PLAY_FASTEST_FWD : Result := 'fastest fwd';
      ED__MODE_PLAY_SLOWEST_FWD : Result := 'slowest fwd';
      ED__MODE_PLAY_FASTEST_REV : Result := 'fastest rev';
      ED__MODE_PLAY_SLOWEST_REV : Result := 'slowest rev';
   else
      if Value = 0 then begin
         Result := 'not in VCR mode';
      end
      else begin
         Result := 'not supported';
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function DecodeMasterStream (StreamValue: TMasterStream): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ converts the enumerated master stream value in its DirectX value
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   case StreamValue of
      ms_AudioMaster: Result := 1;
      ms_VideoMaster: Result := 0;
      ms_NoMaster: Result := -1;
   else
      Result := 0;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure RepaintVideo (Renderer: pRenderer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not assigned (Renderer) then Exit;
   if not Renderer^.DisplayInUse then Exit;
   with Renderer^ do begin
      if assigned (VideoWindow) then begin
         PostMessage (RenderHandle, WM_PAINT, 0, 0);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ReturnFormatType (pmt: PAM_MEDIA_TYPE): TFormatType;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := ft_Unknown;

   if _IsEqualGUID(@pmt.Majortype, @MEDIATYPE_Video) then begin
      if _IsEqualGUID (@pmt.FormatType, @Format_VideoInfo) then begin
         Result := ft_VideoInfo;
      end
      else if _IsEqualGUID (@pmt.FormatType, @Format_VideoInfo2) then begin
         Result := ft_VideoInfo2;
      end
      else if _IsEqualGUID (@pmt.FormatType, @Format_Mpeg1Video) then begin
         Result := ft_Mpeg1Video;
      end
      else if _IsEqualGUID (@pmt.FormatType, @Format_MPeg2Video) then begin
         Result := ft_Mpeg2Video;
      end
   end
   else if _IsEqualGUID(@pmt.Majortype, @MEDIATYPE_Interleaved) then begin
      if _IsEqualGUID (@pmt.FormatType, @Format_DvInfo) then begin
         Result := ft_DvInfo;
      end;
   end
   else if _IsEqualGUID(@pmt.Majortype, @MEDIATYPE_Stream) then begin
      if _IsEqualGUID (@pmt.FormatType, @FORMAT_None) then begin
         Result := ft_MpegCustom;
      end
      else if _IsEqualGUID (@pmt.FormatType, @FORMAT_MPEG1Video) then begin
         Result := ft_Mpeg1Video;
      end
      else if _IsEqualGUID (@pmt.FormatType, @FORMAT_MpegStreams) then begin
         Result := ft_MpegStreamType;
      end
      else if _IsEqualGUID (@pmt.FormatType, @FORMAT_MPEG2Video) then begin
         Result := ft_Mpeg2Video;
      end
      else begin
         Result := ft_MpegCustom;
      end;
   end
   else if _IsEqualGUID(@pmt.Majortype, @MEDIATYPE_Audio) then begin
      if _IsEqualGUID (@pmt.FormatType, @FORMAT_WaveFormatEx) then begin
         Result := ft_WaveFormatEx;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure SyncManagerDoAutostartPreview;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not assigned (_SyncManager) then Exit;
   _SyncManager.ProcessAutoStartPreview;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function VFW_CreateWindow (Parent: Hwnd): Hwnd;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Title: array[0..20] of Char;
   Wnd: Hwnd;
begin
      StrPCopy(Title, 'vfwwnd');
      Wnd := capCreateCaptureWindow (Title, WS_CHILD or WS_VISIBLE, 0, 0, 200, 100, Parent, 0);
      if IsWindow(Wnd) then begin
         Result := Wnd;
      end
      else begin
         Result := 0;
      end
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function VFWSubtypeString (var Compression: dword; bitCount: LongInt): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   sComp: string;
begin
   Result := 'RGB24';
   case Compression of
      BI_RGB:       begin
                       case BitCount of
                           4: Result := 'RGB4';
                           8: Result := 'RGB8';
                          16: Result := 'RGB555';
                          24: Result := 'RGB24';
                          32: Result := 'RGB32';
                       end;
                    end;
      BI_RLE4:      Result := 'RLE4';
      BI_RLE8:      Result := 'RLE8';
      BI_BITFIELDS: Result := 'BITF' + inttostr (BitCount);
   else
      SetString(sComp, PChar(@Compression), 4);
      Result := sComp;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure VFWSubtypeValues (Subtype: string; var Compression: LongWord; var BitCount: word);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
  pComp: pLongWord;
  cComp: array[0..10] of char;
begin
   if Subtype = '' then Exit;
   if Copy (Subtype, 1, 3) = 'RGB' then begin
      Compression := BI_RGB;
      BitCount := StrToInt (Copy (Subtype, 4, MAXINT));
   end
   else if Copy (Subtype, 1, 4) = 'BITF' then begin
      Compression := BI_BITFIELDS;
      BitCount := StrToInt (Copy (Subtype, 5, MAXINT));
   end
   else if Subtype = 'RLE8' then begin
      Compression := BI_RLE8;
      BitCount := 8;
   end
   else if Subtype = 'RLE4' then begin
      Compression := BI_RLE4;
      BitCount := 4;
   end
   else if SubType = 'YUY2' then begin
       strpcopy (cComp, 'YUY2');
       pComp := pLongWord (@cComp);
       Compression := pComp^;
       BitCount := 16;
   end
   else if SubType = 'UYVY' then begin
       strpcopy (cComp, 'UYVY');
       pComp := pLongWord (@cComp);
       Compression := pComp^;
       BitCount := 16;
   end
   else if SubType = 'YV12' then begin
       strpcopy (cComp, 'YV12');
       pComp := pLongWord (@cComp);
       Compression := pComp^;
       BitCount := 12;
   end
   else if SubType = 'IYUV' then begin
       strpcopy (cComp, 'IYUV');
       pComp := pLongWord (@cComp);
       Compression := pComp^;
       BitCount := 12;
   end
   else if SubType = 'I420' then begin
       strpcopy (cComp, 'I420');
       pComp := pLongWord (@cComp);
       Compression := pComp^;
       BitCount := 12;
   end
   else if SubType = 'YVU9' then begin
       strpcopy (cComp, 'YUV9');
       pComp := pLongWord (@cComp);
       Compression := pComp^;
       BitCount := 9;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function VFW_TestFormat (Wnd: HWnd; List: TStringList; bih: pBitmapInfo; bihSize: LongInt; Format: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   VFWSubtypeValues (Format, bih^.bmiheader.biCompression, bih^.bmiheader.biBitCount);
   Result := Boolean (SendMessage(Wnd, OLDWM_CAP_SET_VIDEOFORMAT, Wparam(bihSize), LPARAM(bih)));
   if Result then begin
      List.Add (Format);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function BitmapLineWidth (BiWidth: LongInt; biBitCount: LongInt): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := ((((biWidth * biBitCount) + 31) and (not 31)) shr 3);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function BitmapSize (pbmi: pBitmapInfoHeader): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not assigned (pbmi) then begin
      Result := 0;
   end
   else begin
      with pbmi^ do begin
         Result := ((((biWidth * biBitCount) + 31) and (not 31)) shr 3) * abs (biHeight);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function VFW_TestSize (Wnd: HWnd; List: TStringList; bih: pBitmapInfo; BihSize: LongInt; x: LongInt; y: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   s: string;
begin
   bih^.bmiHeader.BiWidth := x;
   bih^.bmiHeader.BiHeight := abs(y);
   bih^.bmiHeader.biSizeImage := BitmapSize (@bih^.bmiHeader);

   Result := Boolean (SendMessage(Wnd, OLDWM_CAP_SET_VIDEOFORMAT, Wparam(bihSize), LPARAM(bih)));
   if Result then begin
      if x > 999 then begin
         s := IntToStr (x) + 'x' + IntToStr (y);
      end
      else if x < 100 then begin
         s := '  ' + IntToStr (x) + 'x' + IntToStr (y);
      end
      else begin
         s := ' ' + IntToStr (x) + 'x' + IntToStr (y);
      end;
      List.Add (s);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function DirectoryExists (const DirName: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
  Code: LongWord;
begin
   Code := GetFileAttributes(PChar(DirName));
   Result := (Code <> LongWord (-1)) and (FILE_ATTRIBUTE_DIRECTORY and Code <> 0);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ForceDirectories2 (Dir: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Lg: LongInt;
begin
  Result := True;
  lg := length(Dir);
  if lg = 0 then Exit;
  if lg > 1 then begin
     if Dir[lg - 1] = ':' then Exit;
  end;
  if Dir[lg] = ':' then Exit;
  if Dir[lg] = '\' then begin
     SetLength(dir, lg - 1);
  end;
  if (Length(Dir) < 3) then Exit;
  if DirectoryExists(Dir) then Exit;
  if ExtractFilePath(Dir) = Dir then Exit; { avoids 'xyz:\' problem. }
  Result := ForceDirectories2 (ExtractFilePath(Dir)) and CreateDir(Dir);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure ForceDirectoriesFromFilePathName (Value: String);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   iSlash: LongInt;
   Path: String;
begin
   iSlash := LastDelimiter ('\', Value);
   if iSlash > 0 then begin
      Path := Copy (Value, 1, iSlash - 1);
      if not DirectoryExists (Path) then begin
         ForceDirectories2 (Path);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure CleanTVideoGrabberRegistry;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey : TRegistry2;
begin
   RegKey := TRegistry2.Create (False);
   RegKey.DeleteKey (CheckRegKeyId);
   RegKey.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure CheckAndCloseRegistryVersion;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey : TRegistry2;
   Ok: Boolean;
begin
   RegKey := TRegistry2.Create (False);
   Ok := RegKey.OpenKey (CheckRegKeyId + TVideoGrabberVersion, False);
   RegKey.Free;
   if not Ok then begin
      CleanTVideoGrabberRegistry;
      RegKey := TRegistry2.Create (False);
      RegKey.CreateKey (CheckRegKeyId + TVideoGrabberVersion);
      RegKey.Free;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TDualThread.DoResume;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FIsStopped := False;
   SetNotificationMethod (FMethod);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TDualThread.DoSuspend;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FIsStopped := True;
   SetNotificationMethod (FMethod);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TDualThread.SetSleepTime (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      if (Value <= 0) then Exit;
      FSleepTime := Value;
      FTimer.Interval := FSleepTime;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TDualThread.SetNotificationMethod (Value: TNotificationMethod);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FMethod := Value;
   case FMethod of
      nm_Timer: begin
         if not Suspended then begin
            Suspend;
         end;
         FTimer.Enabled := not FIsStopped;
      end;
      nm_Thread: begin
         FTimer.Enabled := False;
         if not FIsStopped then begin
            if Suspended then begin
               Resume;
            end;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TDualThread.SuspendOrTerminateIfDestroying (Destroying: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if Destroying then begin
      if Suspended then begin
         Resume;
      end;
      Terminate;
   end
   else begin
      if not Suspended then begin
         Suspend;
      end;
   end;
end;

(*
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TSyncTimer.Create(CreateSuspended: Boolean; NotificationPriority: TThreadPriority; SyncManager: TSyncManager; NotificationMethod: TNotificationMethod; SleepTime: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   inherited Create ('sync', CreateSuspended, NotificationPriority, FMethod, SleepTime);
   FiVidgrabNext := 0;
   FSyncManager := SyncManager;
end;
*)

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TSyncTimer.Create (AOwner: TComponent; SyncManager: TSyncManager);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   inherited Create (AOwner);
   Enabled := False;
   Interval := DEFAULTSYNCSLEEPTIME;
   FInTimer := False;
   FiVidgrabNext := 0;
   FSyncManager := SyncManager;
   OnTimer := OnTimerSync;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TVidGrabThread.Create(Id: String; CreateSuspended: Boolean; Priority: TThreadPriority; NotificationMethod: TNotificationMethod; Intf: TJxdVideoGrabber; SleepTime: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   inherited Create (Id, CreateSuspended, Priority, NotificationMethod, SleepTime);
   FIntf := Intf;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure FreeAndNilDualThread (var DualThread: TDualThread);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if assigned (DualThread) then begin
      DualThread.Free;
      DualThread := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TDualThread.Create(Id: String; CreateSuspended: Boolean; Priority: TThreadPriority; NotificationMethod: TNotificationMethod; SleepTime: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   inherited Create (CreateSuspended);
   FId := Id;
   FIsStopped := True;
   FInTimer := False;
   FTimer := TTimer.Create (nil);
   FTimer.Enabled := False;
   FMustWaitFor := True;
   FTimer.OnTimer := OnTimer;
   SetNotificationMethod (NotificationMethod);
   SetSleepTime (SleepTime);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
destructor TDualThread.Destroy;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   //FlushMessages;
   FTimer.Free;
   if not Terminated then begin
      if Suspended then begin
         Resume;
      end;
      //FlushMessages;
      Terminate;
      if FMustWaitFor then begin
         //FlushMessages;
         WaitFor;
         //FlushMessages;
      end;
   end;
   inherited Destroy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.PostCommand (WMCommand: TWMCommandOrNotification);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TaskData: pTaskData;
begin
   if WMCommand > WMProcessNotifyEvent then begin
      ProcessTaskCommand (WMCommand); // can process immediately
   end
   else begin
      GetMem (TaskData, sizeof (TTaskData));
      TaskData.Task := WMCommand;
      FTaskList.Add (TaskData);
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessReencoding;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   F_MediaSeeking.GetCurrentPosition(FReencodingProgressInfo.Position);
   FReencodingProgressInfo.Percent := Round ((FReencodingProgressInfo.Position / FReencodingProgressEndTime) * 100);
   if FReencodingProgressInfo.Percent > 100 then Exit;
   if FReencodingProgressInfo.Percent <> FCurrentFrameData.ThreadOldReencodingPercent then begin
      FCurrentFrameData.ThreadOldReencodingPercent := FReencodingProgressInfo.Percent;
      if FReencodingCopyingPreallocatedFile then begin
         PostEvent (@Intf.FOnCopyPreallocDataProgress);
      end
      else begin
         PostEvent (@Intf.FOnReencodingProgress);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ClearOldSavedFrame;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if assigned (FFrameInfo_Current.FrameBitmapData.FrameBitmap) then begin
      FFrameInfo_Current.FrameBitmapData.FrameBitmap.Free;
      FFrameInfo_Current.FrameBitmapData.FrameBitmap := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessGraphRunning;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   NewPosition, CurrentPosition: int64;
   NewFrameNumber: LongInt;
   NewDVTimeCode: Boolean;
   PlayerCanNotifyFrame: Boolean;
   FramesDropped: LongInt;
begin
         if FInFrameProgressRunning then Exit;
         FInFrameProgressRunning := True;

         case FGraphType of
            cs_Playback: begin
               if (not FProcessingRGBFrame) and (not FCurrentFrameData.SettingNewPosition) then begin
                  PlayerCanNotifyFrame := True;
                  if (FCurrent.Networkstreaming = ns_Disabled) and (FFilterState = State_Paused) then begin
                     if FPlayerBackwardTimerEnabled then begin
                        inc (FCurrentFrameData.PlayerStepClocki); // creates a clock for changing positions
                        if FCurrentFrameData.PlayerStepClocki >= FCurrentFrameData.PlayerStepClockCount then begin
                           FCurrentFrameData.PlayerStepClocki := 0;
                           PlayerCanNotifyFrame := True;
                           ProcessPlayByStep (False);
                        end;
                     end
                     else if (FCurrent.FrameGrabber <> fg_Disabled) and FPlayerRefreshPausedDisplay and FPlayerCanRefreshPosition then begin
                        inc (FCurrentFrameData.ThreadPausedPlayerRefreshCount);
                        if (FCurrentFrameData.ThreadPausedPlayerRefreshCount >= MAXREFRESHFRAMECOUNT) then begin // about 20 fps
                           FCurrentFrameData.ThreadPausedPlayerRefreshCount := 0;

                           if assigned (F_MediaSeeking) and (FFilterState = State_Paused) then begin
                              F_MediaSeeking.GetCurrentPosition (CurrentPosition);
                           end
                           else begin
                              CurrentPosition := FFrameInfo_Current.CurrentFrameTime;
                           end;

                           ProcessPlayerNewPosition (CurrentPosition);
                           PlayerCanNotifyFrame := True;
                        end;
                     end;
                  end;
                  if PlayerCanNotifyFrame then begin
                     if FCurrent.FrameGrabber <> fg_Disabled then begin
                        if FCurrentFrameData.NewFrameAvailable then begin
                           if FCurrentFrameData.PlayerDoNotNotifyNextFrame then begin
                              FCurrentFrameData.PlayerDoNotNotifyNextFrame := False;
                           end
                           else begin
                              EnterCriticalSection (FTransmitFrameInfoSection);
                              ClearOldSavedFrame;
                              Windows.CopyMemory (@FFrameInfo_Current, @FFrameInfo_Transmit, sizeof (TCurrentFrameInfo));
                              F_MediaSeeking.GetCurrentPosition (CurrentPosition);
                              NewPosition := Round (CurrentPosition / FCurrentFrameData.PlayerFrameInterval) * FCurrentFrameData.PlayerFrameInterval;
                              ProcessFrameTime (@FFrameInfo_Current, NewPosition);
                              FFrameInfo_Transmit.FrameBitmapData.FrameBitmap := nil; // passed, now must not to be freed in FFrameInfo_Transmit
                              LeaveCriticalSection (FTransmitFrameInfoSection);
                              ProcessNotifyFrame;
                           end;
                           FCurrentFrameData.NewFrameAvailable := False;
                        end;
                     end
                     else begin
                        F_MediaSeeking.GetCurrentPosition (CurrentPosition);
                        NewPosition := Round (CurrentPosition / FCurrentFrameData.PlayerFrameInterval) * FCurrentFrameData.PlayerFrameInterval;
                        if NewPosition <> FCurrentFrameData.ThreadOldPosition then begin
                           if FCurrentFrameData.PlayerDoNotNotifyNextFrame then begin
                              FCurrentFrameData.PlayerDoNotNotifyNextFrame := False;
                           end
                           else begin
                              FCurrentFrameData.ThreadOldPosition := NewPosition;
                              FFrameInfo_Current.PlayerNewPosition := NewPosition;
                              ProcessFrameTime (@FFrameInfo_Current, NewPosition);
                              ProcessNotifyFrame;
                           end;
                        end;
                     end;
                     if FCurrentFrameData.PlayerPausedType <> ppt_None then begin
                        if FFilterState = state_Running then begin
                           F_MediaSeeking.GetCurrentPosition (CurrentPosition);
                           if assigned (F_MediaControl) then begin
                              F_MediaControl.Pause;
                           end;
                           FFilterState := state_Paused;
                           FFrameInfo_Current.PlayerNewPosition := Round (CurrentPosition / FCurrentFrameData.PlayerFrameInterval) * FCurrentFrameData.PlayerFrameInterval;
                           ProcessFrameTime (@FFrameInfo_Current, FFrameInfo_Current.PlayerNewPosition);
                        end
                        else begin
                           case FCurrentFrameData.PlayerPausedType of
                              ppt_Begin: begin
                                 NewPosition := 1;
                              end;
                              ppt_Current: begin
                                 NewPosition := FFrameInfo_Current.FrameInfo.FrameNumber;
                              end;
                              ppt_End: begin
                                 NewPosition := FPlayerFrameCount;
                              end;
                           else
                              NewPosition := 0;
                           end;
                           FCurrentFrameData.PlayerPausedType := ppt_None;
                           SetPlayer_FramePosition (NewPosition);
                        end;
                     end;
                  end;
               end;
            end;

            cs_Preview, cs_Recording: begin
               if assigned (F_AMDroppedFrames) then begin
                  F_AMDroppedFrames.GetNumDropped (FramesDropped);
                  F_AMDroppedFrames.GetNumNotDropped (NewFrameNumber);
                  if NewFrameNumber < 10 then begin
                     FCurrentFrameData.InitialDroppedCount := FramesDropped;
                  end;
                  FFrameInfo_Current.FrameInfo.DroppedFrameCount := FramesDropped - FCurrentFrameData.InitialDroppedCount;
               end
               else begin
                  NewFrameNumber:= FCurrentFrameData.ThreadNewFrameNumber;
               end;
               if FCurrentFrameData.NewFrameNotNotifiedByFrameGrabber then begin
                  NewDVTimeCode := ReadTimeCode (@FFrameInfo_Current);
                  if NewDVTimeCode or (NewFrameNumber <> FCurrentFrameData.ThreadOldFrameNumber) then begin
                     FCurrentFrameData.ThreadOldFrameNumber := NewFrameNumber;
                     FFrameInfo_Current.CurrentFrameNumber := NewFrameNumber;
                     ProcessFrameTime (@FFrameInfo_Current, 0);
                     ProcessNotifyFrame;
                  end;
               end
               else begin
                  if ReadTimeCode (@FFrameInfo_Current) or FCurrentFrameData.NewFrameAvailable then begin
                     EnterCriticalSection (FTransmitFrameInfoSection);
                     FFrameInfo_Grabber.FrameInfo.DroppedFrameCount := FFrameInfo_Current.FrameInfo.DroppedFrameCount;
                     Windows.CopyMemory (@FFrameInfo_Grabber.FrameInfo.DVTimeCode, @FFrameInfo_Current.FrameInfo.DVTimeCode, sizeof (TDVTimeCode));
                     Windows.CopyMemory (@FFrameInfo_Transmit.FrameInfo.DVTimeCode, @FFrameInfo_Current.FrameInfo.DVTimeCode, sizeof (TDVTimeCode));
                     ClearOldSavedFrame;
                     Windows.CopyMemory (@FFrameInfo_Current, @FFrameInfo_Transmit, sizeof (TCurrentFrameInfo));
                     FFrameInfo_Transmit.FrameBitmapData.FrameBitmap := nil; // passed, now must not to be freed in FFrameInfo_Transmit
                     LeaveCriticalSection (FTransmitFrameInfoSection);
                     ProcessNotifyFrame;
                     FCurrentFrameData.NewFrameAvailable := False;
                  end;
               end;

            end;
            cs_Reencoding: begin
               inc (FCurrentFrameData.ThreadReencodingRefreshCount);
               if FCurrentFrameData.ThreadReencodingRefreshCount > 10 then begin
                  FCurrentFrameData.ThreadReencodingRefreshCount := 0;
                  ProcessReencoding;
               end;
            end;
         end;
         if FCheckVMR7Location then begin
            RefreshWindowPos (@FVideoRendererW);
            RefreshWindowPos (@FVideoRendererW2);
            RefreshWindowPos (@FOverlayRendererW);
         end;
         FInFrameProgressRunning := False;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ProcessExtTransport: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TransportState: LongInt;
begin
   Result := False;
   inc (FCurrentFrameData.ThreadAMExtTransportRefreshCount);
   if FCurrentFrameData.ThreadAMExtTransportRefreshCount = 10 then begin // about 10 times per second
      FCurrentFrameData.ThreadAMExtTransportRefreshCount := 0;
      if F_AMExtTransport.Get_Mode (TransportState) = S_OK then begin
         if TransportState <> FCurrentFrameData.ThreadTransportOldState then begin
            FCurrentFrameData.ThreadTransportOldState := TransportState;
            FCurrentFrameData.DVCommandState := TransportState;
            ProcessNotifyDVCommandCompleted;
            Result := True;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.IsSynchronized: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := FSynchronized
   and (FMultiplexedRole <> mr_MultiplexedSlave)
   ;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TCSList.Create;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   InitializeCriticalSection (CriticalSection);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
destructor TCSList.Destroy;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   DeleteCriticalSection (CriticalSection);
   inherited Destroy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCsList.First (var iNext: LongInt): Pointer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   EnterCriticalSection (CriticalSection);
   iNext := 0;
   if iNext < Count then begin
      Result := Items[iNext];
      inc (iNext);
   end
   else begin
      Result := nil;
   end;
   LeaveCriticalSection (CriticalSection);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCsList.Next (var iNext: LongInt): Pointer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   EnterCriticalSection (CriticalSection);
   if iNext < Count then begin
      Result := Items[iNext];
      inc (iNext);
   end
   else begin
      Result := nil;
   end;
   LeaveCriticalSection (CriticalSection);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TCSList.Lock;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   EnterCriticalSection (CriticalSection);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TCSList.Unlock;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   LeaveCriticalSection (CriticalSection);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCSList.Add (Item: Pointer): Integer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   EnterCriticalSection (CriticalSection);
   Result := inherited Add (Item);
   LeaveCriticalSection (CriticalSection);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TCSList.Remove (Item: Pointer): Integer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   EnterCriticalSection (CriticalSection);
   Result := inherited Remove (Item);
   LeaveCriticalSection (CriticalSection);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TTaskThread.Execute;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   CoInitialize (nil);
   while not Terminated do begin
      with TVdgr(FIntf._Vdgr) do begin
         if FDestroying then begin
            Terminate;
         end
         else begin
            if FTaskList.Count > 0 then begin
               ProcessCommand;
            end;
            if FEventList.Count > 0 then begin
               ProcessEvent;
            end;
            if FGraphState = gs_CanActivate then begin
               FGraphState := gs_Activating;
               ActivateGraph;
            end;
            if FGraphAccessAllowed then begin
               ProcessGraphRunning;
               if assigned (F_AMExtTransport) then begin
                  ProcessExtTransport;
               end;
            end;
            //FlushMessages;
         end;
      end;
      Sleep (FSleepTime);
   end;
   CoUninitialize;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TTaskThread.OnTimer (Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not FInTimer then begin
      FInTimer := True;
      with TVdgr(FIntf._Vdgr) do begin
         if FDestroying then begin
            TTimer(Sender).Enabled := False;
         end
         else begin
            if FEventList.Count > 0 then begin
               ProcessEvent;
            end;
            if FTaskList.Count > 0 then begin
               ProcessCommand;
            end;
            if FGraphState = gs_CanActivate then begin
               FGraphState := gs_Activating;
               ActivateGraph;
            end;
            if FGraphAccessAllowed then begin
               ProcessGraphRunning;
               if assigned (F_AMExtTransport) then begin
                  ProcessExtTransport;
               end;
            end;
         end;
      end;
      FInTimer := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TSyncManager.Create (NotificationPriority: TThreadPriority);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   CheckAndCloseRegistryVersion;

   Randomize;

   CheckDevInit;


   FActivatingApp := False;
   FVideoGrabberList := TCsList.Create;
   FAutoFileSequentialCount := TStringList.Create;
   FAutoFileSequentialCount.Sorted := True;
   FAutoFileSequentialCount.Duplicates := dupIgnore;

   FTempFiles := TSTringList.Create;

   FSyncGlobalMessages := TSyncGlobalMessages.CreateNew (nil);
   FSyncGlobalMessages.CreateWnd;
   FSyncGlobalMessages.Tag := LongInt (Self);

   FSyncTimer := TSyncTimer.Create (nil, Self);

   FOldOnIdle := Application.OnIdle;
   Application.OnIdle := OnIdle;

   FSyncTimer.Enabled := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
destructor TSyncManager.Destroy;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
begin
   WriteLog (nil, sGrey, 'freeing global resources');

   FSyncTimer.Free;

   FSyncGlobalMessages.Free;

   FVideoGrabberList.Free;
   FAutoFileSequentialCount.Free;

   if CleanTVideoGrabberRegistryOnExit then begin
      CleanTVideoGrabberRegistry;
   end;

   WriteLog ('=', sBlack, 'END TVideoGrabber v' + TVideoGrabberVersion + ' process log');

   if CoInitializedDone then begin
      CoUninitialize;
   end;

   _AudioDevices.Free;
   _VideoDevices.Free;
   _AudioCompressors.Free;
   _VideoCompressors.Free;

   for i := 0 to MAXMONITORS - 1 do begin
       _Monitors[i].Free;
   end;

   if IsDebuggerPresent then begin
      RestorePBCodecs;
   end;

   while FTempFiles.Count > 0 do begin
      DeleteFile (FTempFiles[0]);
      SysFreeString (POleStr (FTemPFiles.Objects[0]));
      FTempFiles.Delete (0);
   end;
   FTempFiles.Free;

   inherited Destroy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TSyncManager.ProcessAutoStartPreview;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   CanStartPreview: Boolean;
   Vdgr: TVdgr;
   iNext: LongInt;
begin
   if FActivatingApp then Exit;
   FActivatingApp := True;
   Vdgr := FVideoGrabberList.First (iNext);
   while assigned (Vdgr) do begin
      with Vdgr do begin
         DynamicallyCreated;
         CanStartPreview := FAutoStartPreview;
         if FVideoSource > vs_VideoCaptureDevice then begin
            CanStartPreview := False;
         end;
         if FMultiplexedRole = mr_MultiplexedSlave then begin
            CanStartPreview := False;
         end;
         if CanStartPreview then begin
            if FGraphType = cs_Down then begin
               Intf.StartPreview;
            end;
         end;
      end;
      Vdgr := FVideoGrabberList.Next (iNext);
   end;
   FActivatingApp := False;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TSyncManager.DeviceNotify;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FDeviceNotifyStep in [dnsWaiting, dnsReceived] then begin
      FNotifyTime := GetTickCount + 2000;
      FDeviceNotifyStep := dnsReceived;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TSyncManager.ProcessDeviceChange;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ these functions are duplicated 4 times to save CPU testing what function must
{ be called, because the timer event occurs every 10 ms
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   j: LongInt;
   Vdgr: TVdgr;
   iNext: LongInt;
begin
   if not assigned (_SyncManager) then Exit;

   with _SyncManager do begin

      if FNotifyTime > GetTickCount then Exit;

      FDeviceNotifyStep := dnsProcessing;

      _VideoDevices.RebuildDeviceList;
      _AudioDevices.RebuildDeviceList;

      for j := 0 to _VideoDevices.FDevices.Count - 1 do begin
         with TCapDeviceInfo(_VideoDevices.FDevices.Objects[j]) do begin
            if (not WasConnected) and (Connected) then begin
               Vdgr := FVideoGrabberList.First (iNext);
               while assigned (Vdgr) do begin
                  if not Vdgr.FDestroying then begin
                     Vdgr.ApplySetVideoDevice;
                     if Vdgr.CanInvokeEvent (TPObj(Vdgr.Intf.FOnDeviceArrivalOrRemoval)) then Vdgr.Intf.FOnDeviceArrivalOrRemoval (Vdgr.Intf, True, True, _VideoDevices.FDevices[j], j);
                  end;
                  Vdgr := FVideoGrabberList.Next (iNext);
               end;
            end
            else if (WasConnected) and (not Connected) then begin
               Vdgr := FVideoGrabberList.First (iNext);
               while assigned (Vdgr) do begin
                  if not Vdgr.FDestroying then begin
                     if Vdgr.CanInvokeEvent (TPObj(Vdgr.Intf.FOnDeviceArrivalOrRemoval)) then Vdgr.Intf.FOnDeviceArrivalOrRemoval (Vdgr.Intf, False, True, _VideoDevices.FDevices[j], j);
                  end;
                  Vdgr := FVideoGrabberList.Next (iNext);
               end;
            end;
         end;
      end;

      for j := 0 to _AudioDevices.FDevices.Count - 1 do begin
         with TCapDeviceInfo(_AudioDevices.FDevices.Objects[j]) do begin
            if (not WasConnected) and (Connected) then begin
               Vdgr := FVideoGrabberList.First (iNext);
               while assigned (Vdgr) do begin
                  if not Vdgr.FDestroying then begin
                     Vdgr.ApplySetAudioDevice;
                     if Vdgr.CanInvokeEvent (TPObj(Vdgr.Intf.FOnDeviceArrivalOrRemoval)) then Vdgr.Intf.FOnDeviceArrivalOrRemoval (Vdgr.Intf, True, True, _AudioDevices.FDevices[j], j);
                  end;
                  Vdgr := FVideoGrabberList.Next (iNext);
               end;
            end
            else if (WasConnected) and (not Connected) then begin
               Vdgr := FVideoGrabberList.First (iNext);
               while assigned (Vdgr) do begin
                  if not Vdgr.FDestroying then begin
                     if Vdgr.CanInvokeEvent (TPObj(Vdgr.Intf.FOnDeviceArrivalOrRemoval)) then Vdgr.Intf.FOnDeviceArrivalOrRemoval (Vdgr.Intf, False, True, _AudioDevices.FDevices[j], j);
                  end;
                  Vdgr := FVideoGrabberList.Next (iNext);
               end;
            end;
         end;
      end;
      FDeviceNotifyStep := dnsWaiting;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TSyncManager.CheckAndActivateSync;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   CanActivate: Boolean;
   Vdgr: TVdgr;
   iNext: LongInt;
begin
   with _SyncManager do begin
      CanActivate := True;
      Vdgr := FVideoGrabberList.First (iNext);
      while assigned (Vdgr) do begin
         with Vdgr do begin
            if IsSynchronized then begin
               if FGraphState <> gs_WaitForSync then begin
                  CanActivate := False;
               end;
            end;
         end;
         Vdgr := FVideoGrabberList.Next (iNext);
      end;
      if CanActivate then begin
         Vdgr := FVideoGrabberList.First (iNext);
         while assigned (Vdgr) do begin
            with Vdgr do begin
               FGraphState := gs_CanActivate;
            end;
            Vdgr := FVideoGrabberList.Next (iNext);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TSyncManager.OnIdle (Sender: TObject; var Done: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Done := True;
   if not OnIdleDone then begin
      OnIdleDone := True;
      SyncManagerDoAutostartPreview;
   end;
   if assigned (FOldOnIdle) then FOldOnIdle (Sender, Done);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TSyncTimer.OnTimerSync (Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Vdgr: TVdgr;
begin
   if not FInTimer then begin
      FInTimer := True;
      with FSyncManager do begin
         Vdgr := FVideoGrabberList.Next (FiVidgrabNext);
         if assigned (Vdgr) then begin
            if Vdgr.FGraphState = gs_WaitForSync then begin
               CheckAndActivateSync;
            end
            else if FDeviceNotifyStep = dnsReceived then begin
               ProcessDeviceChange;
            end;
         end
         else begin
            FiVidgrabNext := 0;
         end;
      end;
      FInTimer := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TSyncManager.GetNextFileSequentialCount (Dir: string; Prefix: string; Ext: string; var AutoFileSequentialCountIndex: LongInt): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Idx: String;
begin
   if length(Dir) > 0 then begin
      if Dir[length(Dir)] = '\' then begin
         Idx := Dir + Prefix + Ext;
      end
      else begin
         Idx := Dir + '\' + Prefix + Ext;
      end;
   end
   else begin
      Idx := Prefix + Ext;
   end;

   AutoFileSequentialCountIndex := FAutoFileSequentialCount.IndexOf (Idx);
   if AutoFileSequentialCountIndex = -1 then begin
      RefreshAutoFileSequentialCount (Dir, Prefix, Ext);
      AutoFileSequentialCountIndex := FAutoFileSequentialCount.IndexOf (Idx);
   end;
   if AutoFileSequentialCountIndex > -1 then begin
      Result := LongInt (FAutoFileSequentialCount.Objects[AutoFileSequentialCountIndex]) + 1;
      FAutoFileSequentialCount.Objects[AutoFileSequentialCountIndex] := Pointer (Result);
   end
   else begin
      WriteLog (nil, sRed, 'ERROR: sequential file count not found: ' + Idx);
      Result := 1;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAutoConnectRelatedPins: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAutoConnectRelatedPins;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAutoFileName: TAutoFileName;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAutoFileName;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAutoFilePrefix: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FAutoFilePrefix;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetAutoRefreshPreview: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAutoRefreshPreview;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetAutoStartPreview: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAutoStartPreview;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAutoConnectRelatedPins (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FAutoConnectRelatedPins := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAutoStartPreview (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FAutoStartPreview := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAutoStartPlayer: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAutoStartPlayer;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAutoStartPlayer (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FAutoStartPlayer := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAutoRefreshPreview (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FAutoRefreshPreview := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAssociateAudioAndVideoDevices: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAssociateAudioAndVideoDevices;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAssociateAudioAndVideoDevices (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FAssociateAudioAndVideoDevices := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TSyncManager.GetAutoFileSequentialCount (AutoFileSequentialCountIndex: LongInt): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := -1;
   if AutoFileSequentialCountIndex = -1 then Exit;
   if AutoFileSequentialCountIndex >= FAutoFileSequentialCount.Count then Exit;
   Result := LongInt (FAutoFileSequentialCount.Objects[AutoFileSequentialCountIndex]);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.PostEvent (Event: Pointer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   EventData: pEventData;
begin
   if not assigned (_SyncManager) then Exit;
   GetMem (EventData, sizeof (TEventData));
   EventData^.Event := Event;
   EventData^.Vdgr := Self;
   if FEventNotificationSynchrone then begin
      DoProcessEvent (EventData);
   end
   else begin
      FEventList.Add (EventData);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessTaskCommand (WMCommand: TWMCommandOrNotification);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
          if WMCommand >= WMStartPreview then begin
             if (not assigned (Intf.Parent)) and (Intf.ParentWindow = 0) then begin
                Intf.SetParent (_SyncManager.FSyncGlobalMessages); // the control must have a parent
             end;
          end;

          case WMCommand of
               WMDeviceLost: begin
                  if FGraphAccessAllowed then begin
                     ProcessStopGraph;
                  end;
                  FLastPreviewFailed := True;
                  PostEvent (@Intf.FOnDeviceLost);
               end;

               WMProcessNotifyEvent: begin
                  ProcessNotifyEvent;
               end;

               WMProcessStartTVAutoScan: begin
                  ProcessTVStartAutoScan;
               end;

               WMProcessContinueTVAutoScan: begin
                  ProcessTVScanning;
               end;

               WMPlayStartByStep: begin
                  ProcessPlayByStep (True);
               end;

               WMStartPreview: begin
                  if RestartGraph (cs_Preview) then begin
                     PostEvent (@Intf.FOnPreviewStarted);
                  end;
               end;

               WMStartRecording: begin
                  RestartGraph (cs_Recording);
               end;

               WMStartReencoding: begin
                  if ReencodeOrRecopyFile (@FReencodingSettings, False, True) then begin
                     PostEvent (@Intf.FOnReencodingStarted);
                  end;
               end;

               WMOpenPlayer: begin
                  if Build_Player_Rendering then begin
                     PostEvent (@Intf.FOnPlayerOpened);
                  end;
               end;

               WMPausePlayer: begin
                  DoPausePlayer (False);
               end;                                                                   

               WMPlayerSetPosition: begin
                  SetPlayer_FramePosition (FCurrentFrameData.PlayerPausedNewPosition);
               end;

               WMPlayerSetTrackBarPosition: begin
                  SetPlayer_FramePosition (FCurrentFrameData.PlayerTrackBarNewPosition);
               end;

               WMStopPlayer: begin
                  DoPausePlayer (True);
               end;

               WMStopGraph: begin
                  if FGraphAccessAllowed then begin
                     ProcessStopGraph;
                  end;
               end;
            end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TSyncGlobalMessages.WMDeviceChangeMsg (var Message: TMessage);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   inherited;
   TSyncManager(Tag).DeviceNotify;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TSyncManager.DecAutoFileSequentialCount (AutoFileSequentialCountIndex: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Value: LongInt;
begin
   if AutoFileSequentialCountIndex = -1 then Exit;
   if AutoFileSequentialCountIndex >= FAutoFileSequentialCount.Count then Exit;
   Value := LongInt (FAutoFileSequentialCount.Objects[AutoFileSequentialCountIndex]);
   if Value > 0 then begin
      FAutoFileSequentialCount.Objects[AutoFileSequentialCountIndex] := Pointer (Value - 1);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TSyncManager.RefreshAutoFileSequentialCount (Dir: string; Prefix: string; Capture_FileExt: String);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Idx: String;
   i: LongInt;
   Sr: TSearchRec;
   Done: LongInt;
   pPoint: LongInt;
   FileNum: LongInt;
   Ext: String;
   SearchString: String;
   RescanRequired: Boolean;
   iSeq: LongInt;

   procedure CheckInserted (Extension: String);
   var
      FullIdxString: String;
   begin
      FullIdxString := Idx + Extension;
      if _SyncManager.FAutoFileSequentialCount.IndexOf (FullIdxString) = -1 then begin
         iSeq := _SyncManager.FAutoFileSequentialCount.Add (FullIdxString);
         FAutoFileSequentialCount.Objects[iSeq] := Pointer (0);
         RescanRequired := True;
      end;
   end;
begin
   if length(Dir) > 0 then begin
      if Dir[length(Dir)] = '\' then begin
         SearchString := Dir + Prefix + '*.*';
         Idx := Dir + Prefix;
      end
      else begin
         SearchString := Dir + '\' + Prefix + '*.*';
         Idx := Dir + '\' + Prefix;
      end;
   end
   else begin
      SearchString := Prefix + '*.*';
      Idx := Prefix;
   end;

   RescanRequired := False;

   CheckInserted ('bmp');
   CheckInserted ('jpg');
   CheckInserted (Capture_FileExt);

   if not RescanRequired then Exit;

   Done := FindFirst (SearchString, 0, Sr);
   if Done = 0 then begin
      while Done = 0 do begin
         pPoint:= pos ('.', Sr.Name);
         if pPoint > 1 then begin
            Ext := Copy (Sr.Name, pPoint + 1, MaxInt);
            i := FAutoFileSequentialCount.IndexOf (Idx + Ext);
            if i <> -1 then begin
               FileNum:= StrToIntDef (copy (Sr.Name, pPoint - 6, 6), -1);
               if FileNum <> -1 then begin
                  if FileNum > LongInt (FAutoFileSequentialCount.Objects[i]) then begin
                     FAutoFileSequentialCount.Objects[i] := Pointer(FileNum);
                  end;
               end;
            end;
         end;
         Done := FindNext (Sr);
      end;
      FindClose (Sr);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure DisconnectPins (var Filter: IBaseFilter);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ disconnects all the filter's pins
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   hr: HResult;
   pPin: IPin;
   pPinConnected: IPin;
   pEnumPins: IEnumPins;
begin
      if not assigned (Filter) then Exit;
      hr:= Filter.EnumPins(pEnumPins);
      if (hr = S_OK) and (pEnumPins <> nil) then begin
         pEnumPins.Reset;
         while pEnumPins.Next(1, pPin, nil) = S_OK do begin
            if pPin <> nil then begin
               if pPin.ConnectedTo (pPinConnected) = S_OK then begin
                   if pPinConnected <> nil then begin
                      pPinConnected.Disconnect;
                      pPinConnected := nil;
                   end;
               end;
               pPin.DisConnect;
               pPin := nil;
            end;
         end;
         pEnumPins := nil;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetScreenFormat: pGUID;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   BitsPerPixel: LongInt;
   DevDC: HDC;
begin
   DevDC := GetDC(0);
   BitsPerPixel  := GetDeviceCaps(DevDC, BITSPIXEL);
   ReleaseDC(0, DevDC);

   case BitsPerPixel of
       4: begin
         Result := @MEDIASubtype_RGB4;
       end;
       8: begin
         Result := @MEDIASubtype_RGB8;
       end;
      15: begin
         Result := @MEDIASubtype_RGB555;
      end;
      16: begin
         Result := @MEDIASubtype_RGB565;
      end;
      24: begin
         Result := @MEDIASubtype_RGB24;
      end;
      32: begin
         Result := @MEDIASubtype_RGB32;
      end;
   else
      Result := @MEDIASubtype_RGB24; { otherwise problems with RGB32, especially on W98 (256 colors) }
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure LogPinsInfo (pFilter: IBaseFilter);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns the number of input and output pins of a filter
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pEnum: IEnumPins;
   ulFound: ULONG;
   pPin: IPin;
   PinInfo: TPin_Info;
   EnumMedias: IEnumMediaTypes;
   MediasDone: Boolean;
   pmt: PAM_MEDIA_TYPE;
   OldMajorType, OldSubtype: TGUID;
begin
 try
   if not assigned (pFilter) then Exit;

   { Get pin enumerator }
   if pFilter.EnumPins(pEnum) <> S_OK then Exit;
   if pEnum = nil then Exit;

   pEnum.Reset;
   WriteLog ('$', sGrey, 'filter pins info begin');

   { Count every pin on the filter }
   while pEnum.Next(1, pPin, @UlFound) = S_OK do begin
      if assigned (pPin) then begin
         if pPin.QueryPinInfo (PinInfo) = S_OK then begin
            if PinInfo.Dir = PINDIR_INPUT then begin
               WriteLog (nil, sGrey, 'Input pin: ' + PinInfo.achName);
            end
            else begin
               WriteLog (nil, sGrey, 'Output pin: ' + PinInfo.achName);
            end;

            if pPin.EnumMediaTypes (EnumMedias) = S_OK then begin
               if assigned (EnumMedias) then begin
                  EnumMedias.Reset;
                  MediasDone := false;
                  zeromemory (@OldMajorType, sizeof (TGUID));
                  zeromemory (@OldSubType, sizeof (TGUID));
                  while not MediasDone do begin
                     if EnumMedias.Next(1, pmt, @ulFound) <> S_OK then begin
                        MediasDone := True;
                     end
                     else begin
                        if IsEqualGUID (pmt^.MajorType, OldMajorType) and IsEqualGUID (pmt^.SubType, OldSubType) then begin
                        end
                        else begin
                           WriteLog (nil, sGrey, 'major  : ' + GuidToString (pmt^.MajorType));
                           WriteLog (nil, sGrey, 'sub    : ' + GuidToString (pmt^.SubType));
                           WriteLog (nil, sGrey, 'format : ' + GuidToString (pmt^.FormatType));
                           CopyGUID (@OldMajorType, @pmt^.MajorType);
                           CopyGUID (@OldSubType, @pmt^.SubType);
                        end;
                        DeleteMediaType (pmt);
                     end;
                  end;
               end;
               EnumMedias := nil;
            end;

         end;
         PinInfo.pFilter := nil;
         pPin := nil;
      end;
    end;
  finally
    pFilter := nil;
    pEnum := nil;
  end;
  WriteLog ('$', sGrey, 'filter pins info end');
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure ClearAudioDeviceRendering (AudioRendering: pAudioRendering);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
  with AudioRendering^ do begin
     if assigned (MediaControl) then MediaControl.Stop;
     if assigned (MediaControl) then MediaControl := nil;
     if assigned (AudioDevice) then AudioDevice := nil;
     if assigned (FilterGraph2) then FilterGraph2 := nil;
     if assigned (GraphBuilder) then GraphBuilder := nil;
     if assigned (CaptureGraphBuilder2) then CaptureGraphBuilder2 := nil;
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function BytesPerScanline(PixelsPerScanline, BitsPerPixel, Alignment: Longint): Longint;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
  Dec(Alignment);
  Result := ((PixelsPerScanline * BitsPerPixel) + Alignment) and not Alignment;
  Result := Result div 8;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ReturnIndexFromTextList (TextList: String; Value: string): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   sl: TStringList;
begin
   sl := TStringList.Create;
   sl.Text := TextList;
   Result := sl.IndexOf (Value);
   sl.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ReturnItemFromTextList (TextList: String; Value: LongInt): String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   sl: TStringList;
begin
   sl := TStringList.Create;
   sl.Text := TextList;
   if (Value >= 0) and (Value < sl.Count) then begin
      Result := sl[Value];
   end
   else begin
      Result := '';
   end;
   sl.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure GoTop (List: TStringList; Item: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
begin
   i := List.IndexOf (Item);
   if i > 0 then begin
      List.Insert (0, Item);
      List.Delete (i + 1);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function CanControlPin (var Pin: Ipin): boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   StreamControl: IAMStreamControl;
begin
   Result := false;
   if not assigned (Pin) then Exit;
   if Succeeded (Pin.QueryInterface (IAMStreamControl, StreamControl)) then begin
      StreamControl := nil;
      Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function SearchMediaType (var pPin: IPin; pMediaType: pGUID; MediaSubtypes: array of pGUID): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns the number of input and output pins of a filter
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   ulFound: ULONG;
   EnumMedias: IEnumMediaTypes;
   MediasDone: Boolean;
   pmt: PAM_MEDIA_TYPE;
   nbSubtypes: LongInt;
   i: LongInt;
begin
   Result := False;
   nbSubtypes := Length(MediaSubtypes);
   if nbSubtypes = 0 then Exit;
   try
      if assigned (pPin) then begin
            if pPin.EnumMediaTypes (EnumMedias) = S_OK then begin
               if assigned (EnumMedias) then begin
                  EnumMedias.Reset;
                  MediasDone := false;
                  while not MediasDone do begin
                     if EnumMedias.Next(1, pmt, @ulFound) <> S_OK then begin
                        MediasDone := True;
                     end
                     else begin
                        if IsEqualGUID (pmt^.MajorType, pMediaType^) then begin
                           for i := 0 to nbSubtypes - 1 do begin
                              if IsEqualGUID (pmt^.SubType, MediaSubtypes[i]^) then begin
                                 MediasDone := True;
                                 Result :=True;
                              end;
                           end;
                        end;
                        DeleteMediaType (pmt);
                     end;
                  end;
               end;
               EnumMedias := nil;
            end;

      end;
   finally
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure LogTree (StartingFilter: IBaseFilter; Level: LongInt; Filters: TStringList);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ removes all the graph's filters
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   hr: HResult;
   pPin: IPin;
   PinInfo: TPin_Info;
   CxPinInfo: TPin_Info;
   pEnumPins: IEnumPins;
   CxPin: IPin;
   FilterInfo: TFilterInfo;
begin
   if not assigned (StartingFilter) then Exit;

   if StartingFilter.QueryFilterInfo (FilterInfo) = S_OK then begin
      FilterInfo.pGraph := nil;
      Filters.Add (FilterInfo.achName);
      WriteLog (nil, sGreen, StringOfChar (' ', Level shl 1) + '.' + FilterInfo.achName);
   end;

   hr:= StartingFilter.EnumPins(pEnumPins);
   if (hr = S_OK) and assigned (pEnumPins) then begin
      pEnumPins.Reset;
      while pEnumPins.Next(1, pPin, nil) = S_OK do begin
         if assigned (pPin) then begin
            if pPin.QueryPinInfo(PinInfo) = S_OK then begin
               if PinInfo.dir = PINDIR_OUTPUT then begin
                  if pPin.ConnectedTo (CxPin) = S_OK then begin
                     if CxPin.QueryPinInfo (CxPinInfo) = S_OK then begin
                        LogTree (CxPinInfo.pFilter, Level + 1, Filters);
                        CxPinInfo.pFilter := nil;
                     end;
                  CxPin := nil;
                  end;
               end;
               PinInfo.pFilter := nil;
            end;
            pPin := nil;
         end;
      end;
      pEnumPins := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function FindFilterByCLSID (var Graph: IGraphBuilder; SearchCLSID: TGUID; var FilterFound: IBaseFilter): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ disconnects all the graph's pins
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pEnumFilters: iEnumFilters;
   cFetched: ULONG;
   hr: HResult;
   Done: Boolean;
   FilterCLSID: TGUID;
begin
   Done := false;
   if assigned (Graph) then begin
      hr := Graph.EnumFilters(pEnumFilters);
      if (hr = S_OK) and assigned (pEnumFilters) then begin
         pEnumFilters.Reset;
         while (pEnumFilters.Next(1, FilterFound, @cFetched) = S_OK) and (not Done) do begin
            FilterFound.GetClassID (FilterCLSID);
            if _IsEqualGUID (@FilterCLSID, @SearchCLSID) then begin
               Done := true;
            end
            else begin
               FilterFound := nil;
            end;
         end;
         pEnumFilters:= nil;
      end;
      Graph := nil;
   end;
   Result := Done;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function FindPinInGraphByType (var Graph: IGraphBuilder; Direction: TPin_Direction; MustBeUnconnected: Boolean; MajorType: pGUID; var Pin: IPin; IgnoreFilterName: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ disconnects all the graph's pins
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pEnumFilters: iEnumFilters;
   Pins: IEnumPins;
   cFetched: ULONG;
   hr: HResult;
   Filter: IBaseFilter;
   FilterPin: IPin;
   FiltersDone: Boolean;
   PinsDone: Boolean;
   PinInfo: TPin_Info;
   PinFound: Boolean;
   ConnectedTo: IPin;
   IsConnected: Boolean;
   EnumMediaTypes: IEnumMediaTypes;
   MediaTypesDone: Boolean;
   pmt: PAM_MEDIA_TYPE;
   FilterInfo: TFilterInfo;
   Continue: Boolean;
begin
   PinFound := False;
   if assigned (Graph) then begin
      hr := Graph.EnumFilters(pEnumFilters);
      if (hr = S_OK) and assigned (pEnumFilters) then begin
         pEnumFilters.Reset;
         FiltersDone := false;
         while not FiltersDone do begin
            if Succeeded (pEnumFilters.Next(1, Filter, @cFetched)) then if assigned (Filter) then begin
               Continue := True;
               if IgnoreFilterName <> '' then begin
                  if Succeeded (Filter.QueryFilterInfo (FilterInfo)) then begin
                     FilterInfo.pGraph := nil;
                     Continue := Pos (IgnoreFilterName, FilterInfo.AchName) = 0;
                  end;
               end;
               if Continue then begin
                if Succeeded (Filter.EnumPins(Pins)) then begin
                  PinsDone := False;
                  Pins.Reset;
                  while not PinsDone do begin
                     if Succeeded (Pins.Next(1, FilterPin, @cFetched)) then if assigned (FilterPin) then begin
                        if Succeeded (FilterPin.QueryPinInfo (PinInfo)) then begin
                           if PinInfo.dir = Direction then begin // direction ok
                              if Succeeded (FilterPin.ConnectedTo (ConnectedTo)) then begin
                                 ConnectedTo := nil;
                                 IsConnected := True;
                              end
                              else begin
                                 IsConnected := False;
                              end;
                              if ((not MustBeUnconnected) and IsConnected) or (MustBeUnconnected and (not IsConnected)) then begin // connection ok
                                 if Succeeded (FilterPin.EnumMediaTypes (EnumMediaTypes)) then begin
                                    ENumMediaTypes.Reset;
                                    MediaTypesDone := False;
                                    while not MediaTypesDone do begin
                                       pmt := nil;
                                       if Succeeded (EnumMediaTypes.Next (1, pmt, nil)) then if assigned (pmt) then begin
                                          if _IsEqualGUID (@pmt.MajorType, MajorType) then begin
                                             PinFound := True;
                                             MediaTypesDone := True;
                                             PinsDone := True;
                                             FiltersDone := True;
                                          end;
                                          DeleteMediaType (pmt);
                                       end
                                       else begin
                                          MediaTypesDone := True;
                                       end;
                                    end;
                                    EnumMediaTypes := nil;
                                 end;
                              end;
                           end;
                           PinInfo.pFilter := nil;
                        end;
                        if not PinFound then begin
                           FilterPin := nil;
                        end
                        else begin
                           Pin := FilterPin;
                        end;
                     end
                     else begin
                        PinsDone := True;
                     end;
                  end;
                  Pins := nil;
                end;
               end;
               Filter := nil;
            end
            else begin
               FiltersDone := True;
            end;
         end;
         pEnumFilters:= nil;
      end;
   end;
   Result := PinFound;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure DeleteDownStream (var Graph: IGraphBuilder; var StartingPin: IPin; IsOutputPin: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ removes all the graph's filters
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   hr: HResult;
   pPin, InPin: IPin;
   PinInfo, PinInfo2: TPin_Info;
   pEnumPins: IEnumPins;
begin
   if not assigned (Graph) then Exit;
   if not assigned (StartingPin) then Exit;
   try
      if IsOutputPin then begin
         if StartingPin.ConnectedTo(InPin) <> S_OK then Exit;
      end
      else begin
         InPin := StartingPin;
      end;
      if InPin.QueryPinInfo (PinInfo) = S_OK then begin
         hr:= PinInfo.pFilter.EnumPins(pEnumPins);
         if (hr = S_OK) and assigned (pEnumPins) then begin
            pEnumPins.Reset;
            while pEnumPins.Next(1, pPin, nil) = S_OK do begin
               if assigned (pPin) then begin
                  pPin.QueryPinInfo(PinInfo2);
                  if PinInfo2.dir = PINDIR_OUTPUT then begin
                     DeleteDownStream (Graph, pPin, true);
                  end;
                  pPin.Disconnect;
                  pPin := nil;
                  PinInfo2.pFilter := nil;
               end;
            end;
            pEnumPins := nil;
         end;
         Graph.RemoveFilter(PinInfo.pFilter);
         PinInfo.pFilter := nil;
      end;
      InPin := nil;
   finally
      StartingPin.Disconnect;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ReturnTVFormat (Value: string): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if Value = 'NTSC M'           then Result := $00000001
   else if Value = 'NTSC M J'    then Result := $00000002
   else if Value = 'NTSC 433'    then Result := $00000004
   else if Value = 'PAL B'       then Result := $00000010
   else if Value = 'PAL D'       then Result := $00000020
   else if Value = 'PAL H'       then Result := $00000080
   else if Value = 'PAL I'       then Result := $00000100
   else if Value = 'PAL M'       then Result := $00000200
   else if Value = 'PAL N'       then Result := $00000400
   else if Value = 'PAL 60'      then Result := $00000800
   else if Value = 'SECAM B'     then Result := $00001000
   else if Value = 'SECAM D'     then Result := $00002000
   else if Value = 'SECAM G'     then Result := $00004000
   else if Value = 'SECAM H'     then Result := $00008000
   else if Value = 'SECAM K'     then Result := $00010000
   else if Value = 'SECAM K1'    then Result := $00020000
   else if Value = 'SECAM L'     then Result := $00040000
   else if Value = 'SECAM L1'    then Result := $00080000
   else if Value = 'PAL N COMBO' then Result := $00100000
   else begin
      Result := $00000001;
      WriteLog (nil, sRed, 'ERROR: invalid tv format');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ReturnAnalogVideoStandards (Value: LongInt): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ return the real video standard value for Put_TVFormat
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Standards: TstringList;
begin
   Standards := TstringList.Create;
   if (Value and $00000001) > 0 then Standards.Add ('NTSC M');
   if (Value and $00000002) > 0 then Standards.Add ('NTSC M J');
   if (Value and $00000004) > 0 then Standards.Add ('NTSC 433');
   if (Value and $00000010) > 0 then Standards.Add ('PAL B');
   if (Value and $00000020) > 0 then Standards.Add ('PAL D');
   if (Value and $00000080) > 0 then Standards.Add ('PAL H');
   if (Value and $00000100) > 0 then Standards.Add ('PAL I');
   if (Value and $00000200) > 0 then Standards.Add ('PAL M');
   if (Value and $00000400) > 0 then Standards.Add ('PAL N');
   if (Value and $00000800) > 0 then Standards.Add ('PAL 60');
   if (Value and $00001000) > 0 then Standards.Add ('SECAM B');
   if (Value and $00002000) > 0 then Standards.Add ('SECAM D');
   if (Value and $00004000) > 0 then Standards.Add ('SECAM G');
   if (Value and $00008000) > 0 then Standards.Add ('SECAM H');
   if (Value and $00010000) > 0 then Standards.Add ('SECAM K');
   if (Value and $00020000) > 0 then Standards.Add ('SECAM K1');
   if (Value and $00040000) > 0 then Standards.Add ('SECAM L');
   if (Value and $00080000) > 0 then Standards.Add ('SECAM L1');
   if (Value and $00100000) > 0 then Standards.Add ('PAL N COMBO');
   Result := Standards.Text;
   Standards.Free;
end;

const
   { this is the form of the TMotionDetector dialog }
   DFMData: array[0..2045] of byte = (
   $FF,$0A,$00,$54,$46,$52,$4D,$47,$52,$49,$44,$44,$49,$41,$4C,$4F,$47,$00,$30,$10,
   $E6,$07,$00,$00,$54,$50,$46,$30,$0E,$54,$66,$72,$6D,$47,$72,$69,$64,$44,$69,$61,
   $6C,$6F,$67,$0D,$66,$72,$6D,$47,$72,$69,$64,$44,$69,$61,$6C,$6F,$67,$04,$4C,$65,
   $66,$74,$03,$58,$01,$03,$54,$6F,$70,$03,$D6,$00,$05,$57,$69,$64,$74,$68,$03,$8B,
   $01,$06,$48,$65,$69,$67,$68,$74,$03,$CC,$01,$07,$43,$61,$70,$74,$69,$6F,$6E,$06,
   $0B,$47,$72,$69,$64,$20,$6C,$61,$79,$6F,$75,$74,$05,$43,$6F,$6C,$6F,$72,$07,$09,
   $63,$6C,$42,$74,$6E,$46,$61,$63,$65,$0C,$46,$6F,$6E,$74,$2E,$43,$68,$61,$72,$73,
   $65,$74,$07,$0F,$44,$45,$46,$41,$55,$4C,$54,$5F,$43,$48,$41,$52,$53,$45,$54,$0A,
   $46,$6F,$6E,$74,$2E,$43,$6F,$6C,$6F,$72,$07,$0C,$63,$6C,$57,$69,$6E,$64,$6F,$77,
   $54,$65,$78,$74,$0B,$46,$6F,$6E,$74,$2E,$48,$65,$69,$67,$68,$74,$02,$F5,$09,$46,
   $6F,$6E,$74,$2E,$4E,$61,$6D,$65,$06,$0D,$4D,$53,$20,$53,$61,$6E,$73,$20,$53,$65,
   $72,$69,$66,$0A,$46,$6F,$6E,$74,$2E,$53,$74,$79,$6C,$65,$0B,$00,$09,$46,$6F,$72,
   $6D,$53,$74,$79,$6C,$65,$07,$0B,$66,$73,$53,$74,$61,$79,$4F,$6E,$54,$6F,$70,$0E,
   $4F,$6C,$64,$43,$72,$65,$61,$74,$65,$4F,$72,$64,$65,$72,$08,$0D,$50,$69,$78,$65,
   $6C,$73,$50,$65,$72,$49,$6E,$63,$68,$02,$60,$0A,$54,$65,$78,$74,$48,$65,$69,$67,
   $68,$74,$02,$0D,$00,$06,$54,$49,$6D,$61,$67,$65,$07,$69,$6D,$67,$47,$72,$69,$64,
   $04,$4C,$65,$66,$74,$02,$06,$03,$54,$6F,$70,$02,$24,$05,$57,$69,$64,$74,$68,$03,
   $77,$01,$06,$48,$65,$69,$67,$68,$74,$03,$09,$01,$07,$41,$6E,$63,$68,$6F,$72,$73,
   $0B,$06,$61,$6B,$4C,$65,$66,$74,$05,$61,$6B,$54,$6F,$70,$07,$61,$6B,$52,$69,$67,
   $68,$74,$08,$61,$6B,$42,$6F,$74,$74,$6F,$6D,$00,$0B,$4F,$6E,$4D,$6F,$75,$73,$65,
   $44,$6F,$77,$6E,$07,$10,$69,$6D,$67,$47,$72,$69,$64,$4D,$6F,$75,$73,$65,$44,$6F,
   $77,$6E,$0B,$4F,$6E,$4D,$6F,$75,$73,$65,$4D,$6F,$76,$65,$07,$10,$69,$6D,$67,$47,
   $72,$69,$64,$4D,$6F,$75,$73,$65,$4D,$6F,$76,$65,$09,$4F,$6E,$4D,$6F,$75,$73,$65,
   $55,$70,$07,$0E,$69,$6D,$67,$47,$72,$69,$64,$4D,$6F,$75,$73,$65,$55,$70,$00,$00,
   $06,$54,$4C,$61,$62,$65,$6C,$0D,$6C,$62,$6C,$43,$6C,$69,$63,$6B,$4C,$65,$76,$65,
   $6C,$04,$4C,$65,$66,$74,$02,$08,$03,$54,$6F,$70,$02,$0C,$05,$57,$69,$64,$74,$68,
   $02,$2F,$06,$48,$65,$69,$67,$68,$74,$02,$0D,$07,$43,$61,$70,$74,$69,$6F,$6E,$06,
   $0B,$63,$6C,$69,$63,$6B,$20,$6C,$65,$76,$65,$6C,$00,$00,$06,$54,$4C,$61,$62,$65,
   $6C,$0E,$6C,$62,$6C,$47,$6C,$6F,$62,$61,$6C,$4C,$65,$76,$65,$6C,$04,$4C,$65,$66,
   $74,$02,$7E,$03,$54,$6F,$70,$02,$0C,$05,$57,$69,$64,$74,$68,$02,$35,$06,$48,$65,
   $69,$67,$68,$74,$02,$0D,$07,$43,$61,$70,$74,$69,$6F,$6E,$06,$0C,$67,$6C,$6F,$62,
   $61,$6C,$20,$6C,$65,$76,$65,$6C,$00,$00,$07,$54,$42,$75,$74,$74,$6F,$6E,$05,$62,
   $74,$6E,$4F,$4B,$04,$4C,$65,$66,$74,$02,$7A,$03,$54,$6F,$70,$03,$94,$01,$05,$57,
   $69,$64,$74,$68,$02,$46,$06,$48,$65,$69,$67,$68,$74,$02,$15,$07,$41,$6E,$63,$68,
   $6F,$72,$73,$0B,$08,$61,$6B,$42,$6F,$74,$74,$6F,$6D,$00,$07,$43,$61,$70,$74,$69,
   $6F,$6E,$06,$02,$4F,$4B,$08,$54,$61,$62,$4F,$72,$64,$65,$72,$02,$00,$07,$4F,$6E,
   $43,$6C,$69,$63,$6B,$07,$0A,$62,$74,$6E,$4F,$4B,$43,$6C,$69,$63,$6B,$00,$00,$05,
   $54,$45,$64,$69,$74,$0F,$65,$64,$74,$43,$75,$72,$72,$65,$6E,$74,$4C,$65,$76,$65,
   $6C,$04,$4C,$65,$66,$74,$02,$40,$03,$54,$6F,$70,$02,$08,$05,$57,$69,$64,$74,$68,
   $02,$21,$06,$48,$65,$69,$67,$68,$74,$02,$15,$08,$54,$61,$62,$4F,$72,$64,$65,$72,
   $02,$01,$04,$54,$65,$78,$74,$06,$01,$31,$00,$00,$07,$54,$55,$70,$44,$6F,$77,$6E,
   $0F,$75,$70,$64,$43,$75,$72,$72,$65,$6E,$74,$4C,$65,$76,$65,$6C,$04,$4C,$65,$66,
   $74,$02,$61,$03,$54,$6F,$70,$02,$08,$05,$57,$69,$64,$74,$68,$02,$0F,$06,$48,$65,
   $69,$67,$68,$74,$02,$15,$09,$41,$73,$73,$6F,$63,$69,$61,$74,$65,$07,$0F,$65,$64,
   $74,$43,$75,$72,$72,$65,$6E,$74,$4C,$65,$76,$65,$6C,$03,$4D,$69,$6E,$02,$01,$03,
   $4D,$61,$78,$02,$09,$08,$50,$6F,$73,$69,$74,$69,$6F,$6E,$02,$01,$08,$54,$61,$62,
   $4F,$72,$64,$65,$72,$02,$02,$04,$57,$72,$61,$70,$08,$07,$4F,$6E,$43,$6C,$69,$63,
   $6B,$07,$14,$75,$70,$64,$43,$75,$72,$72,$65,$6E,$74,$4C,$65,$76,$65,$6C,$43,$6C,
   $69,$63,$6B,$00,$00,$07,$54,$42,$75,$74,$74,$6F,$6E,$09,$62,$74,$6E,$43,$61,$6E,
   $63,$65,$6C,$04,$4C,$65,$66,$74,$03,$CA,$00,$03,$54,$6F,$70,$03,$94,$01,$05,$57,
   $69,$64,$74,$68,$02,$46,$06,$48,$65,$69,$67,$68,$74,$02,$15,$07,$41,$6E,$63,$68,
   $6F,$72,$73,$0B,$08,$61,$6B,$42,$6F,$74,$74,$6F,$6D,$00,$07,$43,$61,$70,$74,$69,
   $6F,$6E,$06,$06,$43,$61,$6E,$63,$65,$6C,$08,$54,$61,$62,$4F,$72,$64,$65,$72,$02,
   $03,$07,$4F,$6E,$43,$6C,$69,$63,$6B,$07,$0E,$62,$74,$6E,$43,$61,$6E,$63,$65,$6C,
   $43,$6C,$69,$63,$6B,$00,$00,$07,$54,$42,$75,$74,$74,$6F,$6E,$0B,$62,$74,$6E,$43,
   $6C,$65,$61,$72,$41,$6C,$6C,$04,$4C,$65,$66,$74,$03,$D0,$00,$03,$54,$6F,$70,$02,
   $08,$05,$57,$69,$64,$74,$68,$02,$3E,$06,$48,$65,$69,$67,$68,$74,$02,$15,$07,$43,
   $61,$70,$74,$69,$6F,$6E,$06,$09,$63,$6C,$65,$61,$72,$20,$61,$6C,$6C,$08,$54,$61,
   $62,$4F,$72,$64,$65,$72,$02,$04,$07,$4F,$6E,$43,$6C,$69,$63,$6B,$07,$10,$62,$74,
   $6E,$43,$6C,$65,$61,$72,$41,$6C,$6C,$43,$6C,$69,$63,$6B,$00,$00,$07,$54,$42,$75,
   $74,$74,$6F,$6E,$0C,$62,$74,$6E,$45,$6E,$61,$62,$6C,$65,$41,$6C,$6C,$04,$4C,$65,
   $66,$74,$03,$18,$01,$03,$54,$6F,$70,$02,$08,$05,$57,$69,$64,$74,$68,$02,$3E,$06,
   $48,$65,$69,$67,$68,$74,$02,$15,$07,$43,$61,$70,$74,$69,$6F,$6E,$06,$0A,$65,$6E,
   $61,$62,$6C,$65,$20,$61,$6C,$6C,$08,$54,$61,$62,$4F,$72,$64,$65,$72,$02,$05,$07,
   $4F,$6E,$43,$6C,$69,$63,$6B,$07,$11,$62,$74,$6E,$45,$6E,$61,$62,$6C,$65,$41,$6C,
   $6C,$43,$6C,$69,$63,$6B,$00,$00,$07,$54,$55,$70,$44,$6F,$77,$6E,$0E,$75,$70,$64,
   $47,$6C,$6F,$62,$61,$6C,$4C,$65,$76,$65,$6C,$04,$4C,$65,$66,$74,$03,$B8,$00,$03,
   $54,$6F,$70,$02,$08,$05,$57,$69,$64,$74,$68,$02,$0F,$06,$48,$65,$69,$67,$68,$74,
   $02,$15,$03,$4D,$69,$6E,$02,$00,$08,$50,$6F,$73,$69,$74,$69,$6F,$6E,$02,$32,$08,
   $54,$61,$62,$4F,$72,$64,$65,$72,$02,$06,$04,$57,$72,$61,$70,$08,$07,$4F,$6E,$43,
   $6C,$69,$63,$6B,$07,$13,$75,$70,$64,$47,$6C,$6F,$62,$61,$6C,$4C,$65,$76,$65,$6C,
   $43,$6C,$69,$63,$6B,$00,$00,$0A,$54,$50,$6F,$70,$75,$70,$4D,$65,$6E,$75,$0B,$70,
   $6F,$70,$53,$65,$74,$4C,$65,$76,$65,$6C,$04,$4C,$65,$66,$74,$03,$60,$01,$00,$09,
   $54,$4D,$65,$6E,$75,$49,$74,$65,$6D,$03,$4E,$31,$31,$03,$54,$61,$67,$02,$01,$07,
   $43,$61,$70,$74,$69,$6F,$6E,$06,$01,$31,$09,$52,$61,$64,$69,$6F,$49,$74,$65,$6D,
   $09,$07,$4F,$6E,$43,$6C,$69,$63,$6B,$07,$0B,$55,$70,$64,$61,$74,$65,$50,$6F,$70,
   $75,$70,$00,$00,$09,$54,$4D,$65,$6E,$75,$49,$74,$65,$6D,$03,$4E,$32,$31,$03,$54,
   $61,$67,$02,$02,$07,$43,$61,$70,$74,$69,$6F,$6E,$06,$01,$32,$09,$52,$61,$64,$69,
   $6F,$49,$74,$65,$6D,$09,$07,$4F,$6E,$43,$6C,$69,$63,$6B,$07,$0B,$55,$70,$64,$61,
   $74,$65,$50,$6F,$70,$75,$70,$00,$00,$09,$54,$4D,$65,$6E,$75,$49,$74,$65,$6D,$03,
   $4E,$33,$31,$03,$54,$61,$67,$02,$03,$07,$43,$61,$70,$74,$69,$6F,$6E,$06,$01,$33,
   $09,$52,$61,$64,$69,$6F,$49,$74,$65,$6D,$09,$07,$4F,$6E,$43,$6C,$69,$63,$6B,$07,
   $0B,$55,$70,$64,$61,$74,$65,$50,$6F,$70,$75,$70,$00,$00,$09,$54,$4D,$65,$6E,$75,
   $49,$74,$65,$6D,$03,$4E,$34,$31,$03,$54,$61,$67,$02,$04,$07,$43,$61,$70,$74,$69,
   $6F,$6E,$06,$01,$34,$09,$52,$61,$64,$69,$6F,$49,$74,$65,$6D,$09,$07,$4F,$6E,$43,
   $6C,$69,$63,$6B,$07,$0B,$55,$70,$64,$61,$74,$65,$50,$6F,$70,$75,$70,$00,$00,$09,
   $54,$4D,$65,$6E,$75,$49,$74,$65,$6D,$03,$4E,$35,$31,$03,$54,$61,$67,$02,$05,$07,
   $43,$61,$70,$74,$69,$6F,$6E,$06,$01,$35,$09,$52,$61,$64,$69,$6F,$49,$74,$65,$6D,
   $09,$07,$4F,$6E,$43,$6C,$69,$63,$6B,$07,$0B,$55,$70,$64,$61,$74,$65,$50,$6F,$70,
   $75,$70,$00,$00,$09,$54,$4D,$65,$6E,$75,$49,$74,$65,$6D,$03,$4E,$36,$31,$03,$54,
   $61,$67,$02,$06,$07,$43,$61,$70,$74,$69,$6F,$6E,$06,$01,$36,$09,$52,$61,$64,$69,
   $6F,$49,$74,$65,$6D,$09,$07,$4F,$6E,$43,$6C,$69,$63,$6B,$07,$0B,$55,$70,$64,$61,
   $74,$65,$50,$6F,$70,$75,$70,$00,$00,$09,$54,$4D,$65,$6E,$75,$49,$74,$65,$6D,$03,
   $4E,$37,$31,$03,$54,$61,$67,$02,$07,$07,$43,$61,$70,$74,$69,$6F,$6E,$06,$01,$37,
   $09,$52,$61,$64,$69,$6F,$49,$74,$65,$6D,$09,$07,$4F,$6E,$43,$6C,$69,$63,$6B,$07,
   $0B,$55,$70,$64,$61,$74,$65,$50,$6F,$70,$75,$70,$00,$00,$09,$54,$4D,$65,$6E,$75,
   $49,$74,$65,$6D,$03,$4E,$38,$31,$03,$54,$61,$67,$02,$08,$07,$43,$61,$70,$74,$69,
   $6F,$6E,$06,$01,$38,$09,$52,$61,$64,$69,$6F,$49,$74,$65,$6D,$09,$07,$4F,$6E,$43,
   $6C,$69,$63,$6B,$07,$0B,$55,$70,$64,$61,$74,$65,$50,$6F,$70,$75,$70,$00,$00,$09,
   $54,$4D,$65,$6E,$75,$49,$74,$65,$6D,$03,$4E,$39,$31,$03,$54,$61,$67,$02,$09,$07,
   $43,$61,$70,$74,$69,$6F,$6E,$06,$01,$39,$09,$52,$61,$64,$69,$6F,$49,$74,$65,$6D,
   $09,$07,$4F,$6E,$43,$6C,$69,$63,$6B,$07,$0B,$55,$70,$64,$61,$74,$65,$50,$6F,$70,
   $75,$70,$00,$00,$00,$00);

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function OverriddenTuningSpace (TuningSpace: Integer) : Integer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := 99990000 + TuningSpace;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function OleS(s: string; var OleStr: pOleStr): pOleStr;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ creates and Olestring, add it into the FOlestrings list to free it later,
{ and returns a pointer to this string. It is inserted in the 1st Index,
{ because no matter of the Index, it is only to free it later.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := StringToOleStr (s);
   OleStr := Result;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ListItemName (TextList: String; Index: Integer): String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TStringList;
begin
   Result := '';
   if Index < 0 then Exit;
   List := TStringList.Create;
   List.Text := TextList;
   if Index < List.Count then begin
      Result := List[Index];
   end;
   List.Free;
end;

{$IFDEF DELPHI_OR_BCB_4}
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function SafeLoadLibrary(const Filename: string): HMODULE;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   OldMode: UINT;
   FPUControlWord: Word;
   ErrorMode: UINT;
begin
   ErrorMode := SEM_NOOPENFILEERRORBOX;
   OldMode := SetErrorMode(ErrorMode);
   try
    asm
      FNSTCW  FPUControlWord
    end;
    try
      Result := LoadLibrary(PChar(Filename));
    finally
      asm
        FNCLEX
        FLDCW FPUControlWord
      end;
    end;
   finally
    SetErrorMode(OldMode);
   end;
end;
{$ENDIF DELPHI_OR_BCB_4}


var
  WMCreateWriterNetworkSink: function (out ppSink: IWMWriterNetworkSink): HRESULT; stdcall;
  WMCreateProfileManager: function (out ppProfileManager: IWMProfileManager): HRESULT; stdcall;
  WMCreateWriterPushSink: function (out ppSink: IWMWriterPushSink): HRESULT; stdcall;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.LoadWMVASFNetLib: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FirstLoad: Boolean;
begin
   Result := WMVLib <> 0;
   FirstLoad := False;
   if not Result then begin
      WMVLib := SafeLoadLibrary (WMVLibName);
      Result := WMVLib <> 0;
      FirstLoad := True;
   end;
   if Result then begin
      WMCreateWriterNetworkSink := GetProcAddress(WMVLib, 'WMCreateWriterNetworkSink');
      WMCreateProfileManager := GetProcAddress (WMVLib, 'WMCreateProfileManager');
      WMCreateWriterPushSink := GetProcAddress (WMVLib, 'WMCreateWriterPushSink');
   end;
   Result := assigned (WMCreateWriterNetworkSink) and assigned (WMCreateProfileManager) and assigned (WMCreateWriterPushSink);
   if not Result then begin
      if FirstLoad then begin
         LogB (True, LERROR, e_library_not_found, 'wmvcore.dll not found. Install the Media Player 9.');
      end;
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{                               TVIDEOGRABBER
{                                  class
{
{ the TVideoGrabber class is derived from TCustomPanel
{………………………………………………………………………………………………………………………………………………………………………………………………………………}

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure ClearSampleCaptureInfo (SampleCaptureInfo: pSampleCaptureInfo);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with SampleCaptureInfo^ do begin
      if assigned (FrameBuffer) then begin
         FrameBufferSize := 0;
         FreeMem (FrameBuffer);
         FrameBuffer := nil;
      end;
      Capturing := false;
      Processing := False;
      FrameAvail := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure GrabberProcessSample (GrabberControl: pGrabberControl; IsVideo: Boolean; pSample: IMediaSample; pmt: PAM_MEDIA_TYPE; StartTime: int64; EndTime: int64); stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pBuffer: pByte;
   SampleData: TSampleData;
   OnSampleCapture: TOnSampleCapture;
begin
   with TVdgr (GrabberControl^.Component) do begin
      if FDestroying then Exit;
      if IsVideo then begin
         OnSampleCapture := Intf.FOnSampleCapture_Video;
      end
      else begin
         OnSampleCapture := Intf.FOnSampleCapture_Audio;
      end;
      if not assigned (OnSampleCapture) then Exit;

      if pSample.GetPointer (pBuffer) = S_OK then begin
         with SampleData do begin
            SampleBuffer := pBuffer;
            SampleBufferSize := pSample.GetSize;
            SampleDataLength:= pSample.GetActualDataLength;

            pbmi := nil;
            if not IsVideo then begin
               FormatType := ft_WaveFormatEx;
            end
            else begin
               FormatType := ReturnFormatType (pmt);
               case FormatType of
                  ft_VideoInfo   : pbmi := @pVideoInfoHeader(pmt^.pbFormat)^.bmiHeader;
                   ft_VideoInfo2  : pbmi := @pVideoInfoHeader2(pmt^.pbFormat)^.bmiHeader;
                   ft_Mpeg1Video   : pbmi := @pMpeg1VideoInfo(pmt^.pbFormat)^.hdr.bmiHeader;
                   ft_Mpeg2Video  : pbmi := @pMpeg2VideoInfo(pmt^.pbFormat)^.hdr.bmiHeader;
               end;
            end;
            pFormat:= pmt^.pbFormat;
            SampleStartTime := StartTime;
            SampleEndTime := EndTime;
          end;
          OnSampleCapture (Intf, SampleData);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure GrabberProcessNotifyFrame (GrabberControl: pGrabberControl; IsVideo: Boolean; pSample: IMediaSample; StartTime: int64; EndTime: int64); stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Tick: dword;
   DiffTick: int64;
begin
   with TVdgr (GrabberControl^.Component) do begin
         with FCurrentFrameData do begin
            Tick := GetTickCount;
            DiffTick := Tick - gfNotifyPreviousTick;
            if (DiffTick > 66) or (DiffTick < 0) then begin
                gfNotifyPreviousTick := Tick;
                ProcessFrameTime (@FFrameInfo_Transmit, StartTime);
                NewFrameAvailable := True;
            end;
         end;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure GrabberNotifyDVData (GrabberControl: pGrabberControl; DVDateTime: pDVDateTime); stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   DayTable: PDayTable;
   FrameInfo: pCurrentFrameInfo;
begin
   with TVdgr (GrabberControl^.Component) do begin
         if FCurrent.FrameGrabber <> fg_Disabled then begin
            FrameInfo := @FFrameInfo_Grabber;
         end
         else begin
            FrameInfo:= @FFrameInfo_Current;
         end;
         Windows.CopyMemory (@FrameInfo^.FrameInfo.DVDateTime, DVDateTime, sizeof (TDVDateTime));
         with FrameInfo^.FrameInfo.DVDateTime do begin
            DayTable := @MonthDays[IsLeapYear(Year)];
             if (not ((Year >= 1) and (Year <= 9999) and (Month >= 1) and (Month <= 12) and (Day >= 1) and (Day <= DayTable^[Month]))) then begin
               ZeroMemory (@FrameInfo^.FrameInfo.DVDateTime, sizeof (TDVDateTime));
               DVDateTime.IsAvailable := False;
            end;
         end;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure GrabberProcessSampleAsync (GrabberControl: pGrabberControl; IsVideo: Boolean; pSample: IMediaSample; pmt: PAM_MEDIA_TYPE; StartTime: int64; EndTime: int64); stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pBuffer: pByte;
   pSampleInfo: pSampleCaptureInfo;
   BufferSize: LongInt;
   OnSampleCapture: TOnSampleCapture;
begin
   with TVdgr (GrabberControl^.Component) do begin
      if IsVideo then begin
         OnSampleCapture := Intf.FOnSampleCapture_Video;
      end
      else begin
         OnSampleCapture := Intf.FOnSampleCapture_Audio;
      end;
      if not assigned (OnSampleCapture) then Exit;


      if IsVideo then begin
         pSampleInfo := @FSampleInfoVideo;
      end
      else begin
         pSampleInfo := @FSampleInfoAudio;
      end;

      with pSampleInfo^ do begin
         if Processing then Exit;
         Capturing := true;

         if pSample.GetPointer (pBuffer) = S_OK then begin

            if not IsVideo then begin
               FormatType := ft_WaveFormatEx;
               pbmi := nil;
            end
            else begin
               FormatType := ReturnFormatType (pmt);
               case FormatType of
                  ft_VideoInfo   : pSampleInfo^.pbmi := @pVideoInfoHeader(pmt^.pbFormat)^.bmiHeader;
                  ft_VideoInfo2  : pSampleInfo^.pbmi := @pVideoInfoHeader2(pmt^.pbFormat)^.bmiHeader;
                  ft_Mpeg1Video   : pSampleInfo^.pbmi := @pMpeg1VideoInfo(pmt^.pbFormat)^.hdr.bmiHeader;
                  ft_Mpeg2Video  : pSampleInfo^.pbmi := @pMpeg2VideoInfo(pmt^.pbFormat)^.hdr.bmiHeader;
               else
                  pbmi := nil;
               end;
            end;
              BufferSize := pSample.GetSize;
            if assigned (FrameBuffer) then begin
               if BufferSize <> FrameBufferSize then begin
                  FreeMem (FrameBuffer);
                  GetMem (Framebuffer, BufferSize);
               end;
            end
            else begin
               GetMem (Framebuffer, BufferSize);
            end;
            FrameBufferSize := BufferSize;
            FrameDataLength := pSample.GetActualDataLength;
            Windows.CopyMemory (FrameBuffer, pBuffer, FrameBufferSize);
            pFormat := pmt^.pbFormat;
            FrameStartTime := StartTime;
            FrameEndTime := EndTime;
            FrameAvail := True;
         end;
         Capturing := False;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure ClearGrabberHandler (GrabberHandler: pGrabberHandler; Init: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with GrabberHandler^ do begin
      if assigned (Control) then Control := nil;
      if assigned (Grabber) then Grabber := nil;
      if assigned (FrameSample) then FrameSample := nil;
      if Init then begin
         Handle := 0;
      end
      else begin
         if Handle <> 0 then begin
            FreeLibrary (Handle);
            Handle := 0;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure Tvdgr.ClearGrabberHandlers (Init: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: TGrabberHandlers;
begin
   for i := low (TGrabberHandlers) to high (TGrabberHandlers) do begin
      ClearGrabberHandler (@FGrabberHandlers[i], Init);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure InitPpSaver (ppSaver: pPpSaver);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with ppSaver^ do begin
      ppInstance := nil;
      ppRestoreProperties := True;
      ppSaveProperties := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure InitReencodingSettings (ReencodingSettings: pReencodingSettings);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with ReencodingSettings^ do begin
      StopTime := -1;
      IncludeVideoStream := true;
      IncludeAudioStream := true;
      NewVideoClip := '';
      SourceVideoClip := '';
      StartTime := -1;
      UseFrameGrabber := True;
      UseVideoCompressor := False;
      UseAudioCompressor := False;
      Method := rm_AVI;
      WMVOutput := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure ReinitInitCameraControl (CameraControl: p_CameraControlSettings);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: TCameraControl;
begin
   for i := low (TCameraControl) to high(TCameraControl)  do begin
      with CameraControl^[i] do begin
         Available := False;
         Value := 0;
         Min := 0;
         Max := 0;
         SteppingDelta := 0;
         Default_ := 0;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure ReinitInitVideoQuality (VideoQuality: p_VideoQualitySettings);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: TVideoQuality;
begin
   for i := low (TVideoQuality) to high (TVideoQuality) do begin
      with VideoQuality^[i] do begin
         Available := False;
         Value := 0;
         Min := 0;
         Max := 0;
         SteppingDelta := 0;
         Default_ := 0;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor Tvdgr.Create (VideoGrabber: TJxdVideoGrabber; IsInDesignMode: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
begin
   Intf := VideoGrabber;

   FApplyingSetAudioDevice := False;
   FApplyingSetAudioDeviceDone := False;
   FApplyingSetVideoDevice := False;
   FApplyingSetVideoDeviceDone := False;


   InitAudioRegSave (@FAudioRegSave);
   InitGlobalRegSave (@FGlobalRegSave);
   InitVideoRegSave (@FVideoRegSave);

   LoadGlobalSettingsFromRegistry;

   ClearAudioDeviceRendering (@FAudioRendering);
   FAutoTuningStepThread := nil;
   FBorderThickness := GetSystemMetrics (SM_CXEDGE) shl 1;
   ReinitInitCameraControl (@FCameraControl);
   FCheckVMR7Location := False;
   FColorKeyLow := $F000F;
   FColorKeyHigh := $F000F;
   FColorKeysDefault := True;
   FCopyingPreallocData := False;
   FCrossbar[LongInt(cs_AudioCrossbar)] := TCrossbar.Create;
   FCrossbar[LongInt(cs_VideoCrossbar)] := TCrossbar.Create;
   FCrossbarAutoRouter := nil;
   ReinitCurrentParams (True);
   FCurrentParamsInitialized := False;
   //ReInitCurrentFrameData; done at the end, uses FNotificationSleepTimeUsed
   FDestroying := False;
   FDiscovering:= False;
   FDynamicallyCreatedDone := False;
   FEventList := TCsList.Create;

   FExternalSourceFrameData.FrameData := nil;
   FExternalSourceFrameData.CanCreateNewFrame := True;
   FExternalSourceFrameData.CanAccessFrame := False;

   FFrameRate := 2997;
   FFilterState := State_Stopped;
   FFrameGrabberMediaType := nil;
   ZeroMemory (@FFrameInfo_Current, sizeof (TCurrentFrameInfo));
   ZeroMemory (@FFrameInfo_Grabber, sizeof (TCurrentFrameInfo));
   ZeroMemory (@FFrameInfo_Transmit, sizeof (TCurrentFrameInfo));
   FGetTimeFromClock:= False;

   FGraphAccessAllowed := False;
   FGraphState := gs_None;
   FGraphType := cs_Down;

   ClearGrabberHandlers (True);


   FInFrameProgressRunning := False;
   FLastPreviewFailed:= False;
   FLastReencodingSourceFileName:= '';
   FLastReencodingNewFileName:= '';
   FLogoDisplayed := False;
   FLogoLayout := lg_Stretched;
   FLogoBitmap := nil;
   FMotionDetector  := TImplMotionDetector.Create;
   FMPEGWriterBaseFilterName := '';
   FMPEGWriterFilter:= '';
   FMPEGWriterPropertySet := 'PropertySet01';
   FMultiplexedMaster.Vdgr := nil;
   FMultiplexedMaster.UniqueID := -1;
   FMultiplexedSlaveFrameRate := 400;
   FMustReencodeRecordedFile:= false;
   FMutedSPKDevice:= -1;
   FMutedSPKDeviceInput:= -1;
   FNeedFrameOverlayDC := False;
   FNotifyingFrame := False;
   FOutputFileName := '';
   ZeroMemory (@FOverlayRendererW, sizeof (TRendererW));
   FPlayerBackwardTimerEnabled := False;
   FPlayerBufferingData := False;
   FPlayerCanRefreshPosition := False;
   FPlayerCanSeek := True;
   FPlayerFailedToInsertFrameGrabber := False;
   //InitppSaver (@FPpSaver_VideoDevice);
   InitppSaver (@FPpSaver_MPEGWriter);
   FPreallocatedFileCancelCreation := False;
   FPreallocatedFileSuccessfullyCreated := False;
   FPreferredVideoHeight:= 0;
   FPreferredVideoWidth:= 0;
   FPlayerAudioCodec:= '';
   FPlayerVideoCodec:= '';
   FProcessingCommand := False;
   FProcessingRGBFrame := False;
   FProcessingStopGraph := False;
   FPropertyPageSaver := nil;
   FpVideoDeviceInUse := nil;
   FPushSourceConfig.Vdgr := nil;
   FRaiseBacktimedFramesCountReached := False;
   FRaiseBacktimedFramesCountReachedDone := False;
   FRaiseDeviceLost := false;
   FRaiseDiskFull := false;
   FRaiseEndOfStream := false;
   FRaiseGraphError := false;
   FRaisePlayerStartBuffering:= False;
   FRaisePlayerEndBuffering:= False;
   FRaiseReencodingStreamControlStopped := False;
   FRealFrameRate := 0;
   FRealRecordingFileName := '';
   FRecordingAutoFileSequentialCountIndex := 0;
   FRecordingBacktimedFramesArray := TList.Create;
   FRecordingBacktimedFramesArrayIndex := 0;
   FRecordingDuration := 0;
   FRecordingResultNotifiedAfterReencoding := False;
   FRecordingStarted := False;
   FRecordingSuccessful := False;
   FReencodeOrRecopyDataSucceeded := False;
   FReencodingProgressInfo.Percent := 0;
   FReencodingProgressInfo.Position := 0;
   FReencodingProgressInfo.Duration := 0;
   FReencodingProgressInfo.Comment := '';
   FReencodingCopyingPreallocatedFile := False;
   FRenderingAudio := False;
   FResizingWindow := false;
   FRestartingGraph := false;
   FSampleInfoAudio.FrameBuffer := nil;
   ClearSampleCaptureInfo (@FSampleInfoAudio);
   FSampleInfoVideo.FrameBuffer := nil;
   ClearSampleCaptureInfo (@FSampleInfoVideo);
   FSavedBalance := -1;
   FSavedVolume := -1;
   FSaveSequentialFileCount:= -1;
   FShapeOverlayList := TList.Create;

   FSlaveMultiplexedData.LastFrameData := nil;
   FSlaveMultiplexedData.pCxMediaType_OwnedByMaster := nil;
   FSlaveMultiplexedData.CanCreateLastFrame := True;
   FSlaveMultiplexedData.CanAccessLastFrame := False;

   FStoragePath_DoUpdate := True;
   FStreamingHostName:= '';
   FStreamingHostPort:= 0;
   FStretchPreferredVideoSize := False;
   FTemporaryRecordingFileName:= '';
   for i := 0 to MAXCUSTOMVARS do FTextOverlayCustomVars[i] := '';
   FTaskList := TCsList.Create;
   FTextOverlayData[0].Assigning := False;
   FTextOverlayData[0].Processing := False;
   FTextOverlayData[1].Assigning := False;
   FTextOverlayData[1].Processing := False;
   FTextOverlayDataInUse := 0;
   {FThirdPartyFilter initialized in ClearGraph}
   FTimerActivateReadyToStart := nil;
   InitializeCriticalSection (FTransmitFrameInfoSection);
   FTransformConfig.Enabled := False;
   FTransformConfig.VideoRotation := rt_0_deg;
   FTransformConfig.VideoRotation_90_or_270 := False;
   FTransformConfig.VideoHalfDeinterlacing := False;
   FTransformConfig.CustomSubtype := False;
   FTVFrequencyOverrideInUse:= False;
   FTVProcessingTVAutoScan := False;
   FTVScanCurrentChannel := 0;
   FTVScanCurrentCountryCode:= -1;
   FTVScanCurrentTunerInputType:= -1;
   FTVScanMaxChannel := 0;
   FTVScanStopRequest := False;
   FVideoFromImages.BitmapsFileStream := nil;
   FVideoFromImages.BitmapsFileStreamName := '';
   FVideoFromImages.BitmapsCount := 0;
   FVideoFromImages.CreatingSetOfBitmaps := False;
   FVideoFromImages.InUse := False;
   FVideoPinCategoryUsed := @PIN_CATEGORY_CAPTURE;
   FVideoPortHeight:= 576;
   FVideoPortWidth:= 720;
   ZeroMemory (@FVideoRendererW, sizeof (TRendererW));
   ZeroMemory (@FVideoRendererW2, sizeof (TRendererW));
   ReinitInitVideoQuality(@FVideoQuality);
   FVideosizes := TstringList.Create;
   FVideosizes.Sorted := True;
   FVideosizes.Duplicates := dupIgnore;
   FVideoSubtypes := TstringList.Create;
   FVideoSubtypes.Sorted := false;
   FVideoWindow:= TVideoWindow.Create (0, True, True, 320, 240, 10, 10, 320, 240);
   FVideoWindow.FOnVideoWindowNotify := VideoWindowNotify;
   FVideoWindow2:= TVideoWindow.Create (1, False, False, 320, 240, 400, 10, 320, 240);
   FVideoWindow2.FOnVideoWindowNotify := VideoWindowNotify;
   FVideoWindow2.FAlternateVideoWindow := FVideoWindow;
   FVideoWindow.FAlternateVideoWindow := FVideoWindow2;
   FUseMasterStream := ms_AudioMaster;
   FUsedPreallocFileName := '';

   // BEGIN EXPOSED PROPERTIES
   FASFSettings.AudioBitRate := -1;
   FASFSettings.AudioChannels := -1;
   FASFSettings.VideoBitRate := -1;
   FASFSettings.VideoQuality := -1;
   FASFSettings.VideoMaxKeyFrameSpacing := -1;
   FASFSettings.VideoWidth := 320;
   FASFSettings.VideoHeight := 240;
   FASFSettings.DeinterlaceMode := LongWord (adm_NotInterlaced);
   FASFSettings.FixedFrameRate := False;
   FASFSettings.JPEGCompressionQuality := LongWord (-1);

   FASFMediaServerPublishingPoint := 'http://YourWindowsMediaServer/YourPublishingPoint';
   FASFNetworkPort := 0;
   FASFNetworkMaxUsers := 5;
   FASFProfile := -1;
   FASFProfileFromCustomFile := '';
   FAssociateAudioAndVideoDevices := False;
   FAudioCompressor := 0;
   FAutoConnectRelatedPins := True;
   FAudioDevice:= 0;
   FAudioDeviceRendering := False;
   FAudioRecording:= False;
   FAutoFilePrefix := 'vg';
   FAutoFileName:= fn_sequential;
   FAudioFormat := af_Default;
   FAutoRefreshPreview := True;
   FAutoStartPlayer := true;
   FAutoStartPreview := False;
   FAVIFormatOpenDML:= True;
   FBackgroundColor := clBlack;
   FBorderStyle := bsSingle;
   FBurstCount:= 3;
   FBurstInterval:= 0;
   FBurstMode:= false;
   FBurstType := fc_TBitmap;
   FBusyCursor := crHourGlass;
   FCameraControlSettings := True;
   FCaptureFileExt := '';
   FColorKeyEnabled:= False;
   FCompressionMode:= cm_NoCompression;
   FCompressionType := ct_Video;
   FDVRgb219 := false;
   //FDVEncodingResolution: TDVSize;
   //FDVEncodingVideoStandard: TDVVideoStandard;
   //FDVEncodingVideoFormat: TDVVideoFormat;
   FDVReduceFrameRate:= False;
   FEventNotificationSynchrone := False;
   FFrameBuffers:= 5;
   FFrameCaptureWithoutOverlay := False;
   FFrameCaptureZoomSize := 100;
   FFrameGrabber := fg_PreviewStream;
   FFrameGrabberCurrentRGBFormat := fgf_Default;
   FFrameGrabberRGBFormat := fgf_Default;
   FFrameGrabberSynchrone := False;
   FInitializedAtRuntime := False;
   FHoldRecording := False;
   FIsRecordingPaused := False;
   FIsAudioInputBalanceAvailable:= ts_Undefined;
   FIsPlayerAudioStreamAvailable := ts_Undefined;
   FIsTVAutoTuneRunning := False;
   FIsTunerInputSelected := False;
   FJPEGPerformance := jpBestQuality;
   FJPEGProgressiveDisplay := False;
   FJPEGQuality := 100;
   FLast_BurstFrameCapture_FileName:= '';
   FLast_CaptureFrameTo_FileName:= '';
   FMpegStreamType := mpst_Default;
   FMultiplexedRole := mr_NotMultiplexed;
   for i := MULTIPLEXEDSLAVE_MINBOUND to MULTIPLEXEDSLAVE_MAXBOUND do begin
      FMultiplexedSlave[i].Vdgr := nil;
      FMultiplexedSlave[i].UniqueId := -1;
   end;
   FMuteAudioRendering := False;
   FNetworkStreaming := ns_Disabled;
   FNormalCursor := crDefault;
   FNotificationMethod := DEFAULTNOTIFICATIONMETHOD;
   FNotificationSleepTime := -1;
   FNotificationSleepTimeUsed := DEFAULTNOTIFICATIONSLEEPTIME;
   FNotificationPriority := tpNormal;
   FPlayerAudioRendering := True;
   FPlayerDVSize := dvFull;
   FPlayerDuration := 1; // to avoid "divide by 0" error
   FPlayerFastSeekSpeedRatio := 4;
   FPlayerFileName := '';
   FPlayerFrameCount := 1; // to avoid "divide by 0" error
   FPlayerForcedCodec:= '';
   FPlayerRefreshPausedDisplay:= True;
   FPlayerSpeedRatio := 1;
   FPlayerTrackBar := nil;
   FPreallocCapFileCopiedAfterRecording := True;
   FPreallocCapFileEnabled := False;
   FPreallocCapFileName := '';
   FPreallocCapFileSizeInMB := 100;
   FPreviewZoomSize := 100;
   FRecordingBacktimedFramesCount := 0;
   FRecordingCanPause := False;
   FRecordingFileName:= '';
   FRecordingInNativeFormat:= False;
   FRecordingMethod := rm_AVI;
   FRecordingOnMotion_MotionThreshold := 0.001;
   FRecordingOnMotion_Enabled := False;
   FRecordingOnMotion_NoMotionPauseDelayMs := 2000;
   FRecordingFromBitmap := TRecordingFromBitmap.Create;
   InitReencodingSettings (@FReencodingSettings);
   FSampleCapture_Audio := sc_Disabled;
   FSampleCapture_Video := sc_Disabled;
   FSampleCaptureAsyncEvent:= True;
   FShapeOverlay := nil;
   FShapeOverlayEnabled:= false;
   //FShowDialogs := [];
   FSpeakerControl := False;
   FStoragePath := GetCurrentDir;
   FStoreDeviceSettingsInRegistry:= true;
   FStreamingURL:= '';
   FSynchronized := False;
   FTextOverlayAlign := tf_Left;
   FTextOverlayBkColor := clWhite;
   FTextOverlayFont := TFont.Create;
   FTextOverlayFont.Assign (Intf.Font);
   FTextOverlayFont.Color := clAqua;
   FTextOverlayEnabled:= false;
   FTextOverlayLeft:= 0;
   FTextOverlayRight:= 320;
   FTextOverlayString:= 'Note: the date/time formats ' +#13#10+ 'can be easily modified.' +#13#10+ #13#10+'system date/time: %sys_time[dd/mm/yy hh:nn:ss]%' +#13#10+ 'DV time code: %time_code%' +#13#10+ 'DV date/time: %dv_time[dd/mm/yy hh:nn:ss]%' +#13#10+ 'frame count: %frame_count%' +#13#10+ 'time (full): %time_full%' +#13#10+ 'time (sec): %time_sec%' +#13#10+ 'time (ns): %time_100ns%';
   FTextOverlayTop:= 0;
   FTextOverlayTransparent := true;
   FTranslateMouseCoordinates := True;
   ZeroMemory (@FTVChannelInfo, sizeof (TTVChannelInfo));
   FTVUseFrequencyOverrides := True;
   FVideoCompression_KeyFrameRate := 15;
   FVideoCompression_PFramesPerKeyFrame := 0;
   FVideoCompression_Quality := 1.0;
   FVideoCompression_WindowSize := -1;
   FVideoCompressor := 0;
   FVideoControlSettings:= True;
   FVideoDevice:= 0;
   FVideoEffects.Brightness := 0;
   FVideoEffects.Contrast := 0;
   FVideoEffects.Saturation := 0;
   FVideoEffects.Hue := 0;
   FVideoEffects.GrayScale := False;
   FVideoEffects.InvertColors := False;
   FVideoEffects.Deinterlacing := False;
   FVideoEffects.LeftRight := False;
   FVideoEffects.TopDown := False;
   FVideoEffects.Enabled := False;
   FVideoFromImages_SourceDirectory := FStoragePath;
   FVideoFromImages_TemporaryFile := 'SetOfBitmaps01.dat';
   FVideoFromImages_BitmapsSortedBy := fs_TimeAsc;
   FVideoFromImages_RepeatIndefinitely := False;
   FVideoQualitySettings := True;
   FVideoRenderer := vr_AutoSelect;
   FVideoSource := vs_VideoCaptureDevice;
   FVideoSource_FileOrURL := 'http://www.datastead.com/demo/demo.wmv';
   FVideoSource_FileOrURL_StartTime := -1;
   FVideoSource_FileOrURL_StopTime := -1;
   FVideoSourceWidth := 320;
   FVideoSourceHeight := 240;
   FUploadToDV_Device := -1;

   ReInitCurrentFrameData;

   // END EXPOSED PROPERTIES




end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TJxdVideoGrabber.Create (Aowner: TComponent);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
   TempSyncManager: TSyncManager;
begin
   inherited Create (AOwner);

   _VdgrInitialized := False;

   if not IsInDesignMode then begin
      if csDesigning in ComponentState then begin
         IsInDesignMode := True;
      end;
   end;

  _Vdgr := TVdgr.Create (Self, IsInDesignMode);

  with TVdgr(_Vdgr) do begin
    if not IsInDesignMode then begin

      if not assigned (_SyncManager) then begin
         TempSyncManager := TSyncManager.Create (FNotificationPriority);
         _SyncManager := TempSyncManager;
      end;

      FullRepaint := false;

      TVdgr(_Vdgr).ClearGraph (True);

      for i := 0 to TThirdPartyFilterListBound do begin
         ThirdPartyFilter_ClearList (TThirdPartyFilterList (i));
      end;

      WriteLog ('+', sGrey, 'component initialized');
      i := _SyncManager.FVideoGrabberList.Add (_Vdgr);
      SetUniqueID (i);

      with Tvdgr (_vdgr) do begin
         FTaskThread := TTaskThread.Create ('task', True, FNotificationPriority, FNotificationMethod, Intf, FNotificationSleepTimeUsed);
         FTaskThread.DoResume;
      end;


      FInitializedAtRunTime := True;
   end
   else begin
      Caption := Name;
   end;
   FBusy := False;

   BevelInner := bvNone;
   BevelOuter := bvNone;
   BorderWidth := 0;

   Height:= 320;
   Width:= 240;

   BorderStyle := bsSingle;

   inherited OnDblClick := OnDisplayFormDblClick;
   inherited OnClick := OnDisplayFormClick;
   inherited OnMouseMove := OnDisplayFormMouseMove;
   inherited OnMouseDown := OnDisplayFormMouseDown;
   inherited OnMouseUp := OnDisplayFormMouseUp;

  end;
  _VdgrInitialized := True;
  SetVideoControlMode( [vc_Trigger] );
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
destructor TVdgr.Destroy;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not IsInDesignMode then begin

      ClearGraph (True);

      SaveGlobalSettingsToRegistry;

      FTaskList.Lock;
      while FTaskList.Count > 0 do begin
         FreeMem (FTaskList[0]);
         FTaskList.Delete (0);
      end;
      FTaskList.Unlock;

      FTaskList.Free;

      FEventList.Lock;
      while FEventList.Count > 0 do begin
         FreeMem (FEventList[0]);
         FEventList.Delete (0);
      end;
      FEventList.UnLock;

      FEventList.Free;

      FRecordingFromBitmap.Free;

      SaveCurrentVideoDeviceSettingsToRegistry;
      SaveCurrentAudioDeviceSettingsToRegistry;

      FreeAndNilDualThread (TDualThread (FAutoTuningStepThread));

      FreeAndNilDualThread (TDualThread (FTaskThread));


   end;

   DeleteCriticalSection (FTransmitFrameInfoSection);

   while FRecordingBacktimedFramesArray.Count > 0 do begin
      FRecordingBacktimedFramesArray.Delete (0);
   end;

   FRecordingBacktimedFramesArray.Free;

   FVideoSizes.Free;

   FVideoSubtypes.Free;
   FShapeOverlayList.Free;
   FCrossbar[LongInt(cs_VideoCrossbar)].Free;
   FCrossbar[LongInt(cs_AudioCrossbar)].Free;

   if assigned (FLogoBitmap) then begin
      FLogoBitmap.Free;
   end;

   FVideoWindow.Free;
   FVideoWindow2.Free;

   FMotionDetector.Free;


   inherited Destroy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
destructor TJxdVideoGrabber.Destroy;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ purges the command queue, releases the mainform's OnCloseQuery event
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
begin
      _VdgrInitialized := False;

      if assigned (_SyncManager) then begin
         _SyncManager.FVideoGrabberList.Remove (_Vdgr);
      end;


      with TVdgr(_Vdgr) do begin
         for i := MULTIPLEXEDSLAVE_MINBOUND to MULTIPLEXEDSLAVE_MAXBOUND do begin
            if assigned (FMultiplexedSlave[i].Vdgr) then begin
               FMultiplexedSlave[i].Vdgr.FMultiplexedMaster.Vdgr := nil;
               FMultiplexedSlave[i].Vdgr := nil;
            end;
         end;

         if assigned (FMultiplexedMaster.Vdgr) then begin
            for i := MULTIPLEXEDSLAVE_MINBOUND to MULTIPLEXEDSLAVE_MAXBOUND do begin
                if FMultiplexedMaster.Vdgr.FMultiplexedSlave[i].Vdgr = _Vdgr then begin
                   FMultiplexedMaster.Vdgr.FMultiplexedSlave[i].Vdgr := nil;
                end;
            end;
         end;
      end;


      TVdgr(_Vdgr).FDestroying := True;

      TVdgr(_Vdgr).FShapeOverlayList.Clear;

      TVdgr(_Vdgr).FShapeOverlay := nil;
      TVdgr(_Vdgr).FPlayerTrackBar := nil;

      FOnAudioDeviceSelected:= nil;
      FOnVideoDeviceSelected:= nil;
      FOnFrameProgress:= nil;
      FOnRecordingReadyToStart:= nil;
      FOnRecordingCompleted:= nil;
      FOnRecordingStarted:= nil;
      FOnColorKeyChange:= nil;
      FOnCopyPreallocDataCompleted:= nil;
      FOnCopyPreallocDataProgress:= nil;
      FOnCopyPreallocDataStarted:= nil;
      FOnCreatePreallocFileStarted:= nil;
      FOnCreatePreallocFileCompleted:= nil;
      FOnDeviceArrivalOrRemoval:= nil;
      FOnDeviceLost:= nil;
      FOnDirectNetworkStreamingHostUrl:= nil;
      FOnDiskFull:= nil;
      FOnFrameOverlayUsingDC:= nil;
      FOnFrameOverlayUsingDIB:= nil;
      FOnFrameOverlayUsingVIDEOHDR:= nil;
      FOnInactive:= nil;
      FOnLog:= nil;
      FOnFrameCaptureCompleted:= nil;
      FOnDVCommandCompleted:= nil;
      FOnKeyPress:= nil;
      FOnMouseDown:= nil;
      FOnMouseMove:= nil;
      FOnMouseUp:= nil;
      FOnNoVideoDevices:= nil;
      FOnPlayerEndOfStream:= nil;
      FOnPlayerBufferingData:= nil;
      FOnPlayerOpened:= nil;
      FOnPreviewStarted:= nil;
      FOnSampleCapture_Audio:= nil;
      FOnSampleCapture_Video:= nil;
      FOnReencodingCompleted:= nil;
      FOnReencodingProgress:= nil;
      FOnBitmapsLoadingProgress:= nil;
      FOnReencodingStarted:= nil;
      FOnResizeVideo:= nil;
      FOnReinitializing:= nil;
      FOnTVChannelSelected:= nil;
      FOnTVChannelScanCompleted:= nil;
      FOnTVChannelScanStarted:= nil;
      FOnThirdPartyFilterConnected:= nil;
      FOnVideoCompressionSettings:= nil;
      FOnMotionDetected:= nil;
      FOnMotionNotDetected:= nil;

      TVdgr(_Vdgr).FTextOverlayFont.Free;

      TVdgr(_Vdgr).Free;
      _Vdgr := nil;

      inherited Destroy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VideoFromImages_CreateSetOfBitmaps: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if FVideoFromImages.CreatingSetOfBitmaps then Exit;
      if LogB ((FVideoSource = vs_VideoFromImages) and (FGraphType <> cs_Down), LERROR, e_failed_to_load_set_of_bitmaps, 'stop preview or recording first.') then Exit;
      Result := CreateSetOfBitmaps;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.Loaded;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   inherited;
   with TVdgr(_Vdgr) do begin
      if FInitializedAtRuntime then begin
         Caption := '';
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.Paint;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   x, y: LongInt;
begin
  if _VdgrInitialized then begin
    with TVdgr(_Vdgr) do begin
      if FFilterState = State_Running then begin
      //if (FGraphType in [cs_Preview, cs_Recording, cs_Playback]) and (IsWindowEmbedded (FVideoWindow) or IsWindowEmbedded (FVideoWindow2))  then begin
         // do nothing
      end
      else begin
         if FLogoDisplayed and assigned (FLogoBitmap)then begin
            case FLogoLayout of
               lg_Centered: begin
                  inherited;
                  x := Width - FLogoBitmap.Width;
                  y := Height - FLogoBitmap.Height;
                  if x < 0 then x := 0;
                  if y < 0 then y := 0;
                  Canvas.Draw (x shr 1, y shr 1, FLogoBitmap);
               end;
               lg_Stretched: begin
                  Canvas.StretchDraw (Rect (0, 0, ClientWidth, ClientHeight), FLogoBitmap);
               end;
               lg_Repeated: begin
                  if FLogoBitmap.Width < 1 then Exit;
                  if FLogoBitmap.Height < 1 then Exit;
                  y := 0;
                  while (y < Height) do begin
                     x := 0;
                     while (x < Width) do begin
                        Canvas.Draw (x, y, FLogoBitmap);
                        inc (x, FLogoBitmap.Width);
                    end;
                     inc (y, FLogoBitmap.Height);
                   end;
               end;
            end;
         end
         else begin
            inherited;
         end;
      end;
   end;
  end
  else begin
     inherited;
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.About;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
   Year: LongInt = 2004;
   Copyright: string = ' daetsataD )c( thgirypoC';
var
   sCopyRight: String;
   i: LongInt;
begin
   with TVdgr(_Vdgr) do begin
      sCopyright := '';
      for i := length (Copyright) downto 1 do begin
         sCopyright := sCopyright + Copyright[i];
      end;
      ShowMessage ('    ' + Intf.ClassName + ' ' + TVideoGrabberVersion + #13#10 + '       ' + sCopyright + IntToStr (Year));
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CrossbarGetPInBounds (Crossbar: TCrossbarSelector; var InputCount, OutputCount: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      with FCrossbar[LongInt(Crossbar)] do begin
         if not assigned (F_Crossbar) then Exit;
         InputCount := FInBound;
         OutputCount := FOutBound;
         Result := true;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CrossbarGetPinInfo (Crossbar: TCrossbarSelector; PinDirection: TPin_Direction; Index: LongInt; var IndexRelated: LongInt; var PhysicalType: LongInt; var PhysicalTypestring: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      with FCrossbar[LongInt(Crossbar)] do begin
         if not assigned (F_Crossbar) then Exit;
         if (PinDirection = PINDIR_INPUT) and (FInBound <= Index) then Exit;
         if (PinDirection = PINDIR_OUTPUT) and (FOutBound <= Index) then Exit;
         if F_Crossbar.get_CrossbarPinInfo (PinDirection = PINDIR_INPUT, Index, IndexRelated, PhysicalType) = S_OK then begin
            PhysicalTypestring := GetCrossbarstring (PhysicalType);
            Result := true;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CrossbarCanConnectInput (Crossbar: TCrossbarSelector; InputIndex, OutputIndex: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      with FCrossbar[LongInt(Crossbar)] do begin
         if not assigned (F_Crossbar) then Exit;
         if FInBound <= InputIndex then Exit;
         if FOutBound <= OutputIndex then Exit;
         if F_Crossbar.CanRoute (OutputIndex, InputIndex) = S_OK then begin
            Result := true;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CrossbarConnectInput (Crossbar: TCrossbarSelector; InputIndex, OutputIndex: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      with FCrossbar[LongInt(Crossbar)] do begin
         if not assigned (F_Crossbar) then Exit;
         if FInBound <= InputIndex then Exit;
         if FOutBound <= OutputIndex then Exit;
         if F_Crossbar.Route (OutputIndex, InputIndex) = S_OK then begin
            Result := true;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CrossbarGetInputConnected (Crossbar: TCrossbarSelector; OutputIndex: LongInt; var InputIndex: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      with FCrossbar[LongInt(Crossbar)] do begin
         if not assigned (F_Crossbar) then Exit;
         if FOutBound < OutputIndex then Exit;
         if F_Crossbar.Get_IsRoutedTo (OutputIndex, InputIndex) = S_OK then begin
            Result := true;
         end;
      end;
   end;
end;

const
   TvCommandNotAllowedDuringScan = 'TV commands not allowed during tv auto tuning';

const
   AUTOTUNE_REGKEY = 'AutoTune';

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function AutoTuneKeyName (CountryCode: LongInt; TunerInputType: LongInt): String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
   TVTuningRegistryEntry = '\Software\Microsoft\TV System Services\TVAutoTune\';
begin
   Result := TVTuningRegistryEntry + 'TS' + IntToStr (CountryCode) + '-' + IntToStr (1 - TunerInputType) + '\';
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function OpenAutoTuneRegKey (CountryCode: LongInt; TunerInputType: LongInt; var RegKey: TRegistry2): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   RegKey := nil;
   try
      RegKey := TRegistry2.Create (True);
      Result := RegKey.OpenKey (AutoTuneKeyName (CountryCode, TunerInputType), True);
   finally
      if not Result then begin
         if assigned (RegKey) then begin
            RegKey.Free;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerPutChannel(lChannel, lVideoSubChannel, lAudioSubChannel: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := TVDoSetChannel (lChannel, lVideoSubChannel, lAudioSubChannel);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetChannel(out lChannel, lVideoSubChannel, lAudioSubChannel: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.Get_Channel (lChannel, lVideoSubChannel, lAudioSubChannel) = S_OK;
      LogB (not Result, LWARNING, w_tv_tuner, 'cannot read tv channel');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerChannelMinMax(out lChannelMin, lChannelMax: LongInt): Boolean;
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.ChannelMinMax (lChannelMin, lChannelMax) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerPutCountryCode(lCountryCode: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.put_CountryCode(lCountryCode) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetCountryCode(out lCountryCode: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if not assigned (F_AMTVTuner) then begin
         Result := FVideoRegSave[_IsTVTunerAvail].b;
         if Result then begin
            lCountryCode := FVideoRegSave[_TVCountryCode].i;
         end;
      end
      else begin
         if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
         Result := F_AMTVTuner.get_CountryCode(lCountryCode) = S_OK;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerPutTuningSpace(lTuningSpace: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.put_TuningSpace(lTuningSpace) = S_OK;
      LogB (not Result, LERROR, w_tv_tuner, 'cannot set tv tuning space');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetTuningSpace(out lTuningSpace: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if not assigned (F_AMTVTuner) then begin
         Result := FVideoRegSave[_IsTVTunerAvail].b;
         if Result then begin
            lTuningSpace := FVideoRegSave[_TVTuningSpace].i;
         end;
      end
      else begin
         if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
         Result := F_AMTVTuner.get_TuningSpace(lTuningSpace) = S_OK;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerLogon(hCurrentUser: THandle): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.Logon(hCurrentUser) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerLogout: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.Logout = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerSignalPresent(out plSignalStrength: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.SignalPresent(plSignalStrength) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerPutMode(lMode: dword): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      Result := F_AMTVTuner.put_Mode(lMode) = S_OK;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      LogB (not Result, LERROR, w_tv_tuner, 'cannot set tv mode');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetMode(out plMode: dword): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if not assigned (F_AMTVTuner) then begin
         Result := FVideoRegSave[_IsTVTunerAvail].b;
         if Result then begin
            plMode := FVideoRegSave[_TVMode].i;
         end;
      end
      else begin
         if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
         Result := F_AMTVTuner.get_Mode(PlMode) = S_OK;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetAvailableModes(out plModes: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.GetAvailableModes(plModes) = S_OK;
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetAvailableTVFormats(out lAnalogVideoStandard: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.get_AvailableTVFormats(lAnalogVideoStandard) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetTVFormat(out plAnalogVideoStandard: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if not assigned (F_AMTVTuner) then begin
         Result := FVideoRegSave[_IsTVTunerAvail].b;
         if Result then begin
            plAnalogVideoStandard := FVideoRegSave[_ANVTVFormat].i;
         end;
      end
      else begin
         if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
         Result := F_AMTVTuner.get_TVFormat(plAnalogVideoStandard) = S_OK;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerAutoTune(lChannel: LongInt; out plFoundSignal: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.AutoTune(lChannel, plFoundSignal) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerStoreAutoTune: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.StoreAutoTune = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetNumInputConnections(out plNumInputConnections: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.get_NumInputConnections(plNumInputConnections) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerPutInputType(lIndex: LongInt; InputType: TTunerInputType): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoRegSave[_TVInputType].i := LongInt (InputType);
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.put_InputType(lIndex, LongInt (InputType)) = S_OK;
      LogB (not Result, LERROR, w_tv_tuner, 'cannot set tv input type');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetInputType(lIndex: LongInt; out InputType: TTunerInputType): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if not assigned (F_AMTVTuner) then begin
         Result := FVideoRegSave[_IsTVTunerAvail].b;
         if Result then begin
            InputType := TTunerInputType (FVideoRegSave[_TVInputType].i);
         end;
      end
      else begin
         if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
         Result := F_AMTVTuner.get_InputType(lIndex, LongInt(InputType)) = S_OK;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerPutConnectInput(lIndex: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.put_ConnectInput(lIndex) = S_OK;
      LogB (not Result, LERROR, w_tv_tuner, 'cannot connect tv input');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetConnectInput(out plIndex: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if not assigned (F_AMTVTuner) then begin
         Result := FVideoRegSave[_IsTVTunerAvail].b;
         if Result then begin
            plIndex := FVideoRegSave[_TVConnectInput].i;
         end;
      end
      else begin
         if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
         Result := F_AMTVTuner.get_ConnectInput(plIndex) = S_OK;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetVideoFrequency(out lFreq: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.get_VideoFrequency(lFreq) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AMTVTunerGetAudioFrequency(out lFreq: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then begin Result := false; Exit; end;
      Result := F_AMTVTuner.get_AudioFrequency(lFreq) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetLogoDisplayed: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FLogoDisplayed;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetLogoDisplayed (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FLogoDisplayed = Value then Exit;
      FLogoDisplayed := Value;
      if not FDestroying then Repaint;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetLogoLayout: TLogoLayout;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FLogoLayout;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetLogoLayout (Value: TLogoLayout);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FLogoLayout := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.Display_SetLocation (WindowLeft, WindowTop, WindowWidth, WindowHeight: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideoWindow.SetLocation (WindowLeft, WindowTop, WindowWidth, WindowHeight);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.DualDisplay_SetLocation (WindowLeft, WindowTop, WindowWidth, WindowHeight: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideoWindow2.SetLocation (WindowLeft, WindowTop, WindowWidth, WindowHeight);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VDECPutTVFormat(lAnalogVideoStandard: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMAnalogVideoDecoder) then Exit;
      Result := F_AMAnalogVideoDecoder.put_TVFormat (lAnalogVideoStandard) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VDECGetHorizontalLocked(out plLocked: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMAnalogVideoDecoder) then Exit;
      Result := F_AMAnalogVideoDecoder.get_HorizontalLocked(plLocked) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VDECPutVCRHorizontalLocking(lVCRHorizontalLocking: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMAnalogVideoDecoder) then Exit;
      Result := F_AMAnalogVideoDecoder.put_VCRHorizontalLocking(lVCRHorizontalLocking) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VDECGetVCRHorizontalLocking(out plVCRHorizontalLocking: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMAnalogVideoDecoder) then Exit;
      Result := F_AMAnalogVideoDecoder.get_VCRHorizontalLocking(plVCRHorizontalLocking) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VDECGetNumberOfLines(out plNumberOfLines: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMAnalogVideoDecoder) then Exit;
      Result := F_AMAnalogVideoDecoder.get_NumberOfLines(plNumberOfLines) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VDECPutOutputEnable(lOutputEnable: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMAnalogVideoDecoder) then Exit;
      Result := F_AMAnalogVideoDecoder.put_OutputEnable(lOutputEnable) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VDECGetOutputEnable(out plOutputEnable: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMAnalogVideoDecoder) then Exit;
      Result := F_AMAnalogVideoDecoder.get_OutputEnable(plOutputEnable) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetShapeOverlay: TShape;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FShapeOverlay;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetShapeOverlayEnabled: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FShapeOverlayEnabled;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetShapeOverlayEnabled (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FShapeOverlayEnabled := Value;
      SetNeedFrameOverlayDC;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.ShapeOverlayList (Shape: TShape; Add: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Location: LongInt;
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      Location := FShapeOverlayList.IndexOf (Shape);
      if Add then begin
         if Location = - 1 then begin
            Shape.Visible := False;
            FShapeOverlayList.Add (Shape);
            SetNeedFrameOverlayDC;
            Result := True;
         end
      end
      else begin
         FShapeOverlayList.Delete (Location);
         Result := True;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetShapeOverlay (Value: TShape);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FShapeOverlay := Value;
      if assigned (FShapeOverlay) then begin
         FShapeOverlay.Visible := False;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetTextOverlayEnabled: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTextOverlayEnabled;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetTextOverlayBkColor: TColor;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTextOverlayBkColor;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetTextOverlayAlign: TTextOverlayAlign;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTextOverlayAlign;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetTextOverlayFont: TFont;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTextOverlayFont;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTextOverlayFont (Value: TFont);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if assigned (FTextOverlayFont) then begin
         FTextOverlayFont.Assign(Value);
      end;
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetTextOverlayString: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTextOverlayString;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetTextOverlayLeft: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTextOverlayLeft;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetTextOverlayTop: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTextOverlayTop;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetTextOverlayRight: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTextOverlayRight;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetTextOverlayTransparent: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTextOverlayTransparent;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTextOverlayCustomVar (VarIndex: LongInt; VarText: String);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not VarIndex in [0..MAXCUSTOMVARS] then Exit;
   with TVdgr(_Vdgr) do begin
      FTextOverlayCustomVars[VarIndex] := VarText;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTextOverlaystring (Value: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Done: Boolean;
   i: LongInt;
   InVar: Boolean;
   c: Char;
   SubText, VarName: string;
   iOtherTextData: LongInt;
   cCustomIndex: Char;
   VarOk: Boolean;
begin
 with TVdgr(_Vdgr) do begin
  try

  iOtherTextData := 1 - FTextOverlayDataInUse;
  with FTextOverlayData[iOtherTextData] do begin
   if Processing then Exit;
   if Assigning then Exit;
   Assigning := True;

   FTextOverlaystring := Value;
   iStack:= 0;

   SubText := '';
   VarName := '';
   InVar := false;
   i := 1;
   Done := false;
   while not Done do begin
      if i > length (FTextOverlaystring) then begin
         Done := true;
      end
      else begin
         c := FTextOverlaystring[i];
         if c = '%' then begin
            if InVar then begin
               TextStack[iStack] := '';
               VarOk := False;
               if VarName = 'time_code' then begin
                  VarStack[iStack] := ptTimeCode;
                  VarOk := True;
               end
               else if VarName = 'frame_count' then begin
                  VarStack[iStack] := ptCurrentFrameNumber;
                  VarOk := True;
               end
               else if VarName = 'time_full' then begin
                  VarStack[iStack] := ptFullTime;
                  VarOk := True;
               end
               else if VarName = 'time_100ns' then begin
                  VarStack[iStack] := ptTime100Ns;
                  VarOk := True;
               end
               else if VarName = 'time_sec' then begin
                  VarStack[iStack] := ptTimeSec;
                  VarOk := True;
               end
               else if Copy (VarName, 1, 9) = 'sys_time[' then begin
                  VarStack[iStack] := ptSysTime;
                  TextStack[iStack] := Copy (VarName, 10, length(VarName) - 10);
                  VarOk := True;
               end
               else if Copy (VarName, 1, 8) = 'dv_time[' then begin
                  VarStack[iStack] := ptDVTime;
                  TextStack[iStack] := Copy (VarName, 9, length(VarName) - 9);
                  VarOk := True;
               end
               else if Copy (VarName, 1, 6) = 'custom' then begin
                  if length(VarName) = 7 then begin
                     cCustomIndex := VarName[7];
                     if cCustomIndex in ['0'..'9'] then begin
                        VarStack[iStack] := TVarParseText (Ord (ptCustom0) + (Ord(cCustomIndex) - Ord('0')));
                        VarOk := True;
                     end;
                  end;
               end;
               if not VarOk then begin
                  VarStack[iStack] := ptNone;
                  TextStack[iStack] := '%' + VarName + '%';
               end;
               VarName := '';
            end
            else begin
               TextStack[iStack] := SubText;
               SubText := '';
               VarStack[iStack] := ptNone;
            end;
            inc (iStack);
            if iStack = MAXSTACKARRAY then begin
               Done := true;
            end;
            Invar := not InVar;
         end
         else begin
            if InVar then begin
               VarName := VarName + c;
            end
            else begin
               SubText := SubText + c;
            end;
         end;
         inc (i);
      end;
   end;
   if not InVar then begin
      if SubText <> '' then begin
         TextStack[iStack] := SubText;
         VarStack[iStack] := ptNone;
         inc (iStack);
      end;
   end;
   Assigning := False;
   FTextOverlayDataInUse := iOtherTextData;
  end;
  finally
  end;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTextOverlayEnabled (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FTextOverlayEnabled := Value;
      SetNeedFrameOverlayDC;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTextOverlayLeft (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FTextOverlayLeft := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTextOverlayTop (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FTextOverlayTop := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTextOverlayRight (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FTextOverlayRight := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTextOverlayTransparent (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FTextOverlayTransparent := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTextOverlayBkColor (Value: TColor);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FTextOverlayBkColor := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTextOverlayAlign (Value: TTextOverlayAlign);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if (Value < Low (TTextOverlayAlign)) or (Value > High(TTextOverlayAlign)) then Exit;
      FTextOverlayAlign := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetColorKeyEnabled (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FColorKeyEnabled then Exit;
      FColorKeyEnabled := Value;
      RefreshPreview ('scke');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetStoragePath (Value: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FStoragePath_DoUpdate := False;
      FStoragePath := Value;
      FStoragePath_DoUpdate := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TDisplayForm.WMPAINT (var Message: TWMPAINT);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   inherited;
   with TVdgr(TVGOwner) do begin
      RepaintVideo (AssociatedRenderer);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TDisplayForm.WMSIZE (var Message: TWMSIZE);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   inherited;
   with TVdgr(TVGOwner) do begin
      ResizeVideoWindows (False);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
destructor TDisplayForm.Destroy;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   WindowProc := FOldWndProc;
   inherited Destroy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TDisplayForm.NewWndProc (var Message: TMessage);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FOldWndProc (Message);
   if Message.Msg = WM_WINDOWPOSCHANGING then begin
      with TVdgr(TVGOwner) do begin
         if not FDestroying then begin
            RepaintVideo (@FVideoRendererW);
            RepaintVideo (@FVideoRendererW2);
            RepaintVideo (@FOverlayRendererW);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetParentWindow: HWnd;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := inherited ParentWindow;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetParentWindow(Value: HWnd);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if IsInDesignMode then begin
      inherited ParentWindow := Value;
   end
   else begin
      if not assigned (_Vdgr) then begin
         inherited ParentWindow := Value;
      end
      else begin
         with TVdgr(_Vdgr) do begin
            if FDestroying then begin
               inherited ParentWindow := Value;
            end
            else begin
               ChangeDisplayParent (FVideoWindow.FAssociatedRenderer, True);
               ChangeDisplayParent (FVideoWindow2.FAssociatedRenderer, True);
               if IsWindow (Value) then begin
                  if assigned (Parent) and (Parent = _SyncManager.FSyncGlobalMessages) then begin
                     inherited SetParent (nil);
                  end;
                  inherited ParentWindow := Value;
               end
               else begin
                  Value := 0;
                  inherited ParentWindow := Value;
                  inherited SetParent (_SyncManager.FSyncGlobalMessages);
               end;
               AssociateVideoWindows;
               ShowDisplays;
            end;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetParent(AParent: TWinControl);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if IsInDesignMode then begin
      inherited SetParent (AParent);
   end
   else begin
      if not assigned (_Vdgr) then begin
         inherited SetParent (AParent);
      end
      else begin
         with TVdgr(_Vdgr) do begin
            if FDestroying then begin
               inherited SetParent (AParent);
            end
            else begin
               ChangeDisplayParent (FVideoWindow.FAssociatedRenderer, True);
               ChangeDisplayParent (FVideoWindow2.FAssociatedRenderer, True);

               if (not assigned (AParent)) and (ParentWindow = 0) then begin
                  AParent := _SyncManager.FSyncGlobalMessages;
               end;
               inherited SetParent (AParent);
               AssociateVideoWindows;
               ShowDisplays;
            end;
         end;
      end;
   end;
end;

(*
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TDisplayForm.DestroyWindowHandle;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   TVdgr(TVGOwner).FDestroying := True;
   inherited;
end;
*)

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.Notification(AComponent: TComponent; Operation: TOperation);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
begin
   if _VdgrInitialized then begin
      if Operation = opRemove then begin
         with TVdgr (_Vdgr) do begin
            if AComponent.ClassName = 'TJxdVideoGrabber' then begin
               for i := MULTIPLEXEDSLAVE_MINBOUND to MULTIPLEXEDSLAVE_MAXBOUND do begin
                  if assigned (FMultiplexedSlave[i].Vdgr) then begin
                     if AComponent = FMultiplexedSlave[i].Vdgr.Intf then begin
                        FMultiplexedSlave[i].Vdgr := nil;
                     end;
                  end;
               end;

               if assigned (FMultiplexedMaster.Vdgr) then begin
                  if AComponent = FMultiplexedMaster.Vdgr.Intf then begin
                     FMultiplexedMaster.Vdgr := nil;
                  end;
               end;
            end;

            if assigned (FPropertyPageSaver) then begin
               if AComponent = TComponent(FPropertyPageSaver) then begin
                  FPropertyPageSaver.FAssociated := nil;
                  FPropertyPageSaver := nil;
               end;
            end;
         end;
      end;
   end;
   inherited;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.WMERASEBKGND (var Message: TWMERASEBKGND);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if IsWindowEmbedded (FVideoWindow) or IsWindowEmbedded (FVideoWindow2) then begin
         if FFilterState <> State_Stopped then begin
            Message.Result := 0;
         end
         else begin
            inherited;
         end;
      end
      else begin
         inherited;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.WndProc(var Msg: TMessage);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if Msg.Msg = WM_NOTIFYWINDOW then begin
      with TVdgr(_Vdgr) do begin
         ProcessGraphNotify;
      end;
      Msg.Result := 0;
   end
   else begin
      inherited;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetSampleCapture_Audio: TSampleCapture;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FSampleCapture_Audio;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetSampleCapture_Video: TSampleCapture;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FSampleCapture_Video;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetSampleCapture_Audio (Value: TSampleCapture);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < Low(TSampleCapture)) or (Value > High(TSampleCapture)) then Exit;
   with TVdgr(_Vdgr) do FSampleCapture_Audio := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetSampleCapture_Video (Value: TSampleCapture);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < Low(TSampleCapture)) or (Value > High(TSampleCapture)) then Exit;
   with TVdgr(_Vdgr) do FSampleCapture_Video := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CaptureFrameSyncTo (Dest: TFrameCaptureDest; FileName: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := CaptureFrameTo (Dest, FileName);
      if Result then begin
         if not FCurrentFrameData.OneShotSampleAvailable then begin
            FCurrentFrameData.OneShotCaptureSuccess := False;
            FCurrentFrameData.OneShotCaptureWaiting := True;
            while FCurrentFrameData.OneShotCaptureWaiting do begin
               FlushMessages;
               Sleep (1);
            end;
            Result := FCurrentFrameData.OneShotCaptureSuccess;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CaptureFrameTo (Dest: TFrameCaptureDest; FileName: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ called to get 1 or more .BMP file, .JPEG file or memory bitmap
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
    with TVdgr(_Vdgr) do begin
       Result := false;
       if FCurrent.FrameGrabber = fg_Disabled then Exit;
       if not FGraphAccessAllowed then Exit;
       if FCurrentFrameData.ReturnOneShotFrame then Exit;

       FCurrentFrameData.OneShotDest := Dest;
       FCurrentFrameData.OneShotFileName := FileName;

       if FFilterState = state_Paused then begin
          DoGrabFrame (FCurrentFrameData.OneShotDest, FCurrentFrameData.OneShotFileName, true, True);
       end
       else begin
          FCurrentFrameData.ReturnOneShotFrame := True;
       end;

       Result := True;
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.DrawBitmapOverFrame (Bitmap: Graphics.TBitmap; LeftLocation: LongInt; TopLocation: LongInt; bmWidth: LongInt; bmHeight: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   CompatibleDc: HDC;
   OldBitmap: HBitmap;
begin
   Result := False;
   if not assigned (Bitmap) then Exit;
   with TVdgr(Self._Vdgr) do begin
      with FCurrentFrameData do begin
         if not DrawingOverFrames then Exit;

         CompatibleDc := CreateCompatibleDc (DrawingOverFramesDxDc);
         OldBitmap := SelectObject (CompatibleDc, Bitmap.Handle);
         if (bmWidth = Bitmap.Width) and (bmHeight = Bitmap.Height) then begin
            Result := BitBlt (DrawingOverFramesDxDc, LeftLocation, TopLocation, bmWidth, bmHeight, CompatibleDc, 0, 0, SRCCOPY);
         end
         else begin
            Result := StretchBlt (DrawingOverFramesDxDc, LeftLocation, TopLocation, bmWidth, bmHeight, CompatibleDc, 0, 0, Bitmap.Width, Bitmap.Height, SRCCOPY);
         end;
         SelectObject (CompatibleDc, OldBitmap);
         DeleteDC (CompatibleDc);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVersion: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := TVideoGrabberVersion;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVersion (Value: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetOnFrameOverlayUsingDC (Value: TOnFrameOverlayUsingDC);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FOnFrameOverlayUsingDC := Value;
      SetNeedFrameOverlayDC;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPlayerDVSize (Value: TDVSize);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if (Value < Low(TDVSize)) or (Value > High(TDVSize)) then Exit;
      FPlayerDVSize := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetColorKeys (LowestRGBColorValue: TColor; HighestRGBColorValue: TColor);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FColorKeyLow := LowestRGBColorValue;
      FColorKeyHigh := HighestRGBColorValue;
      FColorKeysDefault := False;
      ProcessOverlayColorKey;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsVideoPortAvailable: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoRegSave[_IsVideoPortAvailable].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsVideoInterlaced: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoRegSave[_IsVideoInterlaced].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsAnalogVideoDecoderAvailable: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FVideoRegSave[_IsAnalogVideoDecoderAvail].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsDVCommandAvailAvailable: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FVideoRegSave[_ExtTransportAvail].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsDigitalVideoIn: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := IsDVSource;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsVideoControlAvailable: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FVideoRegSave[_IsVideoControlAvail].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsAudioCrossbarAvailable: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FVideoRegSave[_IsAudioCrossbarAvail].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsAudioDeviceASoundCard: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FAudioRegSave[_AIsSoundCard].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsAudioInputBalanceAvailable: TTriState;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FIsAudioInputBalanceAvailable;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsPlayerAudioStreamAvailable: TTriState;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FIsPlayerAudioStreamAvailable;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsPlayerPaused: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
     with TVdgr(_Vdgr) do Result := (FGraphType = cs_Playback) and (FFilterState = state_Paused) and (not Intf.GetIsPlayerPlaying);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsPlayerPlaying: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
     with TVdgr(_Vdgr) do Result := (FGraphType = cs_Playback) and
     (
        (FFilterState = state_Running)
        or
        (
        (FFilterState = state_Paused) and (FPlayerBackwardTimerEnabled or FCurrentFrameData.PlayerEmulateSpeedRatio)
        )
     );
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsRecordingPaused: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FIsRecordingPaused;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsVideoCrossbarAvailable: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FVideoRegSave[_IsVideoCrossbarAvail].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsTVTunerAvailable: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FVideoRegSave[_IsTVTunerAvail].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsTVAudioAvailable: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FVideoRegSave[_IsTVAudioAvail].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsTVAutoTuneRunning: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FIsTVAutoTuneRunning;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerAudioCodec: String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPlayerAudioCodec;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerVideoCodec: String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPlayerVideoCodec;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerForcedCodec: String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPlayerForcedCodec;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPlayerForcedCodec (Value: String);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FPlayerForcedCodec := trim(Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerRefreshPausedDisplay: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPlayerRefreshPausedDisplay;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPlayerRefreshPausedDisplay (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FPlayerRefreshPausedDisplay := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerFastSeekSpeedRatio: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPlayerFastSeekSpeedRatio;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerFileName: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FPlayerFileName;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPlayerFastSeekSpeedRatio (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value < 1 then Exit;
      FPlayerFastSeekSpeedRatio := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPlayerFileName (Value: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value <> FPlayerFileName then begin
         FPlayerFileName := Value;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPlayerAudioRendering (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FPlayerAudioRendering then Exit;
      FPlayerAudioRendering := Value;
      Allow ([cs_Down, cs_Preview, cs_Recording], LWARNING, True);
      LogB ((FPlayerSpeedRatio <> 1) and (((FGraphType <> cs_Playback) and FPlayerAudioRendering) or ((FGraphType = cs_Playback) and FCurrent.PlayerAudioRendering)), LWARNING, w_player_audio_should_be_disabled, 'disable PlayerAudioRendering if the clip freezes when speed ratio < 1');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetBorderStyle (Value: TBorderStyle);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if IsInDesignMode then begin
         inherited BorderStyle := Value;
         FBorderStyle:= inherited BorderStyle;
      end
      else begin
         if (Value < Low (TBorderStyle)) or (Value > High(TBorderStyle)) then Exit;
         FBorderStyle := Value;

         ChangeDisplayParent (FVideoWindow.FAssociatedRenderer, True);
         ChangeDisplayParent (FVideoWindow2.FAssociatedRenderer, True);

         inherited BorderStyle := Value;
         if BorderStyle = bsSingle then begin
            FBorderThickness := GetSystemMetrics (SM_CXEDGE) shl 1;
         end
         else begin
            FBorderThickness := 0;
         end;

         AssociateVideoWindows;
         ResizeVideoWindows (True);
         ShowDisplays;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetBurstMode (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the Burst mode value of the sample grabber
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value then begin
         FCurrent.BurstCount := FBurstCount;
         FCurrent.BurstInterval := 0;
      end;
      FBurstMode := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetBurstType (Value: TFrameCaptureDest);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the Burst Type value of the sample grabber
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < Low (TFrameCaptureDest)) or (Value > High(TFrameCaptureDest)) then Exit;
   with TVdgr(_Vdgr) do FBurstType := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetDVRgb219: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FDVRgb219;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetDVRgb219 (value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FDVRgb219 := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDVReduceFrameRate: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FDVReduceFrameRate;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetEventNotificationSynchrone: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FEventNotificationSynchrone;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetFrameCaptureWithoutOverlay: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FFrameCaptureWithoutOverlay;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetFrameCaptureZoomSize: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FFrameCaptureZoomSize;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetFrameCaptureZoomSize (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FFrameCaptureZoomSize := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetEventNotificationSynchrone (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FEventNotificationSynchrone := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetPreallocCapFileEnabled: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPreallocCapFileEnabled;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPreallocCapFileEnabled (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FPreallocCapFileEnabled := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetPreallocCapFileCopiedAfterRecording: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPreallocCapFileCopiedAfterRecording;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPreallocCapFileCopiedAfterRecording (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FPreallocCapFileCopiedAfterRecording := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPreallocCapFileName: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FPreallocCapFileName;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPreallocCapFileName (Value: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do if Value <> FPreallocCapFileName then FPreallocCapFileName := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetPreallocCapFileSizeInMB: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPreallocCapFileSizeInMB;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPreallocCapFileSizeInMB (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value < 1 then Exit;
      FPreallocCapFileSizeInMB := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetPreviewZoomSize: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPreviewZoomSize;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetRecordingFileName: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FRecordingFileName;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetRecordingFourCC: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := ReturnFourCc (GUIDToString (FRecordingSubtype));
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetRecordingMethod: TRecordingMethod;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FRecordingMethod;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetRecordingInNativeFormat: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FRecordingInNativeFormat;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetRecordingCanPause: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FRecordingCanPause;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetRecordingDuration: Double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FRecordingDuration / REFTIME_UNITS;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetBurstCount (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the Burst count value of the sample grabber
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value < 0 then Exit;
      FBurstCount := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetBurstInterval (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the Burst interval value of the sample grabber
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value < 0 then Exit;
      FBurstInterval := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetBusyCursor (Value: TCursor);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FBusyCursor := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetBackgroundColor (Value: TColor);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FBackgroundColor := Value;
      if assigned (FVideoRendererW.Display) then begin
         FVideoRendererW.Display.Color := Value;
      end;
      if assigned (FVideoRendererW2.Display) then begin
         FVideoRendererW2.Display.Color := Value;
      end;
      if assigned (FOverlayRendererW.Display) then begin
         FOverlayRendererW.Display.Color := Value;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPropertyPageSaver: TComponent;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FPropertyPageSaver;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPropertyPageSaver (Value: TComponent);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FPropertyPageSaver then Exit;
      if not assigned (Value) then begin
         FPropertyPageSaver := nil;
      end
      else begin
         if Copy (Value.ClassName, 1, 18) = 'TPropertyPageSaver' then begin
            FPropertyPageSaver := TPropertyPageSaverBase (Value);
            FPropertyPageSaver.FAssociated := Self;
         end
         else begin
            FPropertyPageSaver := nil;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetLast_BurstFrameCapture_FileName: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FLast_BurstFrameCapture_FileName;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetLast_CaptureFrameTo_FileName: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FLast_CaptureFrameTo_FileName;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetLast_Clip_Played: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FGlobalRegSave[_LastClipPlayed].s;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetLast_Recording_FileName: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do begin
         if FGraphType = cs_Recording then begin
            Result := FRealRecordingFileName;
         end
         else begin
            Result := FGlobalRegSave[_LastRecordingFileName].s;
         end;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetRecordingCanPause (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FRecordingCanPause = Value then Exit;
      FRecordingCanPause := Value;
      LogB (FRecordingStarted and (FRecordingCanPause <> FCurrent.RecordingCanPause), LWARNING, e_graph_must_be_restarted, 'Recording needs to be restarted');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetRecordingInNativeFormat (value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FRecordingInNativeFormat := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetRecordingMethod (Value: TRecordingMethod);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FRecordingMethod = Value then Exit;
      FRecordingMethod := Value;
      LogB (FRecordingStarted, LWARNING, e_graph_must_be_restarted, 'Recording needs to be restarted');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetReencodingNewVideoClip: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FReencodingSettings.NewVideoClip;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetReencodingSourceVideoClip: String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FReencodingSettings.SourceVideoClip;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetReencodingStartTime: int_64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FReencodingSettings.StartTime;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetReencodingStopTime: int_64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FReencodingSettings.StopTime;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetReencodingIncludeAudioStream: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FReencodingSettings.IncludeAudioStream;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetReencodingIncludeVideoStream: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FReencodingSettings.IncludeVideoStream;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetReencodingUseAudioCompressor: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FReencodingSettings.UseAudioCompressor;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetReencodingUseFrameGrabber: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FReencodingSettings.UseFrameGrabber;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetReencodingUseVideoCompressor: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FReencodingSettings.UseVideoCompressor;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetReencodingMethod: TRecordingMethod;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FReencodingSettings.Method;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetReencodingWMVOutput: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FReencodingSettings.WMVOutput;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetReencodingWMVOutput (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FReencodingSettings.WMVOutput := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetReencodingMethod (Value: TRecordingMethod);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FReencodingSettings.Method  := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetReencodingNewVideoClip (Value:  string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FReencodingSettings.NewVideoClip  := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetReencodingSourceVideoClip (Value:  String);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FReencodingSettings.SourceVideoClip   := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetReencodingStartTime (Value:  int_64);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FReencodingSettings.StartTime  := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetReencodingStopTime (Value:  int_64);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FReencodingSettings.StopTime  := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetReencodingIncludeAudioStream (Value:  Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FReencodingSettings.IncludeAudioStream  := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetReencodingIncludeVideoStream (Value:  Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FReencodingSettings.IncludeVideoStream  := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetReencodingUseAudioCompressor (Value:  Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FReencodingSettings.UseAudioCompressor  := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetReencodingUseFrameGrabber (Value:  Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FReencodingSettings.UseFrameGrabber  := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetReencodingUseVideoCompressor (Value:  Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FReencodingSettings.UseVideoCompressor  := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetSampleCaptureAsyncEvent: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FSampleCaptureAsyncEvent;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetSampleCaptureAsyncEvent (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FSampleCaptureAsyncEvent := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetFrameGrabber: TFrameGrabber;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FFrameGrabber;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetFrameGrabberSynchrone: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FFrameGrabberSynchrone;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetHoldRecording: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FHoldRecording;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetHoldRecording (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FHoldRecording := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetFrameCaptureWithoutOverlay (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FFrameCaptureWithoutOverlay = Value then Exit;
      FFrameCaptureWithoutOverlay := Value;
      RefreshPreview ('sfwo');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetJPEGPerformance: TJPEGPerformance;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FJPEGPerformance;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetJPEGProgressiveDisplay: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FJPEGProgressiveDisplay;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetJPEGQuality: TJPEGQualityRange;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FJPEGQuality;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetJPEGPerformance (Value: TJPEGPerformance);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < Low(TJPEGPerformance)) or (Value > High(TJPEGPerformance)) then Exit;
   with TVdgr(_Vdgr) do FJPEGPerformance := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetJPEGProgressiveDisplay (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FJPEGProgressiveDisplay := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetJPEGQuality (Value: TJPEGQualityRange);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < Low(TJPEGQualityRange)) or (Value > High(TJPEGQualityRange)) then Exit;
   with TVdgr(_Vdgr) do FJPEGQuality := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetFrameGrabber (Value: TFrameGrabber);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if (Value < Low(TFrameGrabber)) or (Value > High(TFrameGrabber)) then Exit;
      if Value = FFrameGrabber then Exit;
      FFrameGrabber := Value;
      RefreshPreview ('dsfg');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetFrameBuffers (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value < 0 then Exit;
      if Value > 10 then Exit;
      FFrameBuffers := Value;
      RefreshPreview ('dsfg');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetFrameGrabberRGBFormat (Value: TFrameGrabberRGBFormat);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if (Value < Low(TFrameGrabberRGBFormat)) or (Value > High(TFrameGrabberRGBFormat)) then Exit;
      if Value = FFrameGrabberRGBFormat then Exit;
      FFrameGrabberRGBFormat := Value;
      if FFrameGrabber <> fg_Disabled then begin
         RefreshPreview ('dsfgf');
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetFrameGrabberSynchrone (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FFrameGrabberSynchrone := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoProcessingBrightness: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoEffects.Brightness;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoProcessingContrast: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoEffects.Contrast;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoProcessingSaturation: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoEffects.Saturation;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoProcessingHue: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoEffects.Hue;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoProcessingGrayScale: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoEffects.GrayScale;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoProcessingLeftRight: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoEffects.LeftRight;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoProcessingTopDown: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoEffects.TopDown;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoProcessingInvertColors: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoEffects.InvertColors;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetVideoProcessingRotation: TVideoRotation;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FTransformConfig.VideoRotation;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoProcessingRotation (Value: TVideoRotation);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if value <> FTransformConfig.VideoRotation then begin
         FTransformConfig.VideoRotation := Value;
         FTransformConfig.VideoRotation_90_or_270 := FTransformConfig.VideoRotation in [rt_90_deg, rt_90_deg_mirror, rt_270_deg, rt_270_deg_mirror];
         EnableDisableVideoTransform;
         RefreshPreview ('spr');
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CameraControlMin (Setting: TCameraControl): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FCameraControl[Setting].Min;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CameraControlMax (Setting: TCameraControl): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FCameraControl[Setting].Max;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CameraControlStep (Setting: TCameraControl): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FCameraControl[Setting].SteppingDelta;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CameraControlDefault (Setting: TCameraControl): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FCameraControl[Setting].Default_;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetCaptureFileExt: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FCaptureFileExt;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetColorKeyEnabled: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FColorKeyEnabled;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetUniqueID: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FUniqueID;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function CheckUniqueID (CurrentVdgr: TVdgr): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Vdgr: TVdgr;
   iNext: LongInt;
   Msg: String;
begin
   Result := True;
   if not assigned (_SyncManager) then Exit;
   Vdgr := _SyncManager.FVideoGrabberList.First (iNext);
   while assigned (Vdgr) do begin
      if CurrentVdgr <> Vdgr  then begin
         if CurrentVdgr.FUniqueID = Vdgr.FUniqueID then begin
            Msg := 'duplicated TVideoGrabber "UniqueID" property: ' + IntToStr (CurrentVdgr.FUniqueID);
            MessageBox (0, Pchar(Msg), '', 0);
            Result := False;
         end;
      end;
      Vdgr := _SyncManager.FVideoGrabberList.Next (iNext);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetUniqueID (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FUniqueID := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetCompressionMode: TCompressionMode;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FCompressionMode;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetCompressionMode (Value: TCompressionMode);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < Low(TCompressionMode)) or (Value > High(TCompressionMode)) then Exit;
   with TVdgr(_Vdgr) do FCompressionMode := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetCompressionType: TCompressionType;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FCompressionType;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetCompressionType (Value: TCompressionType);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < Low(TCompressionType)) or (Value > High(TCompressionType)) then Exit;
   with TVdgr(_Vdgr) do FCompressionType := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetCameraControl (Setting: TCameraControl): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FCameraControl[Setting].Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetCameraControlSettings: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FCameraControlSettings;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetCameraControlAuto: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoRegSave[_CameraControl_Auto].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetCameraControlAuto (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FVideoRegSave[_CameraControl_Auto].b = Value then Exit;
      FVideoRegSave[_CameraControl_Auto].b := Value;
      RestoreCameraControlSettingsFromRegistry;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetCameraControlSettings (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FCameraControlSettings := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.SetCameraControl (Setting: TCameraControl; NewValue: LongInt) : Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      if (Setting < Low(TCameraControl)) or (Setting > High(TCameraControl)) then Exit;
      with FCameraControl[Setting] do begin
         if not Available then Exit;
         if NewValue < Min then Exit;
         if NewValue > Max then Exit;
         Value := NewValue;
         Result := True;
         if assigned (F_AMCameraControl) then begin
            F_AMCameraControl.Set_ (LongInt (Setting), Value, AM_Flags_Manual);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.IsCameraControlSettingAvailable (Setting: TCameraControl): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FCameraControl[Setting].Available;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.IsVideoControlModeAvailable (Mode: TVideoControl): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      case Mode of
         vc_FlipHorizontal          : Result := FVideoRegSave[_VideoControlCaps].i and VideoControlFlag_FlipHorizontal > 0;
         vc_FlipVertical            : Result := FVideoRegSave[_VideoControlCaps].i and VideoControlFlag_FlipVertical > 0;
         vc_ExternalTriggerEnable   : Result := FVideoRegSave[_VideoControlCaps].i and VideoControlFlag_ExternalTriggerEnable > 0;
         vc_Trigger                 : Result := FVideoRegSave[_VideoControlCaps].i and VideoControlFlag_Trigger > 0;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.SetVideoControlMode (Mode: TVideoControlSet): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not FVideoControlSettings then Exit;
      if not FVideoRegSave[_IsVideoControlAvail].b then Exit;

      FVideoRegSave[_VideoControlMode].i := 0;
      if vc_FlipHorizontal in Mode then begin
         FVideoRegSave[_VideoControlMode].i := FVideoRegSave[_VideoControlMode].i or VideoControlFlag_FlipHorizontal;
      end;
      if vc_FlipVertical in Mode then begin
         FVideoRegSave[_VideoControlMode].i := FVideoRegSave[_VideoControlMode].i or VideoControlFlag_FlipVertical;
      end;
      if vc_ExternalTriggerEnable in Mode then begin
         FVideoRegSave[_VideoControlMode].i := FVideoRegSave[_VideoControlMode].i or VideoControlFlag_ExternalTriggerEnable;
      end;
      if vc_Trigger in Mode then begin
         FVideoRegSave[_VideoControlMode].i := FVideoRegSave[_VideoControlMode].i or VideoControlFlag_Trigger;
      end;

      ApplyVideoControlMode;

      Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsMpegStream: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := isMPEGSource;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsWDMVideoDriver: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      if InitializationStatus <> ipInitialized then Exit;
      if FCurrent.VideoDevice < 0 then Exit;
      if FCurrent.VideoDevice >= _VideoDevices.Count then Exit;
      Result := TCapDeviceInfo(_VideoDevices.FDevices.Objects[FCurrent.VideoDevice]).WDM;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMpegStreamType: TMpegStreamType;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FMpegStreamType;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMpegStreamType (Value: TMpegStreamType);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FMpegStreamType := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoInput: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FVideoRegSave[_VideoInput].i;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAVIFormatOpenDML: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAVIFormatOpenDML;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetBackgroundColor: TColor;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FBackgroundColor;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAVIFormatOpenDML (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FAVIFormatOpenDML := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetBorderStyle: TBorderStyle;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do  Result := FBorderStyle;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetBurstCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FBurstCount;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetBurstInterval: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FBurstInterval;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetBurstMode: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FBurstMode;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetBurstType: TFrameCaptureDest;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ gets the Burst Type value of the sample grabber
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FBurstType;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetBusy: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FBusy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetBusyCursor: TCursor;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FBusyCursor;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAudioCompressor: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAudioCompressor;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAudioInput: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if CanAssociateAudioAndVideoDevices then begin
         Result := FVideoRegSave[_AudioInputAssociated].i;
      end
      else begin
         Result := FAudioRegSave[_AudioInput].i;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAudioInput (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   ValueChanged: Boolean;
begin
   if Value < 0 then Exit;
   with TVdgr(_Vdgr) do begin
      if CanAssociateAudioAndVideoDevices then begin
         ValueChanged := FVideoRegSave[_AudioInputAssociated].i <> Value;
         FVideoRegSave[_AudioInputAssociated].i := Value;
      end
      else begin
         ValueChanged := FAudioRegSave[_AudioInput].i <> Value;
         FAudioRegSave[_AudioInput].i := Value;
      end;
      ActivateAudioInputAndSetValues;
      if ValueChanged then begin
         if CanInvokeEventWithoutHandle (TPObj(Intf.FOnAudioDeviceSelected)) then Intf.FOnAudioDeviceSelected (Intf);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoInput (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   ValueChanged: Boolean;
begin
   with TVdgr(_Vdgr) do begin
      if LogB (Value < 0, LERROR, e_index_out_of_range, 'Video input index out of range') then Exit;
      if LogB (Value > Intf.GetVideoInputsCount, LERROR, e_index_out_of_range, 'Video input index out of range') then Exit;
      ValueChanged := FVideoRegSave[_VideoInput].i <> Value;
      FVideoRegSave[_VideoInput].i := Value;
      FVideoRegSave[_VideoInputName].s := ReturnItemFromTextList (FVideoRegSave[_VideoInputs].s, FVideoRegSave[_VideoInput].i);
      PerformSetVideoInput (Value);
      if ValueChanged then begin
         if CanInvokeEventWithoutHandle (TPObj(Intf.FOnVideoDeviceSelected)) then Intf.FOnVideoDeviceSelected (Intf);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoSize (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video size
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   w, h: LongInt;
   ValueChanged: Boolean;
begin
   with TVdgr(_Vdgr) do begin
      if Value < 0 then Exit;
      if Value >= FVideoSizes.Count then Exit;
      ValueChanged := FVideoRegSave[_VideoSize].i <> Value;
      FVideoRegSave[_VideoSize].i := Value;
      if FGraphType = cs_Down then begin
         if DecodeVideoSizeUsingDefault (-1, w, h) then begin
            FVideoSourceWidth := w;
            FVideoSourceHeight := h;
            ResizeVideoWindows (True);
         end;
      end;
      LogB ((FPreferredVideoWidth > 0) and (FPreferredVideoHeight > 0), LWARNING, w_using_nearest_video_size, 'disable nearest video size first (currently set to ' + inttostr (FPreferredVideoWidth) + 'x' + inttostr (FPreferredVideoHeight) + ')');
      if ValueChanged then begin
         if CanInvokeEventWithoutHandle (TPObj(Intf.FOnVideoDeviceSelected)) then Intf.FOnVideoDeviceSelected (Intf);
      end;
      RefreshPreview ('dsvsz');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoSubtype (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video Subtype
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   ValueChanged: Boolean;
begin
   with TVdgr(_Vdgr) do begin
      if Value < 0 then Exit;
      if Value >= FVideoSubtypes.Count then Exit;
      ValueChanged := FVideoRegSave[_VideoSubtype].i <> Value;
      FVideoRegSave[_VideoSubtype].i := Value;
      if ValueChanged then begin
         if CanInvokeEventWithoutHandle (TPObj(Intf.FOnVideoDeviceSelected)) then Intf.FOnVideoDeviceSelected (Intf);
      end;
      RefreshPreview ('dsvsty');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAudioInputLevel (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if LogB (Value < 0, LERROR, e_value_out_of_range, 'Audio level value out of range') then Exit;
      if LogB (Value > 65535, LERROR, e_value_out_of_range, 'Audio level value out of range') then Exit;
      if CanAssociateAudioAndVideoDevices then begin
         FVideoRegSave[_AudioInputLevelAssociated].i := Value;
      end
      else begin
         FAudioRegSave[_AudioInputLevel].i := Value;
      end;
      SetAudioInputValues;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAudioInputBalance (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if LogB (Value < -32768, LERROR, e_value_out_of_range, 'Audio Balance value out of range') then Exit;
      if LogB (Value > 32767, LERROR, e_value_out_of_range, 'Audio Balance value out of range') then Exit;
      if CanAssociateAudioAndVideoDevices then begin
         FVideoRegSave[_AudioInputBalanceAssociated].i := Value;
      end
      else begin
         FAudioRegSave[_AudioInputBalance].i := Value;
      end;
      SetAudioInputValues;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAudioInputMono (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if CanAssociateAudioAndVideoDevices then begin
         FVideoRegSave[_AudioInputMonoAssociated].b := Value;
      end
      else begin
         FAudioRegSave[_AudioInputMono].b := Value;
      end;
      SetAudioInputValues;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAudioInputLevel: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if CanAssociateAudioAndVideoDevices then begin
         Result := FVideoRegSave[_AudioInputLevelAssociated].i;
      end
      else begin
         Result := FAudioRegSave[_AudioInputLevel].i;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAudioInputBalance: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if CanAssociateAudioAndVideoDevices then begin
         Result := FVideoRegSave[_AudioInputBalanceAssociated].i;
      end
      else begin
         Result := FAudioRegSave[_AudioInputBalance].i;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAudioInputMono: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if CanAssociateAudioAndVideoDevices then begin
         Result := FVideoRegSave[_AudioInputMonoAssociated].b;
      end
      else begin
         Result := FAudioRegSave[_AudioInputMono].b;
      end;
   end;
end;

(*
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TVideoGrabber.GetShowDialogs: TDialogs;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FShowDialogs;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVideoGrabber.SetShowDialogs (Value: TDialogs);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FShowDialogs := Value;
end;
*)

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetSpeakerControl: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FSpeakerControl;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetSynchronized: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FSynchronized;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetSynchronized (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FSynchronized := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetTranslateMouseCoordinates: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTranslateMouseCoordinates;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTranslateMouseCoordinates (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FTranslateMouseCoordinates := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetStoragePath: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FStoragePath;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetStoreDeviceSettingsInRegistry: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FStoreDeviceSettingsInRegistry;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetStoreDeviceSettingsInRegistry (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FStoreDeviceSettingsInRegistry := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetSpeakerControl (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FSpeakerControl = Value then Exit;
      FSpeakerControl := Value;
      Allow ([cs_Down], LWARNING, False);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetSpeakerBalance: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if CanAssociateAudioAndVideoDevices then begin
         Result := FVideoRegSave[_SpeakerBalanceAssociated].i;
      end
      else begin
         Result := FAudioRegSave[_SpeakerBalance].i;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetSpeakerVolume: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if CanAssociateAudioAndVideoDevices then begin
         Result := FVideoRegSave[_SpeakerVolumeAssociated].i;
      end
      else begin
         Result := FAudioRegSave[_SpeakerVolume].i;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetSpeakerBalance (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      GetSpeakerBalance;  { we get the current values if not initialized }
      if CanAssociateAudioAndVideoDevices then begin
         FVideoRegSave[_SpeakerBalanceAssociated].i := Value;
      end
      else begin
         FAudioRegSave[_SpeakerBalance].i := Value;
      end;
      UpdateSpeakersControl;
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetSpeakerVolume (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      GetSpeakerVolume;  { we get the current values if not initialized }
      if CanAssociateAudioAndVideoDevices then begin
         FVideoRegSave[_SpeakerVolumeAssociated].i := Value;
      end
      else begin
         FAudioRegSave[_SpeakerVolume].i := Value;
      end;
      UpdateSpeakersControl;
   end;
end;

(*
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVideoGrabber.SetUploadToDV_Device (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ reduces the DV frame rate if the component is available, otherwise queues the command
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if (Value >= 0) and (Value < VideoDevicesCount) then begin
         if pos ('Microsoft DV', TCapDeviceInfo(_VideoDevices.FDevices.Objects[Value]).FriendlyName) > 0 then begin
            FUploadToDV_Device := Value;
         end;
      end;
   end;
end;
*)

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetAnalogVideoStandard: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TstringList;
   Item: TstringList;
   i: LongInt;
begin
   with TVdgr(_Vdgr) do begin
      List := TstringList.Create;
      Item := TstringList.Create;
      List.Text := ReturnAnalogVideoStandards (FVideoRegSave[_ANVTVFormats].i);
      Item.Text := ReturnAnalogVideoStandards (FVideoRegSave[_ANVTVFormat].i);
      i := -1;
      if Item.Count > 0 then begin
         i := List.IndexOf (Item[0]);
      end;
      if i = -1 then begin
         i := 0;
      end;
      Result := i;
      List.Free;
      Item.Free;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAnalogVideoStandards: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TstringList;
begin
   with TVdgr(_Vdgr) do begin
      List := TstringList.Create;
      List.Text := ReturnAnalogVideoStandards (FVideoRegSave[_ANVTVFormats].i);
      Result := List.Text;
      List.Free;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetAnalogVideoStandardsCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TstringList;
begin
   with TVdgr(_Vdgr) do begin
      List := TstringList.Create;
      List.Text := ReturnAnalogVideoStandards (FVideoRegSave[_ANVTVFormats].i);
      Result := List.Count;
      List.Free;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAnalogVideoStandard (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video standard (NTSC, PAL, etc...)
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TstringList;
begin
   with TVdgr(_Vdgr) do begin
      List := TstringList.Create;
      List.Text := ReturnAnalogVideoStandards (FVideoRegSave[_ANVTVFormats].i);
      if List.Count = 0 then begin
         FVideoRegSave[_ANVTVFormat].i := 0;
         Exit;
      end;

      if (Value < 0) or (Value >= List.Count) then begin
         LogB (true, LERROR, e_index_out_of_range, 'analog video standard index out of range');
         Exit;
      end;

      FVideoRegSave[_ANVTVFormat].i := ReturnTVFormat (List[Value]);

      if assigned (F_AMAnalogVideoDecoder) then begin
         F_AMAnalogVideoDecoder.Put_TVFormat (FVideoRegSave[_ANVTVFormat].i);
      end;

      List.Free;

      RefreshPreview ('savs');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPreviewZoomSize (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value < 1 then Exit;
      if Value = FPreviewZoomSize then Exit;
      FPreviewZoomSize := Value;
      ResizeVideoWindows (True);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAudioDevice: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAudioDevice;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetAudioDeviceRendering: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAudioDeviceRendering;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetGlobal_AudioDevices: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ the audio devices list
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := _AudioDevices.List;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetGlobal_VideoDevices: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ the video devices list
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := _VideoDevices.List;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetGlobal_AudioCompressors: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ the audio compressors list
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := _AudioCompressors.List;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetAudioFormat: TAudioFormat;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FAudioFormat;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAudioFormats: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ the audio formats list
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := _AudioFormats;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetAudioRecording: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAudioRecording;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAudioRecording (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FAudioRecording := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSizes: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ the video sizes list
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TstringList;
   i: LongInt;
begin
   with TVdgr(_Vdgr) do begin
      Result := '';
      if not FInitializedAtRuntime then Exit;
      if _VideoDevices.FDevices.Count = 0 then Exit;
      if FVideoSizes.Count = 0 then Exit;
      List := TstringList.Create;
      for i := 0 to FVideoSizes.Count - 1 do begin
          List.Add (Trim (FVideoSizes[i]));
      end;
      List[0] := 'default';
      Result := List.Text;
      List.Free;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSource_FileOrURL_StartTime: int_64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoSource_FileOrURL_StartTime;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoSource_FileOrURL_StartTime (Value: int_64);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideoSource_FileOrURL_StartTime := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSource_FileOrURL_StopTime: int_64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoSource_FileOrURL_StopTime;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoSource_FileOrURL_StopTime (Value: int_64);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideoSource_FileOrURL_StopTime := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSourceHeight: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoSourceHeight;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSourceWidth: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoSourceWidth;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSubtypes: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ the video Subtypes list
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TempList: TstringList;
   i: LongInt;
begin
   with TVdgr(_Vdgr) do begin
      Result := '';
      if not FInitializedAtRuntime then Exit;
      if _VideoDevices.FDevices.Count = 0 then Exit;
      if FVideoSubtypes.Count = 0 then Exit;
      TempList := TStringList.Create;
      for i := 0 to FVideoSubtypes.Count - 1 do begin
         if FVideoRegSave[_IsVfw].b then begin
            TempList.Add (FVideoSubtypes[i]);
         end
         else begin
            TempList.Add (ReturnFourCC (FVideoSubtypes[i]));
         end;
      end;
      TempList[0] := 'default';
      Result := TempList.Text;
      TempList.Free;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoQualitySettings: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoQualitySettings;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoQualitySettings (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideoQualitySettings := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoControlSettings: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoControlSettings;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoControlSettings (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideoControlSettings := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetGlobal_VideoCompressors: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ the video compressors list
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := _VideoCompressors.List;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPlayerFramePosition (Value: Int_64);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      SetPlayer_FramePosition (Value);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPlayerTimePosition (Value: Int_64);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      SetPlayer_TimePosition (Value);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AnalogVideoStandardIndex (Value: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := SelectIndexFromList (ReturnAnalogVideoStandards (FVideoRegSave[_ANVTVFormats].i), Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AudioCompressorIndex (Value: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := SelectIndexFromList (_AudioCompressors.List, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AudioDeviceIndex (Value: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := SelectIndexFromList (_AudioDevices.List, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AudioInputIndex (Value: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := SelectIndexFromList (FAudioRegSave[_AudioInputs].s, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VideoCompressorIndex (Value: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := SelectIndexFromList (_VideoCompressors.List, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VideoDeviceIndex (Value: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := SelectIndexFromList (_VideoDevices.List, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VideoInputIndex (Value: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := SelectIndexFromList (FVideoRegSave[_VideoInputs].s, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VideoSizeIndex (Value: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := SelectIndexFromList (FVideoRegSave[_VideoInputs].s, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VideoSubtypeIndex (Value: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := SelectIndexFromList (GetVideoSubtypes, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.PausePreview: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ stops immediately and Close the current graph.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not allow([cs_Preview], LERROR, True) then Exit;
      if not FGraphAccessAllowed then Exit;
      if FFilterState <> State_Running then Exit;
      FCurrentFrameData.LastFrameAvailable := False;
      if FCurrent.FrameGrabber = fg_Disabled then begin
         if FCurrent.VideoSource = vs_VideoCaptureDevice then begin
            ChangeGraphState (state_Paused, 'ppg');
         end
         else begin
            ChangeGraphState (state_Stopped, 'ppg2');
         end;
      end
      else begin
         FCurrentFrameData.RequestLastFrame := True;
      end;
      Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.SetLogoFromBMPFile (FileName: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not FileExists (FileName) then Exit;
      if assigned (FLogoBitmap) then begin
         FLogoBitmap.Free;
      end;
      FLogoBitmap := TBitmap.Create;
      try
         FLogoBitmap.LoadFromFile (FileName);
         Result := True;
      finally
         if not Result then begin
           FLogoBitmap.Free;
         end;
         Invalidate;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.SetLogoFromJPEGFile (FileName: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   JpegImage: TJpegImage;
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not FileExists (FileName) then Exit;

      if assigned (FLogoBitmap) then begin
         FLogoBitmap.Free;
      end;
      FLogoBitmap := TBitmap.Create;
      JPegImage := TJPegImage.Create;
      try
         JPegImage.LoadFromFile (FileName);
         FLogoBitmap.Width := JpegImage.Width;
         FLogoBitmap.Height := JpegImage.Height;
         FLogoBitmap.Canvas.Draw (0, 0, JpegImage);
         Result := True;
      finally
         if not Result then begin
           JPegImage.Free;
           FLogoBitmap.Free;
         end;
         Invalidate;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.SetLogoFromHBitmap  (Bitmap: HBITMAP): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   DummyBitmap: TBitmap;
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      FLogoBitmap := TBitmap.Create;
      try
         if assigned (FLogoBitmap) then begin
            FLogoBitmap.Free;
         end;
         DummyBitmap := TBitmap.Create;
         DummyBitmap.Handle := Bitmap;
         FLogoBitmap := TBitmap.Create;
         FLogoBitmap.Width := DummyBitmap.Width;
         FLogoBitmap.Height := DummyBitmap.Height;
         FLogoBitmap.Canvas.Draw (0, 0, DummyBitmap);
         DummyBitmap.ReleaseHandle;
         DummyBitmap.Free;
         Result := True;
      finally
         if not Result then begin
           FLogoBitmap.Free;
         end;
         Invalidate;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.SetLogoFromImage  (Image: TImage): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (Image) then Exit;
      FLogoBitmap := TBitmap.Create;
      try
         FLogoBitmap.Width := Image.Picture.Width;
         FLogoBitmap.Height := Image.Picture.Height;
         FLogoBitmap.Canvas.Draw (0, 0, Image.Picture.Graphic);
         Result := True;
      finally
         if not Result then begin
           FLogoBitmap.Free;
         end;
         Invalidate;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.SetLogoFromTBitmap  (Bitmap: TBitmap): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (Bitmap) then Exit;
      Result := SetLogoFromHBitmap (Bitmap.Handle);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.ResumePreview: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ stops immediately and Close the current graph.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not allow([cs_Preview], LERROR, True) then Exit;
      if FCurrent.VideoSource = vs_VideoCaptureDevice then begin
         if not FGraphAccessAllowed then Exit;
         if FFilterState <> State_Paused then Exit;
      end
      else begin
         if FFilterState <> State_Stopped then Exit;
      end;
      if assigned (FFrameInfo_Current.FrameBitmapData.FrameBitmap) then begin
         FFrameInfo_Current.FrameBitmapData.FrameBitmap.Free;
         FFrameInfo_Current.FrameBitmapData.FrameBitmap := nil;
      end;
      ChangeGraphState (State_Running, 'rprev');
      Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.StartPreview: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ stops immediately and Close the current graph.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if IsLiveVideoSource then begin
         if NoDevicesOrIndexOutOfRange (FVideoDevice, _VideoDevices.Count, 'video capture device') then Exit;
         CheckApplySetAudioVideoDevices;
      end;
      if not allow([cs_Down, cs_Preview, cs_Playback], LERROR, true) then Exit;
      PostCommand (WMStartPreview);
      Result := FGraphType = cs_Preview;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.StartRecording: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ starts the video capture
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not Allow ([cs_Down, cs_Preview, cs_Playback], LERROR, False) then Exit;
      if LogB (FGraphType = cs_Recording, LERROR, e_stop_recording_first, 'already recording') then Exit;
      if IsLiveVideoSource then begin
         if NoDevicesOrIndexOutOfRange (FVideoDevice, _VideoDevices.Count, 'video capture device') then Exit;
         CheckApplySetAudioVideoDevices;
      end;
      PostCommand (WMStartRecording);
      Result := FGraphType = cs_Recording;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.StartReencoding: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ starts the video capture
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if LogB (FGraphType = cs_Reencoding, LERROR, e_stop_reencoding_first, 'already reencoding') then Exit;
      if not Allow ([cs_Down, cs_Preview], LERROR, False) then Exit;
      PostCommand (WMStartReencoding);
      Result := FGraphType = cs_Reencoding;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.StopReencoding: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ starts the video capture
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   with TVdgr(_Vdgr) do begin
      if LogB (FGraphType <> cs_Reencoding, LERROR, e_not_reencoding, 'not reencoding') then Exit;
      PostStopGraphMessage;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.Stop: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FGraphType <> cs_Down;
      if Result then begin
         FLastPreviewFailed := False;
         PostStopGraphMessage;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.Cancel: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FPreallocatedFileCancelCreation := True;
      Result := FGraphType <> cs_Down;
      if Result then begin
         ClearGraph (True);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.StopPreview;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ stops immediately and Close the current graph.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FLastPreviewFailed := False;
      if not allow([cs_Preview], LERROR, True) then Exit;
      if FGraphType = cs_Down then LogB (true, LERROR, e_not_previewing, 'not previewing');
      PostStopGraphMessage;
   end;
end;

//------------------------------------------------------------------------------
function TJxdVideoGrabber.ResetPreview: Boolean;
//------------------------------------------------------------------------------
// stops immediately and Close the current graph.
//------------------------------------------------------------------------------
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if LogB ((FVideoDevice >= 0) and (FVideoDevice >= _VideoDevices.Count), LERROR, e_index_out_of_range, 'video device index out of range') then Exit;
      if FGraphType = cs_Preview then begin
         if FFilterState = state_running then begin
            ChangeGraphState (State_Stopped, 'rstpre');
            //FlushMessages; ZZZZZ
            //Sleep (1);     ZZZZZ
            ChangeGraphState (State_Running, 'rstpre');
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFAudioChannels (Value:LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value <> -1) and (Value <> 1) and (Value <> 2) then Exit;
   with TVdgr(_Vdgr) do FASFSettings.AudioChannels := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFDeinterlaceMode (Value: TASFDeinterlaceMode);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FASFSettings.DeinterlaceMode := LongWord (Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFFixedFrameRate (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FASFSettings.FixedFrameRate := Value;
end;

(*  // not yet implemented
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVideoGrabber.SetASFJPEGCompressionQuality (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value <> -1) and ((Value < 1) or (Value > 100)) then Exit;
   with TVdgr(_Vdgr) do FASFSettings.JPEGCompressionQuality := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVideoGrabber.GetASFJPEGCompressionQuality: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFSettings.JPEGCompressionQuality;
end;
*)

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFVideoBitRate (Value:LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < -1) or (Value = 0) then Exit;
   with TVdgr(_Vdgr) do FASFSettings.VideoBitRate := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFVideoQuality (Value:LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if Value < -1 then Exit;
   with TVdgr(_Vdgr) do FASFSettings.VideoQuality := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFVideoHeight (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < -1) or (Value = 0) then Exit;
   with TVdgr(_Vdgr) do FASFSettings.VideoHeight := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFVideoWidth (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < -1) or (Value = 0) then Exit;
   with TVdgr(_Vdgr) do FASFSettings.VideoWidth := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFVideoMaxKeyFrameSpacing (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if Value < -1 then Exit;
   with TVdgr(_Vdgr) do FASFSettings.VideoMaxKeyFrameSpacing := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetNetworkStreaming: TNetworkStreaming;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FNetworkStreaming;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFProfileFromCustomFile: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFProfileFromCustomFile;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFProfileFromCustomFile (Value: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FASFProfileFromCustomFile := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetASFProfiles: String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TStringList;
   ProfilesCount: LongWord;
   i: LongInt;
   lProfilesCount: LongInt;
   WMProfile: IWMProfile;
   WMProfileManager: IWMProfileManager;
   WMProfileManager2: IWMProfileManager2;
   sProfilName: dword;
   pProfilName: pWideChar;
begin
   with TVdgr(_Vdgr) do begin
      List := TStringList.Create;
      try
         ChangeBusyStateAndCursor (True);

         if not LoadWMVASFNetLib then Exit;
         if Failed (WMCreateProfileManager (WMProfileManager)) then Exit;
         if Succeeded (WMProfileManager.QueryInterface (IWMProfileManager2, WMProfileManager2)) then begin
            WMProfileManager2.SetSystemProfileVersion (WMT_VER_8_0);
            WMProfileManager2 := nil;
         end;
         if Failed (WMProfileManager.GetSystemProfileCount (ProfilesCount)) then Exit;
         lProfilesCount := ProfilesCount;
         LogB (lProfilesCount = 0, LERROR, e_failed_to_load_ASF_profile, 'no ASF profiles available. Perhaps the Windows Media Encoder 9 is not installed.');
         for i := 0 to lProfilesCount - 1 do begin
            if Succeeded (WMProfileManager.LoadSystemProfile (i, WMProfile)) then begin
               if Succeeded (WMProfile.GetName (nil, sProfilName)) then begin
                  GetMem (pProfilName, sProfilName shl 1);
                  if Succeeded (WMProfile.GetName (pProfilName, sProfilName)) then begin
                     List.Add (pProfilName);
                  end;
                  FreeMem (pProfilName);
               end;
               WMProfile := nil;
            end;
         end;
      finally
         if assigned (WMProfileManager) then WMProfileManager := nil;
         Result := List.Text;
         List.Free;
         ChangeBusyStateAndCursor (False);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetASFProfilesCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   ProfilesCount: LongWord;
   WMProfileManager: IWMProfileManager;
   WMProfileManager2: IWMProfileManager2;
begin
   Result := 0;
   with TVdgr(_Vdgr) do begin
      try
         ChangeBusyStateAndCursor (True);
         if not LoadWMVASFNetLib then Exit;
         if Failed (WMCreateProfileManager (WMProfileManager)) then Exit;
         if Succeeded (WMProfileManager.QueryInterface (IWMProfileManager2, WMProfileManager2)) then begin
            WMProfileManager2.SetSystemProfileVersion (WMT_VER_8_0);
            WMProfileManager2 := nil;
         end;
         if Failed (WMProfileManager.GetSystemProfileCount (ProfilesCount)) then Exit;
         Result := ProfilesCount;
      finally
         if assigned (WMProfileManager) then WMProfileManager := nil;
         ChangeBusyStateAndCursor (False);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFAudioBitRate: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFSettings.AudioBitRate;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFAudioChannels: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFSettings.AudioChannels;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFMediaServerPublishingPoint;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFMediaServerPublishingPoint;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFNetworkPort: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFNetworkPort;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFNetworkMaxUsers: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFNetworkMaxUsers;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFProfile: Integer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFProfile;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFVideoBitRate: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFSettings.VideoBitRate;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFDeinterlaceMode: TASFDeinterlaceMode;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := TASFDeinterlaceMode (FASFSettings.DeinterlaceMode);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFFixedFrameRate: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFSettings.FixedFrameRate;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFVideoHeight: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFSettings.VideoHeight;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFVideoMaxKeyFrameSpacing: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFSettings.VideoMaxKeyFrameSpacing;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFVideoQuality: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFSettings.VideoQuality;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetASFVideoWidth: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FASFSettings.VideoWidth;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFAudioBitRate (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FASFSettings.AudioBitRate := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFMediaServerPublishingPoint (Value: String);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FASFMediaServerPublishingPoint := Value;
      if Value = 'vidgrablog' then begin
         Log_DoLogToFile := True;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFNetworkPort (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value < 0 then Exit;
      FASFNetworkPort := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFNetworkMaxUsers (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value < 0 then Exit;
      FASFNetworkMaxUsers := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetASFProfile (Value: Integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FASFProfile := Value;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.TVStartAutoScan: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if FIsTVAutoTuneRunning then Exit;
      if not Allow ([cs_Down, cs_Preview], LERROR, True) then Exit;
      if LogB (not FVideoRegSave[_IsTVTunerAvail].b, LERROR, e_no_tv_tuner, 'no TV tuner!') then Exit;
      if LogB (not FIsTunerInputSelected, LERROR, e_tuner_input_not_selected, 'TV tuner input not selected!') then Exit;
      PostCommand (WMProcessStartTVAutoScan);
      Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.TVStopAutoScan: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (not FVideoRegSave[_IsTVTunerAvail].b, LERROR, e_no_tv_tuner, 'no TV tuner!') then Exit;
      if not FIsTVAutoTuneRunning then Exit;
      FTVScanStopRequest := True;
      Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetSystemTempPath: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TempPath: PChar;
begin
   GetMem (TempPath, MAX_PATH);
   if GetTempPath (MAX_PATH, TempPath) <> 0 then begin
      Result := TempPath;
   end
   else begin
      Result := '';
   end;
   FreeMem (TempPath);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetStreamingURL: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FStreamingURL;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetTVChannel: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FVideoRegSave[_TVChannel].i;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetTVTunerInputType: TTunerInputType;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := TTunerInputType (FVideoRegSave[_TVInputType].i);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetTVCountryCode: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FVideoRegSave[_TVCountryCode].i;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTVTunerInputType (Value: TTunerInputType);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if (Value < Low (TTunerInputType)) or (Value > High(TTunerInputType)) then Exit;
      FVideoRegSave[_TVInputType].i := LongInt (Value);
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then Exit;
      TVDoSetChannel (FVideoRegSave[_TVChannel].i, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTVCountryCode (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoRegSave[_TVCountryCode].i := Value;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then Exit;
      TVDoSetChannel (FVideoRegSave[_TVChannel].i, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetTVUseFrequencyOverrides: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTVUseFrequencyOverrides;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetTVChannelInfo: TTVChannelInfo;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FTVChannelInfo;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTVUseFrequencyOverrides (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FTVUseFrequencyOverrides := Value;
      if Value <> FTVFrequencyOverrideInUse then begin
         TVDoSetChannel (FVideoRegSave[_TVChannel].i, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetTVChannel (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoRegSave[_TVChannel].i := Value;
      if not assigned (F_AMTVTuner) then Exit;
      if LogB (FIsTVAutoTuneRunning, LERROR, e_tv_command_not_allowed_during_tv_tuning, TvCommandNotAllowedDuringScan) then Exit;
      TVDoSetChannel (FVideoRegSave[_TVChannel].i, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.TVGetMinMaxChannels (var MinChannel: LongInt; var MaxChannel: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      MinChannel := 0;
      MaxChannel := 0;
      if not FGraphAccessAllowed then Exit;
      if not assigned (F_AMTVTuner) then Exit;
      if FIsTVAutoTuneRunning then Exit;
      Result := F_AMTVTuner.ChannelMinMax (MinChannel, MaxChannel) = S_OK;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.TVClearFrequencyOverrides: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey: TRegistry2;
   OverrideKeyName: String;
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      RegKey := nil;
      try
         OverrideKeyName := AutoTuneKeyName (OverriddenTuningSpace (FVideoRegSave[_TVCountryCode].i), FVideoRegSave[_TVInputType].i);
         RegKey := TRegistry2.Create (True);
         if assigned (RegKey) then begin
            if RegKey.KeyExists (OverrideKeyName) then begin
               Result := RegKey.DeleteKey (OverrideKeyName);
           end;
         end;
      finally
         if assigned (RegKey) then RegKey.Free;
         if FTVFrequencyOverrideInUse then begin
            RefreshPreview ('scf');
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.TVSetChannelFrequencyOverride (TVChannel: LongInt; FrequencyInHz: LongInt): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey: TRegistry2;
   CanRefreshPreview: Boolean;
begin
   with TVdgr(_Vdgr) do begin
      Result := -1;
      if not assigned (F_AMTVTuner) then Exit;
      RegKey := nil;
      CanRefreshPreview := False;
      try
         if OpenAutoTuneRegKey (OverriddenTuningSpace (FVideoRegSave[_TVCountryCode].i), FVideoRegSave[_TVInputType].i, RegKey) then begin
            if FrequencyInHz = -1 then begin
               if RegKey.ValueExists (IntToStr (TVChannel)) then begin
                  RegKey.DeleteValue (IntToStr (TVChannel));
               end;
            end
            else begin
               RegKey.WriteInteger (IntToStr (TVChannel), FrequencyInHz);
               Result := FrequencyInHz;
            end;
            CanRefreshPreview := True;
         end;
      finally
         if assigned (Regkey) then begin
            RegKey.Free;
         end;
         if CanRefreshPreview then begin
            TVDoSetChannel (FVideoRegSave[_TVChannel].i, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.UseNearestVideoSize (PreferredWidth, PreferredHeight: LongInt; Stretch: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FPreferredVideoWidth := PreferredWidth;
      FPreferredVideoHeight := Preferredheight;
      if (FPreferredVideoWidth > 0) and (FPreferredVideoHeight > 0) then begin
         FStretchPreferredVideoSize := Stretch;
      end
      else begin
         FStretchPreferredVideoSize := False;
      end;
      if FGraphType = cs_Down then begin
         ResizeVideoWindows (True);
      end
      else begin
         if Allow ([cs_Preview], LWARNING, True) then begin
            RefreshPreview ('dunv');
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSizeFromIndex (VideoSizeIndex: LongInt; var VideoWidth: LongInt; var VideoHeight: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if VideoSizeIndex < 0 then Exit;
      if VideoSizeIndex >= FVideoSizes.Count then Exit;
      DecodeVideoSize (VideoSizeIndex, VideoWidth, VideoHeight);
      Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.GetNearestVideoSize (PreferredVideoWidth: LongInt; PreferredVideoHeight: LongInt; var NearestVideoWidth: LongInt; var NearestVideoHeight: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Index: LongInt;
begin
   with TVdgr(_Vdgr) do begin
      Index := SearchNearestVideoSizeUsingRatio (Abs (PreferredVideoWidth), Abs(PreferredVideoHeight));
      DecodeVideoSize (Index, NearestVideoWidth, NearestVideoHeight);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.CreatePreallocCapFile: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := CheckAndOrCreatePreallocatedFile (nil, FPreallocCapFileName);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.StopRecording;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ stops the video capture
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if LogB (FGraphType <> cs_Recording, LERROR, e_not_recording, 'not recording') then Exit;
      PostStopGraphMessage;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.ReencodeVideoClip (SourceVideoClip: String; NewVideoClip: string; IncludeVideoStream, IncludeAudioStream, UseFrameGrabber, UseCurrentVideoCompressor, UseCurrentAudioCompressor: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   ReencodingSettings: TReencodingSettings;
begin
   InitReencodingSettings (@ReencodingSettings);
   ReencodingSettings.SourceVideoClip := SourceVideoClip;
   ReencodingSettings.NewVideoClip := NewVideoClip;
   ReencodingSettings.IncludeVideoStream := IncludeVideoStream;
   ReencodingSettings.IncludeAudioStream := IncludeAudioStream;
   ReencodingSettings.UseFrameGrabber := UseFrameGrabber;
   ReencodingSettings.UseVideoCompressor := UseCurrentVideoCompressor;
   ReencodingSettings.UseAudioCompressor := UseCurrentAudioCompressor;
   Result := TVdgr(_Vdgr).Doreencoding (@ReencodingSettings);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetFrameRate (Value: Double);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video frame rate
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = (FFrameRate / 100) then Exit;
      if Value < 0 then Exit;
      FFrameRate := Round (Value * 100);
      if not FInitializedAtRuntime then Exit;
      if LogB (Intf.IsDigitalVideoIn, LWARNING, w_does_not_apply_to_dv, 'does not apply to DV') then Exit;
      if not (FGraphType in [cs_Down, cs_Preview]) then Exit;
      RefreshPreview ('dsfr');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoCompressionSettings (var DataRate, KeyFrameRate, PFramesPerKeyFrame, WindowSize: LongInt; var Quality: Double; var CanQuality, CanCrunch, CanKeyFrame, CanBFrame, CanWindow: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Dummy1, Dummy2: LongInt;
   pCapabilities: LongInt;
   RegKey: TRegistry2;
   AMCompressionSaved: Boolean;
   TempWindowSize: int64;

   AMVfwCompressDialogs: IAMVfwCompressDialogs;
   AMVideoCompression: IAMVideoCompression;
   VideoCaptureOut: IPin;
   CompOut: IPin;

begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      CanQuality:= false;
      CanCrunch:= false;
      CanKeyFrame:= false;
      CanBFrame:= false;
      CanWindow:= false;
      if not Allow ([cs_Down], LERROR, False) then Exit;
      if InitializationStatus <> ipInitialized then Exit;
      if LogB (_VideoDevices.FDevices.Count = 0, LERROR, e_no_video_input_device, 'no video capture device') then Exit;

      ChangeBusyStateAndCursor (true);
         ReinitCurrentParams (False);
         if CreateDeviceGraph then begin
            if BindAndAddCompressor (F_FilterGraph2, _VideoCompressors, FVideoCompressor, '', F_VideoCompressor, False) then begin
               if F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, FVideoPinCategoryUsed, nil, true, 0, VideoCaptureOut) = S_OK then begin
                  if InsertExistingFilter (F_VideoCompressor, VideoCaptureOut) then begin
                     if F_CaptureGraphBuilder2.FindPin (F_VideoCompressor, PINDIR_OUTPUT, nil, nil, true, 0, CompOut) = S_OK then begin
                        RestoreFilterState (F_VideoCompressor, DeviceRegKeyId (_VideoCompressors, FVideoCompressor));
                        if CompOut.QueryInterface (IAMVideoCompression, AMVideoCompression) = S_OK then begin
                           AmVideoCompression.GetInfo (nil, Dummy1, nil, Dummy2, KeyFrameRate, PFramesPerKeyFrame, Quality, pCapabilities);
                           CanQuality:=  (pCapabilities and CompressionCaps_CanQuality) = CompressionCaps_CanQuality;
                           CanCrunch:=   (pCapabilities and CompressionCaps_CanCrunch) = CompressionCaps_CanCrunch;
                           CanKeyFrame:= (pCapabilities and CompressionCaps_CanKeyFrame) = CompressionCaps_CanKeyFrame;
                           CanBFrame:=   (pCapabilities and CompressionCaps_CanBFrame) = CompressionCaps_CanBFrame;
                           CanWindow:=   (pCapabilities and CompressionCaps_CanWindow) = CompressionCaps_CanWindow;

                           RegKey := TRegistry2.Create (False);
                           if RegKey.OpenKey (DeviceRegKeyId (_VideoCompressors, FVideoCompressor), false) then begin
                              if RegKey.ReadBool ('AMCompression_Saved', AMCompressionSaved) then begin
                                 if AMCompressionSaved then begin
                                    if CanQuality then begin
                                       if RegKey.ReadDouble ('AMCompression_Quality', Quality) then begin
                                          AmVideoCompression.put_Quality (Quality);
                                       end;
                                    end;
                                    if CanCrunch then begin
                                       if  RegKey.ReadInteger ('AMCompression_DataRate', DataRate) then begin
                                           { SET DATA RATE }
                                       end;
                                    end;
                                    if CanKeyFrame then begin
                                       if RegKey.ReadInteger ('AMCompression_KeyFrameRate', KeyFrameRate) then begin
                                          AmVideoCompression.put_KeyFrameRate (KeyFrameRate);
                                       end;
                                    end;
                                    if CanBFrame then begin
                                       if RegKey.ReadInteger ('AMCompression_PFramesPerKeyFrame', PFramesPerKeyFrame) then begin
                                          AmVideoCompression.put_PFramesPerKeyFrame (PFramesPerKeyFrame);
                                       end;
                                    end;
                                    if CanWindow then begin
                                       if RegKey.ReadInteger ('AMCompression_WindowSize', WindowSize) then begin
                                          TempWindowSize := WindowSize;
                                          AmVideoCompression.put_WindowSize (TempWindowSize);
                                       end;
                                    end;
                                 end;
                              end;
                           end;
                           RegKey.Free;

                           if CanQuality then begin
                              AmVideoCompression.get_Quality (Quality);
                           end;
                           if CanCrunch then begin
                              DataRate := 3;
                           end;
                           if CanKeyFrame then begin
                              AmVideoCompression.get_KeyFrameRate (KeyFrameRate);
                           end;
                           if CanBFrame then begin
                              AmVideoCompression.get_PFramesPerKeyFrame (PFramesPerKeyFrame);
                           end;
                           if CanWindow then begin
                              AmVideoCompression.get_WindowSize (TempWindowSize);
                              WindowSize := TempWindowSize;
                           end;
                           Result := true;
                        end;
                     end;
                  end;
               end;
            end;
         end;

         if assigned (AMVfwCompressDialogs) then AMVfwCompressDialogs:= nil;
         if assigned (AMVideoCompression) then AMVideoCompression := nil;
         if assigned (VideoCaptureOut) then VideoCaptureOut := nil;
         if assigned (CompOut) then CompOut:= nil;

         ClearGraph (True);
         ChangeBusyStateAndCursor (false);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.SetVideoCompressionDefaults: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey: TRegistry2;
begin
 with TVdgr(_Vdgr) do begin
   Result := false;
   if InitializationStatus <> ipInitialized then Exit;
   if LogB (_VideoDevices.FDevices.Count = 0, LERROR, e_no_video_input_device, 'no video capture device') then Exit;
   Result := true;
   RegKey := TRegistry2.Create (False);
   if RegKey.OpenKey (DeviceRegKeyId (_VideoCompressors, FVideoCompressor), false) then begin
      RegKey.DeleteValue ('AMCompression_Saved');
   end;
   RegKey.Free;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.SetVideoCompressionSettings (DataRate, KeyFrameRate, PFramesPerKeyFrame, WindowSize: LongInt; Quality: Double): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Dummy1, Dummy2, Dummy3, Dummy4: LongInt;
   Dummy5: Double;
   pCapabilities: LongInt;
   CanQuality: Boolean;
   CanCrunch: Boolean;
   CanKeyFrame: Boolean;
   CanBFrame: Boolean;
   CanWindow: Boolean;
   RegKey: TRegistry2;
   TempWindowSize: int64;

   AMVfwCompressDialogs: IAMVfwCompressDialogs;
   AMVideoCompression: IAMVideoCompression;
   VideoCaptureOut: IPin;
   CompOut: IPin;
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      if InitializationStatus <> ipInitialized then Exit;
      if LogB (_VideoDevices.FDevices.Count = 0, LERROR, e_no_video_input_device, 'no video capture device') then Exit;
      if not Allow ([cs_Down], LERROR, False) then Exit;

      ChangeBusyStateAndCursor (true);
      ReinitCurrentParams (False);
      if CreateDeviceGraph then begin
            if BindAndAddCompressor (F_FilterGraph2, _VideoCompressors, FVideoCompressor, '', F_VideoCompressor, False) then begin
               if F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, FVideoPinCategoryUsed, nil, true, 0, VideoCaptureOut) = S_OK then begin
                  if InsertExistingFilter (F_VideoCompressor, VideoCaptureOut) then begin
                     if F_CaptureGraphBuilder2.FindPin (F_VideoCompressor, PINDIR_OUTPUT, nil, nil, true, 0, CompOut) = S_OK then begin
                        RestoreFilterState (F_VideoCompressor, DeviceRegKeyId (_VideoCompressors, FVideoCompressor));
                        if CompOut.QueryInterface (IAMVideoCompression, AMVideoCompression) = S_OK then begin

                           RegKey := TRegistry2.Create (False);
                           if RegKey.OpenKey (DeviceRegKeyId (_VideoCompressors, FVideoCompressor), true) then begin

                              AmVideoCompression.GetInfo (nil, Dummy1, nil, Dummy2, Dummy3, Dummy4, Dummy5, pCapabilities);
                              CanQuality:=  (pCapabilities and CompressionCaps_CanQuality) = CompressionCaps_CanQuality;
                              CanCrunch:=   (pCapabilities and CompressionCaps_CanCrunch) = CompressionCaps_CanCrunch;
                              CanKeyFrame:= (pCapabilities and CompressionCaps_CanKeyFrame) = CompressionCaps_CanKeyFrame;
                              CanBFrame:=   (pCapabilities and CompressionCaps_CanBFrame) = CompressionCaps_CanBFrame;
                              CanWindow:=   (pCapabilities and CompressionCaps_CanWindow) = CompressionCaps_CanWindow;
                              if CanQuality then begin
                                 AmVideoCompression.put_Quality (Quality);
                                 AmVideoCompression.get_Quality (Quality);
                                 RegKey.WriteDouble ('AMCompression_Quality', Quality);
                              end;
                              if CanCrunch then begin
                                 DataRate := 3;
                                 RegKey.WriteInteger ('AMCompression_DataRate', DataRate);
                              end;
                              if CanKeyFrame then begin
                                 AmVideoCompression.put_KeyFrameRate (KeyFrameRate);
                                 AmVideoCompression.get_KeyFrameRate (KeyFrameRate);
                                 RegKey.WriteInteger ('AMCompression_KeyFrameRate', KeyFrameRate);
                              end;
                              if CanBFrame then begin
                                 AmVideoCompression.put_PFramesPerKeyFrame (PFramesPerKeyFrame);
                                 AmVideoCompression.get_PFramesPerKeyFrame (PFramesPerKeyFrame);
                                 RegKey.WriteInteger ('AMCompression_PFramesPerKeyFrame', PFramesPerKeyFrame);
                              end;
                              if CanWindow then begin
                                 TempWindowSize := WindowSize;
                                 AmVideoCompression.put_WindowSize (TempWindowSize);
                                 AmVideoCompression.get_WindowSize (TempWindowSize);
                                 RegKey.WriteInteger ('AMCompression_WindowSize', WindowSize);
                              end;
                              RegKey.WriteBool ('AMCompression_Saved', true);
                              Result := true;
                           end;
                           RegKey.Free;
                        end;
                     end;
                  end;
               end;
            end;
      end;

      if assigned (AMVfwCompressDialogs) then AMVfwCompressDialogs:= nil;
      if assigned (AMVideoCompression) then AMVideoCompression := nil;
      if assigned (VideoCaptureOut) then VideoCaptureOut := nil;
      if assigned (CompOut) then CompOut:= nil;

      ClearGraph (True);
      ChangeBusyStateAndCursor (false);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.IsDialogAvailable (Dialog: TDialog): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ if the desired dialog is available on the current graph?
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      case Dialog of
         dlg_VideoDevice: begin
            Result := true;
         end;
         dlg_VfwFormat: begin
            Result := FVideoRegSave[_VfwCaptureDialogFormat].b;
         end;
         dlg_VfwSource: begin
            Result := FVideoRegSave[_VfwCaptureDialogSource].b;
         end;
         dlg_VfwDisplay: begin
            Result := FVideoRegSave[_VfwCaptureDialogDisplay].b;
         end;
         dlg_VideoCrossbar: begin
            Result := FVideoRegSave[_IsVideoCrossbarAvail].b;
         end;
         dlg_AudioCrossbar: begin
            Result := FVideoRegSave[_IsAudioCrossbarAvail].b;
         end;
         dlg_TVTuner: begin
            Result := FVideoRegSave[_IsTVTunerAvail].b;
         end;
         dlg_TVAudio: begin
            Result := FVideoRegSave[_IsTVAudioAvail].b;
         end;
         dlg_AudioDevice: begin
            if InitializationStatus = ipInitialized then begin
               if _AudioDevices.FDevices.Count > 0 then begin
                  Result := true;
               end;
            end;
         end;
         dlg_VideoCompressor: begin
            Result := true;
         end;
         dlg_AudioCompressor: begin
            Result := true;
         end;
      end;
   end;
end;

(*
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVideoGrabber.PropertyPageSaver_SetProperty (Dialog: TDialog; PropertyIdentifier: String; PropertyValue: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := True;
      case Dialog of
         dlg_VideoDevice: begin
            if assigned (FPpSaver_VideoDevice.ppInstance) then begin
               FPpSaver_VideoDevice.ppInstance.SetProperty (PropertyIdentifier, PropertyValue);
            end;
         end;
      else
         Result := False;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVideoGrabber.PropertyPageSaver_GetProperty (Dialog: TDialog; PropertyIdentifier: String): String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := '';
      case Dialog of
         dlg_VideoDevice: begin
            if assigned (FPpSaver_VideoDevice.ppInstance) then begin
               Result := FPpSaver_VideoDevice.ppInstance.GetProperty (PropertyIdentifier);
            end;
         end;
      end;
   end;
end;
*)

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.ShowDialog (Dialog: TDialog): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ shows the desired dialog. Set TestOnly to true to know if the dialog is available without displaying it.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   MustClear: Boolean;
   CanRestart: Boolean;
begin
   Result := False;
   with TVdgr(_Vdgr) do begin
      CanRestart := FGraphType = cs_Preview;

      case Dialog of

            dlg_VideoCompressor: begin
               FMPEGWriterFilter := CheckCustomMPEGRecording (True);
               if FMPEGWriterFilter = '' then begin
                  Result := VideoCompressorDialog_InLine;
               end
               else begin
                  Result := VideoCompressorDialog_Rendered;
               end;
            end;

            dlg_AudioCompressor: begin
               Result := AudioCompressorDialog;
            end;

            dlg_StreamConfig: begin
               Result := not IsDVSource;
               if Result then begin
                  if not FVideoRegSave[_IsVfw].b then begin
                     Result := VideoStreamDialog;
                  end
                  else begin
                     Result := VideoDeviceDialog (dlg_VideoDevice);
                  end;
                  ResizeVideoWindows (True);
               end;
            end;

            dlg_Videodevice: begin
               if assigned (F_VideoDevice) and (not FVideoRegSave[_IsVfw].b) and (FFilterState = state_Running) then begin
                  (*if assigned (FPropertyPageSaver) and assigned (FPpSaver_VideoDevice.ppInstance) then begin
                     FPpSaver_VideoDevice.ppInstance.SetIdentifyProperties (FPropertyPageSaver.GetIdentifyProperties);
                     FPpSaver_VideoDevice.ppInstance.ShowDialog;
                  end
                  else begin*)
                     Result := WDMDialog (F_VideoDevice);
                  //end;
               end
               else begin
                  Result := VideoDeviceDialog (dlg_VideoDevice);
               end;
               if Result then begin
                  ResizeVideoWindows (True);
               end;
               CanRestart := False;
            end;

            dlg_AudioDevice: begin
               Result := AudioDeviceDialog;
            end;

            dlg_VfwFormat, dlg_VfwSource, dlg_VfwDisplay: begin
               Result := VideoDeviceDialog (Dialog);
            end;

            dlg_VideoCrossbar: begin
               if assigned (F_AMVideoCrossbar) then begin
                  Result := WDMDialog (F_AMVideoCrossbar);
                  if Result then begin
                     FCrossbar[LongInt(cs_VideoCrossbar)].ReadCrossbar (F_AMVideoCrossbar);
                  end;
               end;
               CanRestart := False;
            end;

            dlg_AudioCrossbar: begin
               if assigned (F_AMAudioCrossbar) then begin
                  Result := WDMDialog (F_AMAudioCrossbar);
                  if Result then begin
                     FCrossbar[LongInt(cs_AudioCrossbar)].ReadCrossbar (F_AMAudioCrossbar);
                  end;
               end;
               CanRestart := False;
            end;

            dlg_TVTuner: begin
               MustClear := False;
               if FGraphType = cs_Down then begin
                  MustClear := BuildNonVisibleVideoGraph;
               end
               else begin
                  CanRestart := False;
               end;
               if assigned (F_AMTVTuner) then begin
                  Result := WDMDialog (F_AMTVTuner);
               end;
               if MustClear then begin
                  ClearGraph (True);
               end;
            end;

            dlg_TVAudio: begin
               if assigned (F_AMTVAudio) then begin
                  Result := WDMDialog (F_AMTVAudio);
               end;
               CanRestart := False;
            end;
      end;
      if CanRestart then begin
         FGraphType := cs_Preview;
         RefreshPreview ('dd');
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoCompressor (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the current video compressor
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FVideoCompressor then Exit;
      if NoDevicesOrIndexOutOfRange (FVideoCompressor, _VideoCompressors.Count, 'video compressor') then Exit;
      FVideoCompressor:= Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAudioCompressor (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the current audio compressor
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FAudioCompressor then Exit;
      if NoDevicesOrIndexOutOfRange (FAudioCompressor, _AudioCompressors.Count, 'audio compressor') then Exit;
      FAudioCompressor:= Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAudioDeviceRendering (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ enable audio rendering
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FAudioDeviceRendering then Exit;
      FAudioDeviceRendering := Value;
      if FCurrent.AudioDevice > -1 then begin
         RefreshPreview ('dsar');
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoCompression_KeyFrameRate: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideocompression_KeyFrameRate;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoCompression_PFramesPerKeyFrame: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideocompression_PFramesPerKeyFrame;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoCompression_Quality: Double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideocompression_Quality;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoCompression_WindowSize: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideocompression_WindowSize;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoCompression_KeyFrameRate (Value:LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideocompression_KeyFrameRate := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoCompression_PFramesPerKeyFrame (Value:LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideocompression_PFramesPerKeyFrame := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoCompression_Quality (Value:Double);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideocompression_Quality := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoCompression_WindowSize (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideocompression_WindowSize := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetVideoFromImages_SourceDirectory: String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoFromImages_SourceDirectory;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoFromImages_SourceDirectory (Value: String);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FVideoFromImages_SourceDirectory then Exit;
      FVideoFromImages_SourceDirectory := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetVideoFromImages_RepeatIndefinitely: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoFromImages_RepeatIndefinitely;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoFromImages_RepeatIndefinitely (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FVideoFromImages_RepeatIndefinitely then Exit;
      FVideoFromImages_RepeatIndefinitely := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetVideoFromImages_TemporaryFile: String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoFromImages_TemporaryFile;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoFromImages_TemporaryFile (Value: String);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FVideoFromImages_TemporaryFile then Exit;
      FVideoFromImages_TemporaryFile := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetVideoFromImages_BitmapsSortedBy: TFileSort;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoFromImages_BitmapsSortedBy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoFromImages_BitmapsSortedBy (Value: TFileSort);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FVideoFromImages_BitmapsSortedBy then Exit;
      FVideoFromImages_BitmapsSortedBy := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetVideoDevice: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoDevice;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoDevice (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the current video input device
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoDevice := Value;
      if Value = -1 then Exit;
      if InitializationStatus <> ipInitialized then Exit;
      if NoDevicesOrIndexOutOfRange (FVideoDevice, _VideoDevices.Count, 'video capture device') then Exit;
      if _VideoDevices.Count < 1 then Exit;
      if FCurrent.VideoDevice = FVideoDevice then Exit;
      if not FInitializedAtRuntime then Exit;
      if FGraphType = cs_Down then begin
         if not (csLoading in Intf.ComponentState) then begin
            if FVideoRegSave[_DeviceDiscovered].b then begin
               SaveCurrentVideoDeviceSettingsToRegistry;
            end;
            ApplySetVideoDevice;
         end;
      end
      else begin
         RefreshPreview ('dsvdev');
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAudioDevice (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the current Audio input device
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FAudioDevice := Value;
      if Value = -1 then Exit;
      if InitializationStatus <> ipInitialized then Exit;
      if NoDevicesOrIndexOutOfRange (FAudioDevice, _AudioDevices.Count, 'audio capture device') then Exit;
      if FCurrent.AudioDevice = FAudioDevice then Exit;
      if not FInitializedAtRuntime then Exit;
      if FGraphType = cs_Down then begin
         if not (csLoading in Intf.ComponentState) then begin
            if FAudioRegSave[_A_DeviceDiscovered].b then begin
               SaveCurrentAudioDeviceSettingsToRegistry;
            end;
            ApplySetAudioDevice;
         end;
      end
      else begin
         RefreshPreview ('dsadev');
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetDVReduceFrameRate (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ reduces the DV frame rate
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FDVReduceFrameRate then Exit;
      FDVReduceFrameRate := Value;
      RefreshPreview ('dvrfr');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoRenderer: TVideoRenderer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoRenderer;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoRenderer (Value: TVideoRenderer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video size
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < Low(TVideoRenderer)) or (Value > High(TVideoRenderer)) then Exit;
   with TVdgr(_Vdgr) do begin
      if Value = FVideoRenderer then Exit;
      FVideoRenderer := Value;
      RefreshPreview ('prvpr');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSource: TVideoSource;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoSource;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoSource (Value: TVideoSource);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video size
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < Low(TVideoSource)) or (Value > High(TVideoSource)) then Exit;
   with TVdgr(_Vdgr) do begin
      if Value = FVideoSource then Exit;
      FVideoSource := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSource_FileOrURL: String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoSource_FileOrURL;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoSource_FileOrURL (Value: String);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video size
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = FVideoSource_FileOrURL then Exit;
      FVideoSource_FileOrURL := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSize: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FVideoRegSave[_VideoSize].i;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSubtype: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FVideoRegSave[_VideoSubtype].i;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetFrameRate: Double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FFrameRate / 100;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetCurrentFrameRate: Double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FRealFrameRate / 100;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetCurrentState: TCurrentState;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FGraphType;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDeliveredFrames: int_64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FFrameInfo_Current.FrameInfo.FrameNumber;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetFrameBuffers: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FFrameBuffers;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetFrameGrabberCurrentRGBFormat: TFrameGrabberRGBFormat;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FFrameGrabberCurrentRGBFormat;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetFrameGrabberRGBFormat: TFrameGrabberRGBFormat;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FFrameGrabberRGBFormat;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDroppedFrameCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FFrameInfo_Current.FrameInfo.DroppedFrameCount;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetInFrameProgressEvent: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FNotifyingFrame or (FCurrentFrameData.SettingNewPosition);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.RunPlayer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ runs the player
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if LogB (FGraphType <> cs_Playback, LTRACE, w_not_playing, 'no clip opened') then Exit;
      if FFilterState = state_Running then Exit;

      if FCurrent.Networkstreaming <> ns_Disabled then begin
         if FFilterState <> state_Running then begin
            ChangeGraphState (state_Running, 'ppg');
         end;
         Exit;
      end;

      if FGraphAccessAllowed then begin
         FPlayerBackwardTimerEnabled := False;
      end;

      FCurrentFrameData.PLayerSeekBackwards := False;
      FCurrentFrameData.PlayerFastSeek := False;

      if FCurrent.Networkstreaming <> ns_Disabled then begin
            ChangeGraphState (state_Running, 'dpr2');
      end
      else begin
         if (FFrameInfo_Current.FrameInfo.FrameTime >= (FPlayerDuration - FCurrentFrameData.PlayerFrameInterval - 1000)) or FCurrentFrameData.PlayerEndOfStreamReached then begin
            SetPlayer_TimePosition (0);
         end;
         if FCurrentFrameData.PlayerEmulateSpeedRatioTickCountInterval > 0 then begin
            RunEmulatedPlayback;
         end
         else begin
            ChangeGraphState (state_Running, 'dpr2');
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.RunPlayerBackwards;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ runs the player
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if PlayerNetworkStreaming then Exit;
      FCurrentFrameData.PlayerFastSeek := False;
      StartPlayerBackwards;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.RewindPlayer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ goes backward in the clip
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if PlayerNetworkStreaming then Exit;
      FCurrentFrameData.PlayerFastSeek := True;
      StartPlayerBackwards;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.FindIndexInListByName (List: String; SearchedString: String; IsSubString: boolean; IgnoreCase: Boolean): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   sl: TStringList;
   Done: Boolean;
   i: LongInt;
   Searched: String;
   Line: string;
begin
   Result := -1;
   if IgnoreCase then begin
      Searched := Lowercase (SearchedString);
   end
   else begin
      Searched := SearchedString;
   end;
   sl := TStringList.Create;
   sl.Text := List;
   Done := False;
   i := 0;
   while not Done do begin
      if i >= sl.Count then begin
         Done := True;
      end
      else begin
         if IgnoreCase then begin
            Line := lowercase (sl[i]);
         end
         else begin
            Line := sl[i];
         end;
         if IsSubString then begin
            if pos (Searched, Line) > 0 then begin
               Result := i;
               Done := True;
            end;
         end
         else begin
            if Searched = Line then begin
               Result := i;
               Done := True;
            end;
         end;
         inc (i);
      end;
   end;
   sl.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.FastForwardPlayer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ goes forward in the clip
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if PlayerNetworkStreaming then Exit;
      FCurrentFrameData.PlayerFastSeek := True;
      StartPlayerForwards;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.DoPausePlayer (Stopped: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ pauses the player
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FCurrent.Networkstreaming <> ns_Disabled then begin
      if Stopped then begin
         if FFilterState <> state_Stopped then begin
            ChangeGraphState (state_Stopped, 'ppg');
         end;
      end
      else begin
         if FFilterState = state_Running then begin
            ChangeGraphState (state_Paused, 'ppg');
         end;
      end;
      Exit;
   end;

   if FGraphAccessAllowed then begin
      FPlayerBackwardTimerEnabled := False;
   end;
   FCurrentFrameData.PLayerSeekBackwards := False;
   FCurrentFrameData.PlayerEmulateSpeedRatio := False;
   FCurrentFrameData.PlayerFastSeek := False;
   if FFilterState = state_Running then begin
      if FFrameGrabber = fg_Disabled then begin
         ChangeGraphState (state_Paused, 'ppg');
      end;
   end;
   if FCurrentFrameData.PlayerEndOfStreamReached then begin
      FCurrentFrameData.PlayerEndOfStreamReached := False;
      FCurrentFrameData.PlayerPausedType := ppt_End;
   end
   else if Stopped then begin
      FPlayerCanRefreshPosition := False;
      FCurrentFrameData.PlayerPausedType := ppt_Begin;
   end
   else begin
      FPlayerCanRefreshPosition := True;
      FCurrentFrameData.PlayerPausedType := ppt_Current;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.PausePlayer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ pauses the player
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if LogB (FGraphType <> cs_Playback, LTRACE, w_not_playing, 'not playing') then Exit;
        DoPausePlayer (False);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.StopPlayer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ pauses the player
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if LogB (FGraphType <> cs_Playback, LTRACE, w_not_playing, 'not playing') then Exit;
      PostCommand (WMStopPlayer);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.ClosePlayer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ closes the player.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if LogB (FGraphType <> cs_Playback, LTRACE, e_trace_log, 'already closed') then Exit;
      PostStopGraphMessage;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.OpenPlayer: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if not Allow ([cs_Down, cs_Preview, cs_Playback], LERROR, False) then Exit;
      if LogB (FGraphType = cs_Recording, LERROR, e_stop_recording_first, 'first stop recording') then Exit;
      if LogB (FPlayerFilename = '', LERROR, e_file_name_not_specified, 'file name not specified') then Exit;
      PostStopGraphMessage;
      PostCommand (WMOpenPlayer);
      Result := FGraphType = cs_Playback;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.AVIDuration (AVIFile: String; var Duration: int_64; var FrameCount: int_64): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
   MAXWC = 512;
var
   MediaSeeking: IMediaSeeking;
   GraphBuilder: IGraphBuilder;
   FileName: pOleStr;
   FrameCount64: int64;
   SourceFilter: IBaseFilter;
   CaptureGraphBuilder2: ICaptureGraphBuilder2;
   Int64Duration: int64;
begin
   Result := False;
   FrameCount := 0;
   Int64Duration := 0;
   FileName := nil;
   try
      if not CreateInstance (@CLSID_FilterGraph, IGraphBuilder, GraphBuilder, 'Graph Builder') then Exit;
      if not CreateInstance (@CLSID_CaptureGraphBuilder2, ICaptureGraphBuilder2, CaptureGraphBuilder2, 'Graph Builder') then Exit;
      if Failed (CaptureGraphBuilder2.SetFilterGraph (GraphBuilder)) then Exit;
      FileName := StringToOleStr (AVIFile);
      if Failed (GraphBuilder.AddSourceFilter(FileName, nil, SourceFilter)) then Exit;
      if Failed (CaptureGraphBuilder2.RenderStream (nil, nil, SourceFilter, nil, nil)) then Exit;
      if Failed (GraphBuilder.QueryInterface (IMediaSeeking, MediaSeeking)) then Exit;
      if MediaSeeking.IsFormatSupported (TIME_FORMAT_FRAME) = S_OK then begin
         MediaSeeking.SetTimeFormat (TIME_FORMAT_FRAME);
         if MediaSeeking.GetDuration (FrameCount64) = S_OK then begin
            FrameCount := FrameCount64;

            Result := True;
         end;
      end;
      if MediaSeeking.SetTimeFormat (TIME_FORMAT_MEDIA_TIME) = S_OK then begin
         if MediaSeeking.GetDuration (Int64Duration) = S_OK then begin
            Duration := Int64Duration;
            Result := True;
         end;
      end;
    finally
      if assigned (FileName) then SysFreeString (FileName);
      if assigned (MediaSeeking) then MediaSeeking := nil;
      if assigned (CaptureGraphBuilder2) then CaptureGraphBuilder2 := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.TerryTest(const Ab: Boolean);
var


  HR: HRESULT;
  s: TAudioState;
begin

  try
    if Ab then
      s := asLeft
    else
      s := asRight;
    TVdgr(_Vdgr).a.put_State(s);
  finally
//    a.Free;
  end;
end;

function TJxdVideoGrabber.Test3: boolean;
begin
  Result := TVdgr(_Vdgr).isV;
end;

function TJxdVideoGrabber.ThirdPartyFilter_AddToList (Location: TThirdPartyFilterList; GUID: TGUID; Name: string; Enable: Boolean; SaveFilterState: Boolean): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
   Done: Boolean;
begin
 with TVdgr(_Vdgr) do begin
   Result := -1;
   Done := false;
   i := 0;
   while not Done do begin
      if i >= ThirdPartyFilterMaxCount then begin
         Done := true;
      end
      else begin
         with FThirdPartyFilter[LongInt (Location), i] do begin
            if _IsEqualGUID (@FilterGUID, @GUID) then begin
               LogB (True, LERROR, e_third_party_filter_already_inserted, 'filter inserted more than 1 time: ' + FilterName);
               Done := True;
            end
            else if _IsEqualGUID (@FilterGUID, @GUID_NULL) then begin
               CopyGUID (@FilterGUID, @GUID);
               FilterName := Name;
               Enabled := Enable;
               SavedFilterState := SaveFilterState;
               Result := i;
               Done := true;
            end
            else begin
               inc (i);
            end
         end;
      end;
   end;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.ThirdPartyFilter_ClearList (Location: TThirdPartyFilterList): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
begin
 with TVdgr(_Vdgr) do begin
   for i := 0 to ThirdPartyFilterMaxCount - 1 do begin
      with FThirdPartyFilter[LongInt (Location), i] do begin
         CopyGUID (@FilterGUID, @GUID_NULL);
         Enabled := false;
      end;
   end;
   Result := True;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.ThirdPartyFilter_Enable (Location: TThirdPartyFilterList; Index: LongInt; Enable: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
 with TVdgr(_Vdgr) do begin
   Result := false;
   if Index >= ThirdPartyFilterMaxCount then Exit;
   if Index < 0 then Exit;
   with FThirdPartyFilter[LongInt (Location), Index] do begin
      if _IsEqualGUID (@FilterGUID ,@GUID_NULL) then Exit;
      Enabled := Enable;
      Result := true;
   end;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.ThirdPartyFilter_RemoveFromList (Location: TThirdPartyFilterList; Index: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
 with TVdgr(_Vdgr) do begin
   Result := false;
   if Index >= ThirdPartyFilterMaxCount then Exit;
   if Index < 0 then Exit;
   with FThirdPartyFilter[LongInt (Location), Index] do begin
      if _IsEqualGUID (@FilterGUID , @GUID_NULL) then Exit;
      CopyGUID (@FilterGUID, @GUID_NULL);
      Enabled := false;
      Result := true;
   end;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMuteAudioRendering: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FMuteAudioRendering;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMuteAudioRendering (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FMuteAudioRendering = Value then Exit;
      FMuteAudioRendering := Value;
      if IsInDesignMode then Exit;
      UpdateSpeakersControl;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetNormalCursor: TCursor;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FNormalCursor;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetNormalCursor (Value: TCursor);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FNormalCursor := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerAudioRendering: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPlayerAudioRendering;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetPlayerDVSize: TDVSize;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPlayerDVSize;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetNotificationMethod: TNotificationMethod;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FNotificationMethod;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetNotificationSleepTime: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FNotificationSleepTime;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetNotificationPriority: TThreadPriority;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FNotificationPriority;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetNetworkStreaming (Value: TNetworkStreaming);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FNetworkStreaming = Value then Exit;
      FNetworkStreaming := Value;
      RefreshPreview ('snstr');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetNotificationMethod (Value: TNotificationMethod);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FNotificationMethod := Value;
      if IsInDesignMode then Exit;

      if assigned (FAutoTuningStepThread) then FAutoTuningStepThread.SetNotificationMethod (FNotificationMethod);
      if assigned (FTaskThread) then FTaskThread.SetNotificationMethod (FNotificationMethod);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetNotificationSleepTime (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if (Value <= 0) and (Value <> -1) then Exit;
      if Value > 10000 then Exit; // > 10 s is stupid
      FNotificationSleepTime := Value;
      if FNotificationSleepTime = -1 then begin
         FNotificationSleepTimeUsed := DEFAULTNOTIFICATIONSLEEPTIME;
      end
      else begin
         FNotificationSleepTimeUsed := FNotificationSleepTime;
      end;
      ApplyNotificationSleepTime;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetNotificationPriority (Value: TThreadPriority);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FNotificationPriority := Value;
      if IsInDesignMode then Exit;
      if assigned (FAutoTuningStepThread) then FAutoTuningStepThread.Priority := FNotificationPriority;
      if assigned (FTaskThread) then FTaskThread.Priority := FNotificationPriority;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.ThirdPartyFilter_ShowDialog (Location: TThirdPartyFilterList; Index: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FilterCreated: Boolean;
   pp: TPropertyPageSaverBase;
begin
 with TVdgr(_Vdgr) do begin
   Result := false;
   if Index >= ThirdPartyFilterMaxCount then Exit;
   if Index < 0 then Exit;
   with FThirdPartyFilter[LongInt (Location), Index] do begin
      if _IsEqualGUID (@FilterGUID ,@GUID_NULL) then Exit;
      FilterCreated := assigned (Filter);
      if not FilterCreated then begin
         if not CreateInstance (@FilterGUID, IBaseFilter, Filter, 'create third party filter for dialog') then Exit;
         if Filter.QueryInterface (IUnknown, FilterIntf) <> S_OK then begin
            FilterIntf := nil;
         end;
      end;
      if not assigned (FilterIntf) then Exit;

      if assigned (FPropertyPageSaver) then begin
         pp := FPropertyPageSaver.CreateNewInstance (nil);
         pp.Parent := Intf;
         pp.SetRegistryKey (ThirdPartyFilterRegKeyId (FilterGUID) + '\');
         pp.SetRegistrySubKey ('PPSaver');
         if pp.Activate (FilterIntf) then begin
            pp.RestoreProperties;
            pp.ShowDialog;
            pp.SaveProperties;
            pp.Deactivate;
         end;
         pp.Free;
      end
      else begin
         if SavedFilterState then begin
            RestoreFilterState (Filter, ThirdPartyFilterRegKeyId (FilterGUID));
         end;
         if WDMDialog (FilterIntf) then begin
            if SavedFilterState then begin
               SaveFilterState (Filter, ThirdPartyFilterRegKeyId (FilterGUID));
            end;
         end;
      end;
      Result := True;
      if not FilterCreated then begin
         Filter := nil;
         FilterIntf := nil;
      end;
   end;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.MotionDetector_Get2DTextGrid: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ this function builds a 2D text representation of the grid sensitivity
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i, j: integer;
   sl: TStringList;
   Temp: string;
   Temp2: string;
begin
 with TVdgr(_Vdgr).FMotionDetector do begin
   sl := TStringList.Create;
   for i := 0 to FGridYBound do begin
      Temp := Copy (MotionDetector_Grid, (i * (FGridXSize + 1)) + 1, FGridXSize);
      Temp2 := '';
      for j := 1 to length (Temp) do begin
         if Temp[j] = '0' then begin
            Temp2 := Temp2 + '. ';
         end
         else begin
            Temp2 := Temp2 + Temp[j] + ' ';
         end;
      end;
      sl.Add (Trim (Temp2));
   end;
   Result := sl.Text;
   sl.Free;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.MotionDetector_Get2DTextMotion: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ this function builds a 2D text represention of the motion detected within the grid
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i, j: integer;
   sl: TStringList;
   Temp2: string;
   Det: integer;
   MotionRatio: Double;
begin
 with TVdgr(_Vdgr).FMotionDetector do begin
   sl := TStringList.Create;
   sl.text := '';
   for i := 0 to FGridYBound do begin
      Temp2 := '';
      for j := 0 to FGridXBound do begin
         MotionRatio := MotionDetector_CellMotionRatio (j, i);
         if MotionRatio > 0 then begin
            Det := Round (MotionRatio * 10);
            if Det > 9 then begin
               Det := 9;
            end;
            Temp2 := Temp2 + Char (Det + 48) + ' ';
         end
         else begin
            Temp2 := Temp2 + '. ';
         end;
      end;
      sl.Add (Temp2);
   end;
   Result := sl.Text;
   sl.Free;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_IsGridValid: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FIsGridValid;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_Grid: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FGrid;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_GridXCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FGridXSize;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_GridYCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FGridYSize;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.MotionDetector_CellMotionRatio (x, y: LongInt): Double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
 with TVdgr(_Vdgr).FMotionDetector do begin
   Result := -1;
   if x > FGridXBound then Exit;
   if y > FGridYBound then Exit;
   if FInternalGrid.MotionPixelDetected[x, y] > 0 then begin
      Result := Round ((FInternalGrid.MotionPixelDetected[x, y] / FInternalGrid.MotionPixelTotal[x, y] * 10000)) / 10000;
   end
   else begin
      Result := 0;
   end;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.MotionDetector_GetCellSensitivity (x, y: LongInt; var Value: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr).FMotionDetector do begin
      Result := GetCellSensitivity (x, y, Value);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.LoadGridDialogIfNotLoaded (Owner: TComponent);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   MStream: TMemoryStream;
begin
   if not assigned (FGridDialog) then begin
      MStream := TMemoryStream.Create;
      MStream.Write (DFMData, SizeOf (DFMData));
      MStream.Position := 0;
      FGridDialog := TfrmGridDialog.CreateNew(Owner);
      MStream.ReadComponentRes(FGridDialog);
      MStream.Free;
      FGridDialog.FimgGridProc := FGridDialog.imgGrid.WindowProc;
      FGridDialog.imgGrid.WindowProc := FGridDialog.ImgGridWndProc;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TImplMotionDetector.GetCellSensitivity (x, y: word; var Value: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   if x > FGridXBound then Exit;
   if y > FGridYBound then Exit;
   Value := FInternalGrid.Grid_0_9[x, y];
   Result := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.MotionDetector_SetCellSensitivity (x, y, Value: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr).FMotionDetector do begin
      Result := SetCellSensitivity (x, y, Value);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TImplMotionDetector.SetCellSensitivity (x, y, Value: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   if x < 0 then Exit;
   if y < 0 then Exit;
   if x > FGridXBound then Exit;
   if y > FGridYBound then Exit;
   if Value > 9 then Exit;
   FInternalGrid.Grid_0_9[x, y] := Value;
   RebuildGridFromInternal;
   Result := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetMotionDetector_GlobalMotionRatio: Double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FMotionRatio;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.MotionDetector_EnumGridDialogControls (FirstControl: Boolean): TComponent;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      with FMotionDetector do begin
         LoadGridDialogIfNotLoaded (Intf);
         Result := nil;
         if FirstControl then begin
            FiEnumGridDialogControls := 0;
            Result := FGridDialog;
         end
         else begin
            if FiEnumGridDialogControls >= FGridDialog.ComponentCount then Exit;
            Result := FGridDialog.Components[FiEnumGridDialogControls];
            inc (FiEnumGridDialogControls);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.MotionDetector_ShowGridDialog;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      with FMotionDetector do begin
         LoadGridDialogIfNotLoaded (Intf);
         with FGridDialog do begin

            DlgDet := FMotionDetector;

            FMouseDown:= False;
            FMouseDownClickValue := 0;

            FindBestCurrentLevel;

            if assigned (FCurrentFrameData.PreviousFrameBitmapData.FrameBitmap) then begin
               DlgDet.FDialogBitmap.Assign (FCurrentFrameData.PreviousFrameBitmapData.FrameBitmap);
            end;

            RedrawMatricedBitmap;

            updCurrentLevel.Position := DlgDet.FCurrentLevel;

            popSetLevel.Items[DlgDet.FCurrentLevel - 1].Checked := True;

            ShowModal;
         end;
      end;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.MotionDetector_GloballyIncOrDecSensitivity (Value: integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr).FMotionDetector do GloballyIncOrDecSensitivity (Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.MotionDetector_ResetGlobalSensitivity (Value: integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr).FMotionDetector do ResetGlobalSensitivity (Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMotionDetector_Grid (Value: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   TVdgr(_Vdgr).FMotionDetector.SetMotionDetector_Grid (Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.MotionDetector_SetGridSize (x, y: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   result := TVdgr(_Vdgr).FMotionDetector.SetCellCount (x, y);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.MotionDetector_Reset;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   TVdgr(_Vdgr).FMotionDetector.FReset := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_CompareBlue: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FCompareBlue;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_CompareGreen: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FCompareGreen;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_GreyScale: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FGreyScale;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_CompareRed: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FCompareRed;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_ReduceVideoNoise: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FReduceVideoNoise;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_ReduceCPULoad: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FReduceCPULoad;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMotionDetector_ReduceCPULoad (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr).FMotionDetector do begin
      if Value < 1 then Exit;
      FReduceCPULoad := Value;
      FReset := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_MaxDetectionsPerSecond: Double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FMaxDetectionsPerSecond;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMotionDetector_MaxDetectionsPerSecond (Value: Double);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr).FMotionDetector do begin
      if Value < 0 then Exit;
      FMaxDetectionsPerSecond := Value;
      if FMaxDetectionsPerSecond > 0 then begin
         FMaxFrameTimeInterval100ns := Round (REFTIME_UNITS / FMaxDetectionsPerSecond);
      end
      else begin
         FMaxFrameTimeInterval100ns := 0;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMotionDetector_Enabled: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := TVdgr(_Vdgr).FMotionDetector.FEnabled;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMotionDetector_Enabled (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FMotionDetector.FEnabled = Value then Exit;
      FMotionDetector.FEnabled := Value;
      if FGraphType <> cs_Down then begin
         if FMotionDetector.FEnabled and (FCurrent.FrameGrabberRGBFormat > fgf_RGB24) then begin
            RefreshPreview ('scf');
         end
         else begin
            FCurrent.MotionDetectorEnabled := FMotionDetector.FEnabled;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMotionDetector_CompareBlue (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
 with TVdgr(_Vdgr).FMotionDetector do begin
   if Value = FCompareBlue then Exit;
   FCompareBlue := Value;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMotionDetector_CompareGreen (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
 with TVdgr(_Vdgr).FMotionDetector do begin
   if Value = FCompareGreen then Exit;
   FCompareGreen := Value;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMotionDetector_GreyScale (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
 with TVdgr(_Vdgr).FMotionDetector do begin
   if Value = FGreyScale then Exit;
   FGreyScale := Value;
   FChangedCompareCriterias := True;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMotionDetector_CompareRed (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
 with TVdgr(_Vdgr).FMotionDetector do begin
   if Value = FCompareRed then Exit;
   FCompareRed := Value;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMotionDetector_ReduceVideoNoise (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
 with TVdgr(_Vdgr).FMotionDetector do begin
   if Value = FReduceVideoNoise then Exit;
   FReduceVideoNoise := Value;
   FChangedCompareCriterias := True;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.SendDVCommand (DVCommand: TDVCommand): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sends DV commands to the DV camcorder
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      if FVideoRegSave[_ExtTransportAvail].b then begin
         ChangeBusyStateAndCursor (True);
         if not assigned (F_AMExtTransport) then begin
            ReinitCurrentParams (False);
            if CreateDeviceGraph then begin
               if assigned (F_VideoDevice) then begin
                  F_VideoDevice.QueryInterface (IAMExtTransport, F_AMExtTransport);
               end;
            end;
         end;
         if assigned (F_AMExtTransport) then begin
            F_AMExtTransport.Get_Mode (FCurrentFrameData.ThreadTransportOldState);
            Result := F_AMExtTransport.put_Mode (ReturnDVCommand (DVCommand)) = S_OK;
         end;
         ChangeBusyStateAndCursor (False);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.PauseRecording: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ starts the video capture
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   with TVdgr(_Vdgr) do begin
      if LogB (not FRecordingStarted, LERROR, e_recording_cannot_pause, 'not recording') then Exit;
      if LogB (FIsRecordingPaused, LERROR, e_recording_cannot_pause, 'Recording already paused') then Exit;
      if LogB (not FCurrent.RecordingCanPause, LERROR, e_pause_resume_disabled, 'RecordingCanPause property disabled') then Exit;
      FIsRecordingPaused := HoldStreaming;
      Result := FIsRecordingPaused;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.ResumeRecording: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ starts the video capture
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   with TVdgr(_Vdgr) do begin
      if LogB (FGraphType <> cs_Recording, LERROR, e_not_recording, 'not recording') then Exit;

      if (FCurrent.HoldRecording) and (FFilterState = state_Running) then begin
         ChangeGraphState (State_Paused, 'rr');
         FCurrent.HoldRecording := False;
         RecordingStartedPostProcessing;
         ControlPinByEnabled (F_ScCapturePinVideo, 'video', true);
         ControlPinByEnabled (F_ScCapturePinAudio, 'audio', true);
         ChangeGraphState (State_Running, 'rr2');
      end
      else begin
         if LogB (not FRecordingStarted, LERROR, e_recording_cannot_pause, 'not recording') then Exit;
         if LogB (not FIsRecordingPaused, LERROR, e_recording_cannot_pause, 'Recording not paused') then Exit;
         if LogB (not FCurrent.RecordingCanPause, LERROR, e_pause_resume_disabled, 'RecordingCanPause property disabled') then Exit;
         ReleaseStreaming;
         FIsRecordingPaused := False;
      end;
      Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetGlobal_AudioCompressorsCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns the audio compressors count
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := 0;
      if InitializationStatus <> ipInitialized then Exit;
      Result := _AudioCompressors.Count;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetGlobal_AudioDevicesCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns the audio input devices count
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := 0;
   if InitializationStatus <> ipInitialized then Exit;
   Result := _AudioDevices.Count;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetGlobal_VideoCompressorsCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns the number of video compressors
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := 0;
   if InitializationStatus <> ipInitialized then Exit;
   Result := _VideoCompressors.Count;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoInputs: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoRegSave[_VideoInputs].s;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoInputsCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := GetstringListCount (FVideoRegSave[_VideoInputs].s);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSizesCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := GetstringListCount (GetVideoSizes);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetRecordingHeight: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := -1;
      if IsDVSource then begin
         if NativeRecording then begin
            if FVideoRegSave[_IsDVPal].b then begin
               Result := 576;
            end
            else begin
               Result := 480;
            end;
         end;
      end;
      if Result = -1 then begin
         Result := FVideoSourceHeight;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetRecordingWidth: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := -1;
      if IsDVSource then begin
         if NativeRecording then begin
            Result := 720;
         end;
      end;
      if Result = -1 then begin
         Result := FVideoSourceWidth;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoSubtypesCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := GetstringListCount (GetVideoSubtypes);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetAudioInputs: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FAudioRegSave[_AudioInputs].s;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetAudioInputsCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TstringList;
begin
   with TVdgr(_Vdgr) do begin
      List := TstringList.Create;
      List.Text := FAudioRegSave[_AudioInputs].s;
      Result := List.Count;
      List.Free;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAudioFormat (Value: TAudioFormat);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < Low(TAudioFormat)) or (Value > High(TAudioFormat)) then Exit;
   with TVdgr(_Vdgr) do begin
      if Value = FAudioFormat then Exit;
      FAudioFormat := Value;
      if FCurrent.AudioDevice > -1 then begin
         RefreshPreview ('saf');
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoCompressor: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoCompressor;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoCompressorName : string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns the Index video compressor's name
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := '';
      if InitializationStatus <> ipInitialized then Exit;
      if FVideoCompressor >= _VideoCompressors.Count then Exit;
      Result := _VideoCompressors.DeviceName (FVideoCompressor);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAudioCompressorName: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns the Index audio compressor's name
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := '';
      if InitializationStatus <> ipInitialized then Exit;
      if FAudioCompressor >= _AudioCompressors.Count then Exit;
      Result := _AudioCompressors.DeviceName (FAudioCompressor);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoDeviceName: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns the Index video input device's name
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := '';
      if InitializationStatus <> ipInitialized then Exit;
      if FVideoDevice < 0 then Exit;
      if FVideoDevice >= _VideoDevices.Count then Exit;
      Result := _VideoDevices.DeviceName (FVideoDevice);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetAudioDeviceName: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns the Index audio input device's name
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := '';
      if InitializationStatus <> ipInitialized then Exit;
      if FAudioDevice < 0 then Exit;
      if FAudioDevice >= _AudioDevices.Count then Exit;
      Result := _AudioDevices.DeviceName (FAudioDevice);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetGlobal_VideoDevicesCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns the number of video input devices
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := 0;
   if InitializationStatus <> ipInitialized then Exit;
   Result := _VideoDevices.Count;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetTimeCodeReaderAvailable: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FVideoRegSave[_TimeCodeReaderAvail].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function FlagsValue (Auto: Boolean): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if Auto then begin
      Result := 1; { Flags_Auto }
   end
   else begin
      Result := 2; { Flags_Manual }
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVCRHorizontalLocking: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FVideoRegSave[_ANVVCRHorzLocking].i = 1;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVCRHorizontalLocking (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   IntValue: LongInt;
begin
   with TVdgr(_Vdgr) do begin

      if Value then begin
         IntValue := 1;
      end
      else begin
         IntValue := 0;
      end;

      if IntValue = FVideoRegSave[_ANVVCRHorzLocking].i then Exit;

      if assigned (F_AMAnalogVideoDecoder) then begin
         F_AMAnalogVideoDecoder.put_VCRHorizontalLocking (IntValue);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VideoQualityMin (Setting: TVideoQuality): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoQuality[Setting].Min;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VideoQualityMax (Setting: TVideoQuality): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoQuality[Setting].Max;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VideoQualityStep (Setting: TVideoQuality): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoQuality[Setting].SteppingDelta;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.VideoQualityDefault (Setting: TVideoQuality): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoQuality[Setting].Default_;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoQuality (Setting: TVideoQuality): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoQuality[Setting].Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoQualityAuto: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoRegSave[_VideoQuality_Auto].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoQualityAuto (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FVideoRegSave[_VideoQuality_Auto].b = Value then Exit;
      FVideoRegSave[_VideoQuality_Auto].b := Value;
      RestoreVideoQualitySettingsFromRegistry;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.SetVideoQuality (Setting: TVideoQuality; NewValue: LongInt) : Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := false;
      if (Setting < Low(TVideoQuality)) or (Setting > High(TVideoQuality)) then Exit;
      with FVideoQuality[Setting] do begin
         if not Available then Exit;
         if NewValue < Min then Exit;
         if NewValue > Max then Exit;
         Value := NewValue;
         Result := True;
         if assigned (F_AMVideoQuality) then begin
            F_AMVideoQuality.Set_ (LongInt (Setting), Value, AM_Flags_Manual);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.IsVideoQualitySettingAvailable (Setting: TVideoQuality): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoQuality[Setting].Available;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsCameraControlAvailable: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FVideoRegSave[_IsCameraControlAvail].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsVideoQualityAvailable: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do Result := FVideoRegSave[_IsVideoQualityAvail].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetVideoProcessingDeinterlacing: TVideoDeinterlacing;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FVideoEffects.Deinterlacing then begin
         Result := di_FullSize;
      end
      else if FTransformConfig.VideoHalfDeinterlacing then begin
         Result := di_HalfSize;
      end
      else begin
         Result := di_Disabled;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoProcessingDeinterlacing (Value: TVideoDeinterlacing);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   OldTransformConfig: Boolean;
begin
   with TVdgr(_Vdgr) do begin
      OldTransformConfig := FTransformConfig.VideoHalfDeinterlacing;
      case Value of
         di_Disabled: begin
            FVideoEffects.Deinterlacing := False;
            FTransformConfig.VideoHalfDeinterlacing := False;
         end;
         di_HalfSize: begin
            FVideoEffects.Deinterlacing := False;
            FTransformConfig.VideoHalfDeinterlacing := True;
         end;
         di_FullSize: begin
            FVideoEffects.Deinterlacing := True;
            FTransformConfig.VideoHalfDeinterlacing := False;
         end;
      end;
      EnableDisableVideoTransform;
      if FTransformConfig.VideoHalfDeinterlacing <> OldTransformConfig then begin
         RefreshPreview ('spdi');
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoProcessingBrightness (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoEffects.Brightness := Value;
      EnableDisableVideoEffects;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoProcessingContrast (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoEffects.Contrast := Value;
      EnableDisableVideoEffects;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoProcessingSaturation (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoEffects.Saturation := Value;
      EnableDisableVideoEffects;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoProcessingHue (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoEffects.Hue := Value;
      EnableDisableVideoEffects;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoProcessingGrayScale (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoEffects.GrayScale := Value;
      EnableDisableVideoEffects;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoProcessingTopDown (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoEffects.TopDown := Value;
      EnableDisableVideoEffects;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoProcessingLeftRight (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoEffects.LeftRight := Value;
      EnableDisableVideoEffects;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetVideoProcessingInvertColors (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      FVideoEffects.InvertColors := Value;
      EnableDisableVideoEffects;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMultiplexedRole: TMultiplexedRole;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FMultiplexedRole;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SeTMultiplexedRole (Value: TMultiplexedRole);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FMultiplexedRole = Value then Exit;
      FMultiplexedRole := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMultiplexedSlaveFrameRate: Double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FMultiplexedSlaveFrameRate / 100;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMultiplexedSlaveFrameRate (Value: Double);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value = (FMultiplexedSlaveFrameRate / 100) then Exit;
      if Value < 0 then Exit;
      FMultiplexedSlaveFrameRate := Round (Value * 100);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetMultiplexedSlaveID (Index: LongInt): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Index in [MULTIPLEXEDSLAVE_MINBOUND..MULTIPLEXEDSLAVE_MAXBOUND] then begin
         Result := FMultiplexedSlave[Index].UniqueID;
      end
      else begin
         Result := -1;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetMultiplexedSlaveID (Index: LongInt; Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Index in [MULTIPLEXEDSLAVE_MINBOUND..MULTIPLEXEDSLAVE_MAXBOUND] then begin
         FMultiplexedSlave[Index].UniqueID := Value;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetImageRatio: double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FVideoSourceWidth / FVideoSourceHeight;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAutoFileName (Value: TAutoFileName);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if (Value < Low(TAutoFileName)) or (Value > High(TAutoFileName)) then Exit;
   with TVdgr(_Vdgr) do begin
      if Value = FAutoFileName then Exit;
      FAutoFileName := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetAutoFilePrefix (Value: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if not IsInDesignMode then begin
         if Value = 'vidgrablog' then begin
            Log_DoLogToFile := True;
            Exit;
         end;
      end;
      if FAutoFilePrefix = Value then Exit;
      FAutoFilePrefix := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetCaptureFileExt (Value: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if FCaptureFileExt = Value then Exit;
      FCaptureFileExt := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetRecordingFileName (Value: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value <> FRecordingFileName then begin
         FRecordingFileName := Value;
         if (FGraphType = cs_Recording) and FGraphAccessAllowed then begin
            if not FCurrent.PreallocCapfileEnabled then begin
               NewCaptureFileDuringRecording;
            end
            else begin
               LogB (True, LERROR, e_failed_to_renew_recording_file, 'renew not allowed when the preallocated file is used');
            end;
         end;
         if FRecordingFileName = 'RENEW' then begin
            FRecordingFileName := '';
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetRecordingBacktimedFramesCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FRecordingBacktimedFramesCount;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetRecordingBacktimedFramesCount (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value < 0 then Exit;
      FRecordingBacktimedFramesCount := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetRecordingOnMotion_MotionThreshold: Double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FRecordingOnMotion_MotionThreshold;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetRecordingOnMotion_MotionThreshold (Value: Double);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FRecordingOnMotion_MotionThreshold := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetRecordingOnMotion_Enabled: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FRecordingOnMotion_Enabled;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetRecordingOnMotion_Enabled (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FRecordingOnMotion_Enabled := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetRecordingOnMotion_NoMotionPauseDelayMs: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FRecordingOnMotion_NoMotionPauseDelayMs;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetRecordingOnMotion_NoMotionPauseDelayMs (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value < 0 then Exit;
      FRecordingOnMotion_NoMotionPauseDelayMs := Value;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerFramePosition: Int_64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FramePosition: int64;
begin
   with TVdgr(_Vdgr) do begin
      if FGraphAccessAllowed then begin
         FramePosition := FFrameInfo_Current.FrameInfo.FrameNumber;
      end
      else begin
         FramePosition := 0;
      end;
      Result := FramePosition;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerSpeedRatio: double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPlayerSpeedRatio;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TJxdVideoGrabber.GetPlayerTrackBar: TTrackBar;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FPlayerTrackBar;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPlayerTrackBar (Value: TTrackBar);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FPlayerTrackBar := Value;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerTimePosition: Int_64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TimePosition: int64;
begin
   with TVdgr(_Vdgr) do begin
      if assigned (F_MediaSeeking) and (FFilterState = State_Paused) then begin
         F_MediaSeeking.GetCurrentPosition (TimePosition);
      end
      else begin
         TimePosition := FFrameInfo_Current.CurrentFrameTime;
      end;
      Result := TimePosition;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerDuration: Int_64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FPlayerDuration;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerFrameCount: Int_64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      Result := FPlayerFrameCount;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetPlayerFrameRate: double;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      with TVdgr(_Vdgr) do begin
         if (FPlayerDuration > 0) and (FPlayerFrameCount > 0) then begin
            Result := FPlayerFrameCount * 10000000 / FPlayerDuration;
         end
         else begin
            Result := 0;
         end;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDisplay_VideoWindowHandle: hwnd;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if assigned (FVideoWindow.FAssociatedRenderer) then begin
         Result := FVideoWindow.FAssociatedRenderer^.RenderHandle;
      end
      else begin
         Result := 0;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDualDisplay_VideoWindowHandle: hwnd;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if assigned (FVideoWindow2.FAssociatedRenderer) then begin
         Result := FVideoWindow2.FAssociatedRenderer^.RenderHandle;
      end
      else begin
         Result := 0;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDisplay_VideoHeight: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoWindow.FLongInt[vwVideoHeight];
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDisplay_VideoWidth: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoWindow.FLongInt[vwVideoWidth];
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDualDisplay_VideoHeight: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoWindow2.FLongInt[vwVideoHeight];
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDualDisplay_VideoWidth: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoWindow2.FLongInt[vwVideoWidth];
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDisplayLongIntProperties (Index: LongInt): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoWindow.GetLongIntProperties (Index);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDisplayBoolProperties (Index: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoWindow.GetBoolProperties (Index);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDisplay2LongIntProperties (Index: LongInt): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoWindow2.GetLongIntProperties (Index);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetDisplay2BoolProperties (Index: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do Result := FVideoWindow2.GetBoolProperties (Index);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetDisplayBoolProperties (Index: LongInt; Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideoWindow.SetBoolProperties (Index, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetDisplayLongIntProperties (Index: LongInt; Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideoWindow.SetLongIntProperties (Index, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetDisplay2BoolProperties (Index: LongInt; Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideoWindow2.SetBoolProperties (Index, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetDisplay2LongIntProperties (Index: LongInt; Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do FVideoWindow2.SetLongIntProperties (Index, Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TJxdVideoGrabber.GetIsHorizontalSyncLocked: Boolean;
var
   Locked: LongInt;
begin
   with TVdgr(_Vdgr) do begin
      Result := False;
      if assigned (F_AMAnalogVideoDecoder) then begin
         if F_AMAnalogVideoDecoder.Get_HorizontalLocked (Locked) = S_OK then begin
            Result := Locked = 1;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TRecordingFromBitmap.Create;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FIsValidFormat := False;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function WriteBitmapToFile (Bitmap: TBitmap; FileName: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := false;
   try
      if FileName = '' then Exit;
      Bitmap.SaveToFile (FileName);
      Result := true;
   except
     on E: Exception do;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function WriteJPEGToFile (Jpeg: TJpegImage; FileName: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := false;
   try
      if FileName = '' then Exit;
      JPeg.SaveToFile (FileName);
      Result := true;
   except
     on E: Exception do;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ReturnFormatValues (pmt: PAM_MEDIA_TYPE; var dwBitRate: dword; var AvgTimePerFrame: int64; var biWidth: LongInt; var biHeight: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      Result := False;
      case ReturnFormatType (pmt) of
         ft_VideoInfo: begin
            dwBitRate := pVideoInfoHeader(pmt^.pbFormat)^.dwBitRate;
            AvgTimePerFrame := pVideoInfoHeader(pmt^.pbFormat)^.AvgTimePerFrame;
            biWidth := abs (pVideoInfoHeader(pmt^.pbFormat)^.bmiHeader.biWidth);
            biHeight := abs (pVideoInfoHeader(pmt^.pbFormat)^.bmiHeader.biHeight);
            Result := True;
         end;
         ft_VideoInfo2: begin
            dwBitRate := pVideoInfoHeader2(pmt^.pbFormat)^.dwBitRate;
            AvgTimePerFrame := pVideoInfoHeader2(pmt^.pbFormat)^.AvgTimePerFrame;
            biWidth := abs (pVideoInfoHeader2(pmt^.pbFormat)^.bmiHeader.biWidth);
            biHeight := abs (pVideoInfoHeader2(pmt^.pbFormat)^.bmiHeader.biHeight);
            Result := True;
         end;
         ft_Mpeg1Video: begin
            dwBitRate := pMpeg1VideoInfo(pmt^.pbFormat)^.hdr.dwBitRate;
            AvgTimePerFrame := pMpeg1VideoInfo(pmt^.pbFormat)^.hdr.AvgTimePerFrame;
            biWidth := abs (pMpeg1VideoInfo(pmt^.pbFormat)^.hdr.bmiHeader.biWidth);
            biHeight := abs (pMpeg1VideoInfo(pmt^.pbFormat)^.hdr.bmiHeader.biHeight);
            Result := True;
         end;
         ft_Mpeg2Video: begin
            dwBitRate := pMpeg2VideoInfo(pmt^.pbFormat)^.hdr.dwBitRate;
            AvgTimePerFrame := pMpeg2VideoInfo(pmt^.pbFormat)^.hdr.AvgTimePerFrame;
            biWidth := abs (pMpeg2VideoInfo(pmt^.pbFormat)^.hdr.bmiHeader.biWidth);
            biHeight := abs (pMpeg2VideoInfo(pmt^.pbFormat)^.hdr.bmiHeader.biHeight);
            Result := True;
         end;
         ft_MpegCustom: begin
            { dwBitRate := pMpeg2VideoInfo(pmt^.pbFormat).hdr.dwBitRate;
            AvgTimePerFrame := pMpeg2VideoInfo(pmt^.pbFormat).hdr.AvgTimePerFrame;
            biWidth := pMpeg2VideoInfo(pmt^.pbFormat).hdr.bmiHeader.biWidth;
            biHeight := pMpeg2VideoInfo(pmt^.pbFormat).hdr.bmiHeader.biHeight;
            showmesdsage (inttostr (biheight)); }
         end;
      end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetVideoFormatBmiInfoCB_FromBitmap (VidGrab: Pointer; out pmt: PAM_MEDIA_TYPE; var CanDeleteMediaType: Boolean): HRESULT; stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   VideoInfoHeader: pVideoInfoHeader;
   Bitmap: HBitmap;
begin
   with TVdgr(VidGrab) do begin
      Result := E_FAIL;
      if FDestroying then Exit;

     with FRecordingFromBitmap do begin
      Result := S_OK;

      VideoInfoHeader := CoTaskMemAlloc (sizeof (TVideoInfoHeader));
      ZeroMemory (VideoInfoHeader, sizeOf (TVideoInfoHeader));

      pmt := CoTaskMemAlloc (sizeof (TAM_MEDIA_TYPE));
      ZeroMemory (pmt, sizeOf (TAM_MEDIA_TYPE));
      pmt^.lSampleSize:= 0;
      pmt^.bFixedSizeSamples := TRUE;
      pmt^.majortype:= MEDIATYPE_Video;
      pmt^.Subtype := MEDIASUBTYPE_RGB24;

      Bitmap := 0;

      FIsValidFormat := False;

      if assigned (Intf.FOnVideoFromBitmaps_FormatNeeded) then begin

         Intf.FOnVideoFromBitmaps_FormatNeeded (Intf, Bitmap);

         FIsValidFormat := GetObject (Bitmap, sizeof (TDibSection), @FDibSection) <> 0;

         if FIsValidFormat then begin

            SetRect (VideoInfoHeader.rcSource, 0, 0, FDibSection.dsBmih.biWidth, abs(FDibSection.dsBmih.biHeight));
            SetRect (VideoInfoHeader.rcTarget, 0, 0, FDibSection.dsBmih.biWidth, abs(FDibSection.dsBmih.biHeight));

            Windows.CopyMemory (@VideoInfoHeader.bmiHeader, @FDibSection.dsBmih, sizeof (TBitmapInfoHeader));

            pmt^.lSampleSize:= BitmapSize (@VideoInfoHeader.bmiHeader);
            case FDibSection.dsBmih.biBitCount of
               24: pmt^.Subtype := MEDIASUBTYPE_RGB24;
               32: pmt^.Subtype := MEDIASUBTYPE_RGB32;
            else
               FIsValidFormat := False;
            end;

            DeleteObject (Bitmap);
         end;
      end
      else begin
         SetRect (VideoInfoHeader.rcSource, 0, 0, 320, 240);
         SetRect (VideoInfoHeader.rcTarget, 0, 0, 320, 240);
      end;
      VideoInfoHeader.dwBitRate := 4000000;
      VideoInfoHeader.AvgTimePerFrame := 333667;

      pmt^.formattype:= FORMAT_VideoInfo;
      pmt^.pUnk := nil;
      pmt^.pbFormat := VideoInfoHeader;
      pmt^.cbFormat := sizeof (TVideoInfoHeader);

      CanDeleteMediaType := True;
     end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetSampleDataCB_FromBitmap (VidGrab: Pointer; Buffer: pByte; BufferSize: LongInt; out EndOfData: Boolean; var DataLength: LongInt): HRESULT; stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Bitmap: HBitmap;
   DibSection: TDibSection;
   Ok: Boolean;
begin
   with TVdgr(VidGrab) do begin
      if FDestroying then begin
         Result := E_FAIL;
      end
      else begin
       with FRecordingFromBitmap do begin
         Ok := False;
         EndOfData := False;
         if FIsValidFormat then begin
            if assigned (Intf.FOnVideoFromBitmaps_NextFrameNeeded) then begin
               Bitmap := 0;
               Intf.FOnVideoFromBitmaps_NextFrameNeeded (Intf, Bitmap, EndOfData);
               if GetObject (Bitmap, sizeof (TDibSection), @DibSection) <> 0 then begin
                  if LongInt (dibsection.dsBmih.biSizeImage) = BufferSize then begin
                     Windows.CopyMemory (Buffer, DibSection.dsBm.bmBits, BufferSize);
                     Ok := True;
                  end;
                  DeleteObject (Bitmap);
               end;
            end;
         end;
         if not Ok then begin
            EndOfData := True;
         end;
         if not EndOfData then begin
            if FCurrent.FrameGrabber = fg_Disabled then begin
               if (FCurrentFrameData.ThreadNewFrameNumber = -1) then begin
                  FCurrentFrameData.ThreadNewFrameNumber := 1;
               end
               else begin
                  inc (FCurrentFrameData.ThreadNewFrameNumber);
               end;
            end;
         end;
         Result := S_OK;
       end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ApplyNotificationSleepTime;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FGraphType = cs_Playback then begin
      FTaskThread.SetSleepTime (DEFAULTNOTIFICATIONSLEEPTIME);
      FCurrentFrameData.PlayerStepClockCount := Round (DEFAULTPLAYERSTEPSLEEPTIME / DEFAULTNOTIFICATIONSLEEPTIME);
   end
   else begin
      if assigned (FTaskThread) then begin
         FTaskThread.SetSleepTime (FNotificationSleepTimeUsed);
      end;
      FCurrentFrameData.PlayerStepClockCount := Round (DEFAULTPLAYERSTEPSLEEPTIME / FNotificationSleepTimeUsed);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ReturnRawFrameAsync (IsVideo: Boolean; SampleCaptureInfo: pSampleCaptureInfo);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   SampleData: TSampleData;
begin
   with FSampleInfoVideo do begin
      if Capturing then Exit;
      if Processing then Exit;
      Processing := True;
      FrameAvail := False;
      with SampleData do begin
         FrameBuffer := FSampleInfoVideo.FrameBuffer;
         FrameBufferSize := FSampleInfoVideo.FrameBufferSize;
         FrameDataLength := FSampleInfoVideo.FrameDataLength;
         FormatType := FSampleInfoVideo.FormatType;
         pFormat:= FSampleInfoVideo.pFormat;
         pbmi:= FSampleInfoVideo.pbmi;
         FrameStartTime := FSampleInfoVideo.FrameStartTime;
         FrameEndTime := FSampleInfoVideo.FrameEndTime;
      end;

      case IsVideo of
         true  : if CanInvokeEvent (TPObj(Intf.FOnSampleCapture_Video)) then Intf.FOnSampleCapture_Video (Intf, SampleData);
         false : if CanInvokeEvent (TPObj(Intf.FOnSampleCapture_Audio)) then Intf.FOnSampleCapture_Audio (Intf, SampleData);
      end;
      Processing := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.InitGlobalRegSave (GlobalRegSave: pGlobalRegSave);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: TGlobalId;
begin
   for i := low (TGlobalId) to high (TGlobalId) do begin
      GlobalRegSave^[i].t := tvNone;
   end;
   with GlobalRegSave^[_LastRecordingFileName] do begin             t:=tvString;  RegId := '_LastRecordingFileName';           s := ''      end;
   with GlobalRegSave^[_LastClipPlayed] do begin                    t:=tvString;  RegId := '_LastClipPlayed';                  s := ''      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.InitAudioRegSave (AudioRegSave: pAudioRegSave);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: TAudioId;
begin
   for i := low (TAudioId) to high (TAudioId) do begin
      AudioRegSave^[i].t := tvNone;
   end;

   with AudioRegSave^[_A_DeviceDiscovered] do begin             t:=tvBoolean;  RegId := '_DeviceDiscovered';           b := false;    end;

   with AudioRegSave^[_AUDIO_MAYNOTBESAVED] do begin            t:=tvLongInt;  RegId := 'DummyMAYNOTBESAVED';          i := MAXINT;   end;
   with AudioRegSave^[_AIsAudioCrossbarAvail] do begin          t:=tvBoolean;  RegId := 'AIsAudioCrossbarAvail';       b := false;    end;
   with AudioRegSave^[_AudioInput] do begin                     t:=tvLongInt;  RegId := 'AudioInput';                  i := 0;        end;
   with AudioRegSave^[_AudioInputBalance] do begin              t:=tvLongInt;  RegId := 'AudioInputBalance';           i := 0;        end;
   with AudioRegSave^[_AudioInputLevel] do begin                t:=tvLongInt;  RegId := 'AudioInputLevel';             i := 50000;    end;
   with AudioRegSave^[_AudioInputMono] do begin                 t:=tvBoolean;  RegId := 'AudioInputMono';              b := false;    end;
   with AudioRegSave^[_AudioInputName] do begin                 t:=tvString;   RegId := 'AudioInputName';              s := '';       end;
   with AudioRegSave^[_SpeakerVolume] do begin                  t:=tvLongInt;  RegId := 'SpeakerVolume';               i := 50000;    end;
   with AudioRegSave^[_SpeakerBalance] do begin                 t:=tvLongInt;  RegId := 'SpeakerBalance';              i := 0;        end;
   with AudioRegSave^[_AudioMute] do begin                      t:=tvBoolean;  RegId := 'AudioMute';                   b := false;    end;
   with AudioRegSave^[_AudioInputs] do begin                    t:=tvstring;   RegId := 'AudioInputs';                 s := '';       end;
   with AudioRegSave^[_AIsSoundCard] do begin                   t:=tvBoolean;  RegId := 'AIsSoundCard';                b := false;    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.InitVideoRegSave (VideoRegSave: pVideoRegSave);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: TVideoId;
begin
   for i := low (TVideoId) to high (TVideoId) do begin
      VideoRegSave^[i].t := tvNone;
   end;

   with VideoRegSave^[_DeviceDiscovered] do begin               t:=tvBoolean;  RegId := '_DeviceDiscovered';           b := false;    end;
   with VideoRegSave^[_AudioDeviceAssociated] do begin          t:=tvString;   RegId := '_AudioDeviceAssociated';      s := '';       end;
   with VideoRegSave^[_AudioInputAssociated] do begin           t:=tvLongInt;  RegId := '_AudioInputAssociated';       i := 0;        end;
   with VideoRegSave^[_AudioInputBalanceAssociated] do begin    t:=tvLongInt;  RegId := '_AudioInputBalanceAssociated';i := 0;        end;
   with VideoRegSave^[_AudioInputLevelAssociated] do begin      t:=tvLongInt;  RegId := '_AudioInputLevelAssociated';  i := 50000;    end;
   with VideoRegSave^[_AudioInputMonoAssociated] do begin       t:=tvBoolean;  RegId := '_AudioInputMonoAssociated';   b := false;    end;
   with VideoRegSave^[_AudioInputNameAssociated] do begin       t:=tvString;   RegId := '_AudioInputNameAssociated';   s := '';       end;
   with VideoRegSave^[_SpeakerVolumeAssociated] do begin        t:=tvLongInt;  RegId := '_SpeakerVolumeAssociated';    i := 50000;    end;
   with VideoRegSave^[_SpeakerBalanceAssociated] do begin       t:=tvLongInt;  RegId := '_SpeakerBalanceAssociated';   i := 0;        end;
   with VideoRegSave^[_IsVfw] do begin                          t:=tvBoolean;  RegId := '_IsVfw';                      b := false;    end;
   with VideoRegSave^[_IsAudioCrossbarAvail] do begin           t:=tvBoolean;  RegId := '_IsAudioCrossbarAvail';       b := false;    end;
   with VideoRegSave^[_IsDigitalVideoIn] do begin               t:=tvBoolean;  RegId := '_IsDigitalVideoIn';           b := false;    end;
   with VideoRegSave^[_IsDVPal] do begin                        t:=tvBoolean;  RegId := '_IsDVPal';                    b := false;    end;
   with VideoRegSave^[_IsVideoPortAvailable] do begin           t:=tvBoolean;  RegId := '_IsVideoPortAvailable';       b := false;    end;
   with VideoRegSave^[_IsVideoInterlaced] do begin              t:=tvBoolean;  RegId := '_IsVideoInterlaced';          b := false;    end;
   with VideoRegSave^[_IsTVTunerAvail] do begin                 t:=tvBoolean;  RegId := '_IsTVTunerAvail';             b := false;    end;
   with VideoRegSave^[_IsTVAudioAvail] do begin                 t:=tvBoolean;  RegId := '_IsTVAudioAvail';             b := false;    end;
   with VideoRegSave^[_IsAnalogVideoDecoderAvail] do begin      t:=tvBoolean;  RegId := '_IsAnalogVideoDecoderAvail';  b := false;    end;
   with VideoRegSave^[_IsVCRHorizontalLockingAvail] do begin    t:=tvBoolean;  RegId := '_IsVCRHorizontalLockingAvail';b := false;    end;
   with VideoRegSave^[_IsVideoCrossbarAvail] do begin           t:=tvBoolean;  RegId := '_IsVideoCrossbarAvail';       b := false;    end;

   with VideoRegSave^[_IsVideoQualityAvail] do begin            t:=tvBoolean;  RegId := '_IsVideoQualityAvail';        b := false;    end;
   with VideoRegSave^[_IsCameraControlAvail] do begin           t:=tvBoolean;  RegId := '_IsCameraControlAvail';       b := false;    end;
   with VideoRegSave^[_IsVideoControlAvail] do begin            t:=tvBoolean;  RegId := '_IsVideoControlAvail';        b := false;    end;
   with VideoRegSave^[_IsMpegStream] do begin                   t:=tvBoolean;  RegId :=  '_IsMpegStream';              b := false;    end;
   with VideoRegSave^[_VfwCaptureDialogFormat] do begin         t:=tvBoolean;  RegId := '_VfwCaptureDialogFormat';     b := false;    end;
   with VideoRegSave^[_VfwCaptureDialogSource] do begin         t:=tvBoolean;  RegId := '_VfwCaptureDialogSource';     b := false;    end;
   with VideoRegSave^[_VfwCaptureDialogDisplay] do begin        t:=tvBoolean;  RegId := '_VfwCaptureDialogDisplay';    b := false;    end;
   with VideoRegSave^[_VideoControlCaps] do begin               t:=tvLongInt;  RegId := '_VideoControlCaps';           i := 0;        end;

   with VideoRegSave^[_VIDEO_MAYNOTBESAVED] do begin            t:=tvLongInt;  RegId := 'DummyMAYNOTBESAVED';          i := MAXINT;   end;

   with VideoRegSave^[_ExtTransportAvail] do begin              t:=tvBoolean;  RegId := 'ExtTransportAvail';           b := false;    end;
   with VideoRegSave^[_TimeCodeReaderAvail] do begin            t:=tvBoolean;  RegId := 'TimeCodeReaderAvail';         b := false;    end;

   with VideoRegSave^[_VideoInput] do begin                     t:=tvLongInt;  RegId := 'VideoInput';                  i := 0;        end;
   with VideoRegSave^[_VideoInputs] do begin                    t:=tvstring;   RegId := 'VideoInputs';                 s := '';       end;
   with VideoRegSave^[_VideoInputName] do begin                 t:=tvLongInt;  RegId := 'VideoInputName';              s := '';       end;
   with VideoRegSave^[_VideoSize] do begin                      t:=tvLongInt;  RegId := 'VideoSize';                   i := 0;        end;
   with VideoRegSave^[_VideoRenderer] do begin                  t:=tvLongInt;  RegId := 'VideoRenderer';               i := 0;        end;
   with VideoRegSave^[_VideoSubtype] do begin                   t:=tvLongInt;  RegId := 'VideoSubtype';                i := 0;        end;
   with VideoRegSave^[_VideoControlMode] do begin               t:=tvLongInt;  RegId := '_VideoControlMode';           i := 0;        end;
   with VideoRegSave^[_VIDEOCROSSBARAVAIL] do begin             t:=tvBoolean;  RegId := 'VIDEOCROSSBARAVAIL';          b := false;    end;
   with VideoRegSave^[_AUDIOCROSSBARAVAIL] do begin             t:=tvBoolean;  RegId := 'AUDIOCROSSBARAVAIL';          b := false;    end;
   with VideoRegSave^[_TVChannel] do begin                      t:=tvLongInt;  RegId := 'TVChannel';                   i := 0;        end;
   with VideoRegSave^[_TVChannelFreq] do begin                  t:=tvLongInt;  RegId := 'TVChannelFreq';               i := 0;        end;
   with VideoRegSave^[_TVInputType] do begin                    t:=tvLongInt;  RegId := 'TVInputType';                 i := 0;        end;
   with VideoRegSave^[_TVConnectInput] do begin                 t:=tvLongInt;  RegId := 'TVConnectInput';              i := MAXINT;   end;
   with VideoRegSave^[_TVTuningSpace] do begin                  t:=tvLongInt;  RegId := 'TVTuningSpace';               i := 0;        end;
   with VideoRegSave^[_TVCountryCode] do begin                  t:=tvLongInt;  RegId := 'TVCountryCode';               i := 0;        end;
   with VideoRegSave^[_TVMode] do begin                         t:=tvLongInt;  RegId := 'TVMode';                      i := 0;        end;

   with VideoRegSave^[_ANVTVFormat] do begin                    t:=tvLongInt;  RegId := 'ANTVFormat';                  i := 0;        end;
   with VideoRegSave^[_ANVTVFormats] do begin                   t:=tvLongInt;  RegId := 'ANTVFormats';                 i := 0;        end;
   with VideoRegSave^[_ANVVCRHorzLocking] do begin              t:=tvLongInt;  RegId := 'ANVVCRHorzLocking';           i := 0;        end;
   with VideoRegSave^[_ANVOutputEnable] do begin                t:=tvLongInt;  RegId := 'ANVOutputEnable';             i := MAXINT;   end;
   with VideoRegSave^[_AMVideoCrossbar] do begin                t:=tvstring ;  RegId := 'AMVideoCrossbar';             s := '';       end;
   with VideoRegSave^[_AMAudioCrossbar] do begin                t:=tvstring ;  RegId := 'AMAudioCrossbar';             s := '';       end;

   with VideoRegSave^[_VideoQuality_Auto] do begin              t:=tvBoolean;  RegId := 'VideoQualityAuto';            b := true;     end;
   with VideoRegSave^[_VideoQuality_Values] do begin            t:=tvBuffer;   RegId := 'VideoQualityValues';          Data := @FVideoQuality; DataSize := sizeof (T_VideoQualitySettings); end;

   with VideoRegSave^[_CameraControl_Auto] do begin             t:=tvBoolean;  RegId := 'CameraControlAuto' ;          b := true;     end;
   with VideoRegSave^[_CameraControl_Values] do begin           t:=tvBuffer;   RegId := 'CameraControlValues ';        Data := @FCameraControl; DataSize := sizeof (T_CameraControlSettings); end;

end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ControlPinByTime (Pin: IPin; sType: String; StartTime, StopTime: int64; StartCookie: LongInt; StopCookie: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ enable / disable pin
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   StreamControl: IAMStreamControl;
   Maxtime: int64;
begin
   Maxtime := high (Int64);
   Result := false;
   if not assigned (Pin) then Exit;
   Result := true;
   if Pin.QueryInterface (IAMStreamControl, StreamControl) = S_OK then begin
      StreamControl.StopAt (@Maxtime, true, 0);
      StreamControl.StartAt (@MaxTime, 0);
      StreamControl.StopAt (@StopTime, true, StopCookie);
      StreamControl.StartAt (@StartTime, StartCookie);
      StreamControl := nil;
   end
   else begin
      LogB (True, LERROR, e_no_stream_control, 'no stream control on ' + sType + ' pin');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ControlPinByEnabled (Pin: IPin; sType: String; Enable: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ enable / disable pin
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   StreamControl: IAMStreamControl;
   t: int64;
begin
   t := high (Int64);
   Result := false;
   if not assigned (Pin) then Exit;
   Result := true;
   if Pin.QueryInterface (IAMStreamControl, StreamControl) = S_OK then begin
      if Enable then begin
         StreamControl.StopAt (@t, true, 0);
         StreamControl.StartAt (nil, 0);
      end
      else begin
         StreamControl.StartAt (@t, 0);
         StreamControl.StopAt (nil, false, 0);
      end;
      StreamControl := nil;
   end
   else begin
      LogB (True, LERROR, e_no_stream_control, 'no stream control on ' + sType + ' pin');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RemoveFilters;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ removes all the graph's filters
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pEnumFilters: iEnumFilters;
   cFetched: ULONG;
   pFilter: IBaseFilter;
   hr: HResult;
begin
   if assigned (F_GraphBuilder) then begin

      hr := F_GraphBuilder.EnumFilters(pEnumFilters);
      if (hr = S_OK) and assigned (pEnumFilters) then begin
         pEnumFilters.Reset;
         while pEnumFilters.Next(1, pFilter, @cFetched) = S_OK do begin
            DisconnectPins (pFilter);
            pFilter := nil;
         end;
         pEnumFilters:= nil;
      end;

      hr := F_GraphBuilder.EnumFilters(pEnumFilters);
      if (hr = S_OK) and assigned (pEnumFilters) then begin
         pEnumFilters.Reset;
         while pEnumFilters.Next(1, pFilter, @cFetched) = S_OK do begin
            if assigned (pFilter) then begin
               F_GraphBuilder.RemoveFilter (pFilter);
               pFilter:= nil;
            end;
            pEnumFilters.Reset;
         end;
         pEnumFilters:= nil;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.SelectIndexFromList (ListValues: String; FindValue: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
type
   TSearchType = (tsExact, tsAnywhere, tsLeft, tsRight);
var
   Done: Boolean;
   SList: TStringList;
   i: LongInt;
   Value: String;
   SearchedValue: String;
   SearchType: TSearchType;
   UpListString: String;
begin
   Result := -1;
   Value := Uppercase (Trim (FindValue));
   if length (Value) = 0 then Exit;
   SearchType := tsExact;
   SearchedValue := '';
   if length (Value) > 2 then begin
      if (Value[1] = '*') and (Value[length(Value)] = '*') then begin
         SearchType := tsAnyWhere;
         SearchedValue := copy (Value, 2, length(Value) - 2);
      end;
   end;
   if SearchedValue = '' then begin
      if length(Value) > 1 then begin
         if Value[1] = '*' then begin
            SearchType := tsRight;
            SearchedValue := copy (Value, 2, length(Value) - 1);
         end
         else if Value[length(Value)] = '*' then begin
            SearchType := tsLeft;
            SearchedValue := copy (Value, 1, length(Value) - 1);
         end;
      end;
   end;
   if SearchedValue = '' then begin
      SearchType := tsExact;
      SearchedValue := Value;
   end;

   SList := TStringList.Create;
   SList.Text := ListValues;
   i := 0;
   Done := False;
   while not Done do begin
      if i >= SList.Count then begin
         Done := True;
      end
      else begin
         UpListString := UpperCase (SList[i]);
         case SearchType of
            tsExact     : Done := SearchedValue = UpListString;
            tsAnywhere  : Done := pos (SearchedValue, UpListString) > 0;
            tsLeft      : Done := Copy (UpListString, 1, length(SearchedValue)) = SearchedValue;
            tsRight     : Done := Copy (UpListString, length(UpListString) - length(SearchedValue) + 1, length(SearchedValue)) = SearchedValue;
         end;
         if Done then begin
            Result := i;
         end
         else begin
            inc (i);
         end;
      end;
   end;
   SList.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessOverlayColorKey;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   ColorKeyOk: Boolean;
   ColorKey: TColorKey;
begin
   if Intf.ColorKeyEnabled then begin
      if not assigned (F_Overlay) then Exit;
      ColorKeyOk := False;
      if assigned (F_Overlay) then begin
         if not FColorKeysDefault then begin
            ColorKey.KeyType := CK_INDEX or CK_RGB;
            ColorKey.PaletteIndex := 0;
            ColorKey.LowColorValue := FColorKeyLow;
            ColorKey.HighColorValue := FColorKeyHigh;
            F_Overlay.SetColorKey(@ColorKey);
         end;

         if F_Overlay.GetColorKey(ColorKey) = S_OK then begin
            if CanInvokeEvent (TPObj(Intf.FOnColorKeyChange)) then Intf.FOnColorKeyChange (Intf, ColorKey.LowColorValue);
            ColorKeyOk := True;
         end;
      end;
      if not ColorKeyOk then begin
         LogB (not ColorKeyOk, LWARNING, w_cannot_use_color_key, 'cannot use color key');
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.VideoWindowNotify (Sender: TObject; Notification: TVideoWindowNotify; Param: LongWord);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   IsActivated: Boolean;
   function FullscreenRunning: Boolean;
   begin
      Result := TVideoWindow(Sender).FBool[vwFullScreen] and not (FGraphType in [cs_Down, cs_Reencoding]);
   end;
begin
   IsActivated := Boolean(Param);
   case Notification of
      vwActive: begin
         if IsActivated then begin
            if not TVideoWindow(Sender).FActivated then begin
               RefreshPreview ('vwn');
            end;
         end;
      end;
      vwVideoPortEnabled: begin
         if not FVideoRegSave[_IsVideoPortAvailable].b then Exit;
      end;
      vwEmbedded: begin
         if FullscreenRunning then Exit;
      end;
      vwMouseMovesWindow: begin
         if IsActivated then begin
            TVideoWindow(Sender).FPrevMousePoint.x := -1; { restarts old mousedown position }
         end;
         if FullscreenRunning then Exit;
      end;
      vwAutoSize: begin
         if FullscreenRunning then Exit;
      end;
      vwLocation: begin
         if FullscreenRunning then Exit;
      end;
   end;
   AssociateVideoWindows;
   ResizeVideoWindows (True);
   ShowDisplays;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ConnectPins (FilterOut: IBaseFilter; PinOutName: String; PinOutIsSub: Boolean; FilterIn: IBaseFilter; PinInName: string; PinInIsSub: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   PinOut, PinIn: IPin;
begin
   Result := False;
   if RetrievePinByName (PINDIR_OUTPUT, FilterOut, PinOutName, PinOutIsSub, PinOut) then begin
      if RetrievePinByName (PINDIR_INPUT, FilterIn, PinInName, PinInIsSub, PinIn) then begin
         Result := Connect (PinOut, PinIn);
      end;
   end;
   if assigned (PinOut) then PinOut := nil;
   if assigned (PinIn) then PinIn := nil;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ConnectPins (var PinOut: IPin; FilterIn: IBaseFilter; PinInName: string; PinInIsSub: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   PinIn: IPin;
begin
   Result := False;
   if RetrievePinByName (PINDIR_INPUT, FilterIn, PinInName, PinInIsSub, PinIn) then begin
      Result := Connect (PinOut, PinIn);
   end;
   if assigned (PinIn) then PinIn := nil;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ConnectPins (FilterOut: IBaseFilter; PinOutName: String; PinOutIsSub: Boolean; PinIn: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   PinOut: IPin;
begin
   Result := False;
   if RetrievePinByName (PINDIR_OUTPUT, FilterOut, PinOutName, PinOutIsSub, PinOut) then begin
      Result := Connect (PinOut, PinIn);
   end;
   if assigned (PinOut) then PinOut := nil;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AudioInputsCount: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FilterPin: IPin;
   Pins: IEnumPins;
   cFetched: ULONG;
   Direction: TPin_Direction;
   Done: Boolean;
begin
   Result := 0;
   if not assigned (F_AudioDevice) then Exit;
   if F_AudioDevice.EnumPins(Pins) <> S_OK then Exit;
   if not assigned (Pins)  then Exit;
   Done := false;
   while not Done do begin
      if Pins.Next(1, FilterPin, @cFetched) = S_OK then begin
         if assigned (FilterPin) then begin
            FilterPin.QueryDirection (Direction);
            if Direction = PINDIR_INPUT then begin
               inc (Result);
            end;
            FilterPin := nil;
         end;
      end
      else begin
         Done := True;
      end;
   end;
   Pins := nil;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CanInvokeEvent (Event: TPObj): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := assigned (Event) and Intf.HandleAllocated and (not FDestroying);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CanInvokeEventWithoutHandle (Event: TPObj): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := assigned (Event) and (not FDestroying);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CanAssociateAudioAndVideoDevices: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := FAssociateAudioAndVideoDevices and (FCurrent.VideoDevice <> -1);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ExtractVideoSizeFromFormatCoded (s: String; var x: LongInt; var y: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   p: LongInt;
begin
   p := pos ('x', s);
   if p > 1 then begin
      x := StrToIntDef (Trim (Copy (s, 1, p - 1)), 0);
      y := StrToIntDef (Trim (Copy (s, p + 1, MAXINT)), 0);
      Result := (x > 0) and (y > 0);
   end
   else begin
      Result := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.DecodeVideoSizeUsingDefault (FormatIndex: LongInt; var x, y : LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Idx: LongInt;
begin
   Result := False;
   if (FormatIndex = -1) and (FVideoSizes.Count > 0) and (FVideoRegSave[_VideoSize].i = 0) then begin
      if FVideoRegSave[_IsAnalogVideoDecoderAvail].b then begin
         if FVideoRegSave[_ANVTVFormat].i < $10 then begin // NTSC
            Idx := FVideoSizes.IndexOf (' 352x240');
            if Idx > 0 then begin
               x := 352;
               y := 240;
               Result := True;
            end;
         end
         else begin
            Idx := FVideoSizes.IndexOf (' 352x288');
            if Idx > 0 then begin
               x := 352;
               y := 288;
               Result := True;
            end;
         end;
      end
      else begin
      end;
   end;
   if not Result then begin
      Result := DecodeVideoSize (FormatIndex, x, y);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.DecodeVideoSize (FormatIndex: LongInt; var x, y : LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ decodes the x and y sizes of the format coded in a longword
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;

   x:= -1;
   y:= -1;

   if FVideoSizes.Count = 0 then begin
      x := 320;
      y := 240;
      Exit;
   end;

   if FormatIndex = -1 then begin
      if FVideoRegSave[_VideoSize].i >= FVideoSizes.Count then begin
         FVideoRegSave[_VideoSize].i := 0;
      end;
      if (FPreferredVideoWidth > 0) and (FPreferredVideoHeight > 0) then begin
         FormatIndex := SearchNearestVideoSizeUsingRatio (FPreferredVideoWidth, FPreferredVideoHeight);
      end
      else begin
         FormatIndex := FVideoRegSave[_VideoSize].i;
      end;
   end;

   if IsDVSource then begin
      Result := True;
      if FVideoRegSave[_IsDVPal].b then begin
          case FormatIndex of
             0: begin   x := 360;   y := 288;  end;
             1: begin   x :=  88;   y :=  72;  end;
             2: begin   x := 180;   y := 144;  end;
             3: begin   x := 360;   y := 288;  end;
             4: begin   x := 720;   y := 576;  end;
          else
             Result := False;
          end;
      end
      else begin
          case FormatIndex of
             0: begin   x := 360;   y := 240;  end;
             1: begin   x :=  88;   y :=  60;  end;
             2: begin   x := 180;   y := 120;  end;
             3: begin   x := 360;   y := 240;  end;
             4: begin   x := 720;   y := 480;  end;
          else
             Result := False;
          end;
      end;
   end
   else begin
      Result := ExtractVideoSizeFromFormatCoded (FVideoSizes[FormatIndex], x, y);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CheckFileNameExtension (FileName: string; FileNameType: TAutoFileNameType): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   iPoint: LongInt;
   iSlash: LongInt;
   Ext: string;
   FullPath, Path: string;
   Continue: Boolean;
begin
   case FileNameType of
      afn_BmpFile: begin
         Ext := 'bmp';
      end;
      afn_JpegFile: begin
         Ext := 'jpg';
      end;
   else
      Ext := '';
   end;

   Continue := true;
   FullPath := ExpandFileName (FileName);
   iSlash := LastDelimiter ('\', FullPath);
   if iSlash > 0 then begin
      Path := Copy (FullPath, 1, iSlash - 1);
      if not DirectoryExists (Path) then begin
         ForceDirectories2 (Path);
         if not DirectoryExists (Path) then begin
            LogB (true, LERROR, e_failed_to_create_directory, 'cannot create directory: ' + Path);
            Continue := false;
            Result := '';
         end;
      end;
   end;
   if Continue then begin
      iPoint := LastDelimiter ('.', FileName);
      iSlash := LastDelimiter ('\', FileName);
      if (iSlash = 0) or (iSlash < iPoint) then begin
         if iPoint = 0 then begin
            Result := FileName + '.' + Ext;
         end
         else begin
            if lowercase (Copy (FileName, iPoint + 1, MAXINT)) <> Ext then begin
               Result := Copy (FileName, 1, iPoint) + Ext;
            end
            else begin
               Result := FileName;
            end;
         end;
      end
      else begin
         Result := FileName + '.' + Ext;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RouteAudioRelatedPin;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   OutBound, InBound: LongInt;
   PhysicalType: LongInt;
   PinIndexRelated: LongInt;
   AudioOut, VideoOut: LongInt;
   RoutedToVideoOut: LongInt;
   i: LongInt;
   Done: Boolean;
   hr: HResult;
begin
   if not assigned (F_AMVideoCrossbar) then Exit;
   if F_AMVideoCrossbar.Get_PinCounts (OutBound, InBound) <> S_OK then Exit;
   if OutBound = 0 then Exit;

   AudioOut := -1;
   VideoOut := -1;
   i := 0;
   Done := false;
   while not Done do begin
      if i > OutBound then begin
         Done := true;
      end
      else begin
         if F_AMVideoCrossbar.get_CrossbarPinInfo (false, i, PinIndexRelated, PhysicalType) = S_OK then begin
            if PhysicalType < PhysConn_Audio_Tuner then begin
               if VideoOut = -1 then begin
                  VideoOut := i;
               end;
            end
            else begin
               if AudioOut = -1 then begin
                  AudioOut := i;
               end;
            end;
         end;
         inc (i);
         if (i > OutBound) or ((AudioOut <> -1) and (VideoOut <> -1)) then begin
            Done := true;
         end;
      end;
   end;

   if F_AMVideoCrossbar.Get_IsRoutedTo (VideoOut, RoutedToVideoOut) = S_OK then begin
      if F_AMVideoCrossbar.get_CrossbarPinInfo (true, RoutedToVideoOut, PinIndexRelated, PhysicalType) = S_OK then begin
         hr := F_AMVideoCrossbar.Route (AudioOut, PinIndexRelated);
         LogH (hr, LWARNING, w_cannot_route_audio_crossbar, 'cannot route audio crossbar');
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure LoadFrameData (FrameData: pFrameData; FrameBitmapData: pFrameBitmapData);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FrameData^.Bitmap := FrameBitmapData^.FrameBitmap;
   FrameData^.FrameNumber := FrameBitmapData^.FrameBitmapNumber;
   Windows.CopyMemory (@FrameData^.DibSection, @FrameBitmapData^.FrameDibSection, sizeof (TDibSection));
   FrameData^.FrameTime :=  FrameBitmapData^.FrameBitmapTime;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.PerformDetectMotion (var MustReturnFrame: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   CaptureFrame: Boolean;
   MotionDetected: Boolean;
   FrameData: TFrameData;
   MaxDetectionsPerSecond: int64;
begin
   if FMotionDetector.FMaxFrameTimeInterval100ns > 0 then begin
      if FMotionDetector.FLatestFrameTime <> -1 then begin
         if (FFrameInfo_Current.FrameBitmapData.FrameBitmapTime - FMotionDetector.FLatestFrameTime) < FMotionDetector.FMaxFrameTimeInterval100ns then begin
            Exit;
         end;
     end;
   end;

   MaxDetectionsPerSecond := FFrameInfo_Current.FrameBitmapData.FrameBitmapTime - FCurrentFrameData.PreviousFrameBitmapData.FrameBitmapTime;
   if MaxDetectionsPerSecond > 0 then begin
      if MaxDetectionsPerSecond < FMotionDetector.FMaxDetectionsPerSecond then Exit;
   end;

   if assigned (FCurrentFrameData.PreviousFrameBitmapData.FrameBitmap) then begin
      MotionDetected := FMotionDetector.DetectMotion (@FCurrentFrameData.PreviousFrameBitmapData.FrameDibSection, @FFrameInfo_Current.FrameBitmapData.FrameDibSection, FFrameInfo_Current.FrameBitmapData.FrameBitmapTime);
      FCurrentFrameData.PreviousFrameBitmapData.FrameBitmap.Free;
   end
   else begin
      MotionDetected := FMotionDetector.DetectMotion (nil, @FFrameInfo_Current.FrameBitmapData.FrameDibSection, FFrameInfo_Current.FrameBitmapData.FrameBitmapTime);
   end;
   Windows.CopyMemory (@FCurrentFrameData.PreviousFrameBitmapData, @FFrameInfo_Current.FrameBitmapData, sizeof (TFrameBitmapData));
   FFrameInfo_Current.FrameBitmapData.FrameBitmap := nil;

   CaptureFrame := False;

   if FFrameInfo_Current.FrameInfo.FrameNumber > 3 then begin
      LoadFrameData (@FrameData, @FCurrentFrameData.PreviousFrameBitmapData);
      if MotionDetected then begin
         if CanInvokeEvent (TPObj(Intf.FOnMotionDetected)) then Intf.FOnMotionDetected (Intf, FMotionDetector.FMotionRatio, FrameData, CaptureFrame);
      end
      else begin
         if CanInvokeEvent (TPObj(Intf.FOnMotionNotDetected)) then Intf.FOnMotionNotDetected (Intf, FrameData, CaptureFrame);
      end;
      if FCurrent.RecordingOnMotion_Enabled then begin
         if MotionDetected and (FMotionDetector.FMotionRatio >= FCurrent.RecordingOnMotion_MotionThreshold) then begin
            FCurrentFrameData.RecordingOnMotionNextTickCountTime := GetTickCount + FCurrent.RecordingOnMotion_NoMotionPauseDelayMs;
            if FIsRecordingPaused then begin
               Intf.ResumeRecording;
            end;
         end
         else begin
            if not FIsRecordingPaused then begin
               if GetTickCount > FCurrentFrameData.RecordingOnMotionNextTickCountTime then begin
                  FIsRecordingPaused := HoldStreaming;
               end;
            end;
         end;
      end;
   end;
   if (not MustReturnFrame) and (CaptureFrame) then begin
      MustReturnFrame := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.DoGrabFrame (UsedBurstType: TFrameCaptureDest; FileName: string; IsCaptureFrameTo: Boolean; MustReturnFrame: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Jpeg: TJPEGImage;
   FrameData: TFrameData;
   DummyIndex: LongInt;
   FrameDataBitmap: TBitmap;
begin
   Result := false;
   if not assigned (FGrabberHandlers[gh_RGB].Control) then Exit;

   with FGrabberHandlers[gh_RGB].Control^ do begin
     ZeroMemory (@FrameData, sizeof (TFrameData));
     if assigned (FFrameInfo_Current.FrameBitmapData.FrameBitmap) then begin
         FrameDataBitmap := TBitmap.Create;
         if FFrameCaptureZoomSize = 100 then begin
            FrameDataBitmap.Assign (FFrameInfo_Current.FrameBitmapData.FrameBitmap);
         end
         else begin
            FrameDataBitmap.Width := Round (FVideoSourceWidth * FFrameCaptureZoomSize / 100);
            FrameDataBitmap.Height := Round (FVideoSourceHeight * FFrameCaptureZoomSize / 100);
            FrameDataBitmap.Canvas.StretchDraw(Rect (0, 0, FrameDataBitmap.Width, FrameDataBitmap.Height), FFrameInfo_Current.FrameBitmapData.FrameBitmap);
         end;

         FrameData.FrameNumber := FFrameInfo_Current.FrameBitmapData.FrameBitmapNumber;
         FrameData.FrameTime := FFrameInfo_Current.FrameBitmapData.FrameBitmapTime;

         FrameData.Bitmap := FrameDataBitmap;

         if GetObject (FrameDataBitmap.Handle, sizeof (TDibSection), @FrameData.DibSection) <> 0 then begin
            if (not FCurrent.FrameCaptureWithoutOverlay) and FCurrent.MotionDetectorEnabled then begin
               ProcessFrameOverlays (@FFrameInfo_Current, FrameDataBitmap.Handle, @FrameData.DibSection);
            end;
         end;

         if MustReturnFrame then begin

            case UsedBurstType of
               fc_TBitmap: begin
                  Result := True;
               end;
               fc_BmpFile:  begin
                  if FileName = '' then begin
                     Filename := AutoGenerateFileName (afn_BmpFile, 'bmp', DummyIndex);
                  end
                  else begin
                     Filename := CheckFileNameExtension (FileName, afn_BmpFile);
                  end;
                  if WriteBitmapToFile (FrameDataBitmap, FileName) then begin
                     if IsCaptureFrameTo then begin
                        FLast_CaptureFrameTo_FileName := FileName;
                     end
                     else begin
                        FLast_BurstFrameCapture_FileName := FileName;
                     end;
                     Result := true;
                  end;
               end;

               fc_JpegFile: begin
                  if FileName = '' then begin
                     Filename := AutoGenerateFileName (afn_JpegFile, 'jpg', DummyIndex);
                  end
                  else begin
                     Filename := CheckFileNameExtension (FileName, afn_JpegFile);
                  end;
                  Jpeg := TJpegImage.Create;
                  Jpeg.Assign (FrameDataBitmap);
                  Jpeg.Performance := FJPEGPerformance;
                  Jpeg.CompressionQuality := FJPEGQuality;
                  if FJPEGProgressiveDisplay then begin
                     Jpeg.ProgressiveDisplay := true;
                     Jpeg.ProgressiveEncoding := true;
                  end;

                  if WriteJpegToFile (Jpeg, FileName) then begin
                     if IsCaptureFrameTo then begin
                        FLast_CaptureFrameTo_FileName := FileName;
                     end
                     else begin
                        FLast_BurstFrameCapture_FileName := FileName;
                     end;
                     Result := true;
                  end;
                  Jpeg.Free;
               end;
            end;

            if CanInvokeEvent (TPObj(Intf.FOnFrameCaptureCompleted)) then begin

               case UsedBurstType of
                  fc_TBitmap: begin
                     Intf.FOnFrameCaptureCompleted (Intf, FrameData, fc_TBitmap, '', true);
                  end;
                  fc_JpegFile: begin
                     Intf.FOnFrameCaptureCompleted (Intf, FrameData, fc_JpegFile, FileName, Result);
                  end;
                  fc_BmpFile:  begin
                     Intf.FOnFrameCaptureCompleted (Intf, FrameData, fc_BmpFile, FileName, Result);
                  end;
               end;
               //FlushMessages; ZZZZZ
            end;
         end;
         FrameDataBitmap.Free;
     end;
   end;
   if Result then begin
      FCurrentFrameData.OneShotCaptureSuccess:= True;
      FCurrentFrameData.OneShotCaptureWaiting:= False;
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessGrabFrames;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   MustReturnFrame: Boolean;
begin
   with FCurrentFrameData do begin
      if assigned (FFrameInfo_Current.FrameBitmapData.FrameBitmap) then begin
         if ReturnOneShotFrame then begin
            ReturnOneShotFrame := False;
            DoGrabFrame (OneShotDest, OneShotFileName, true, True);
         end
         else if ReturnBurstModeFrame then begin
            ReturnBurstModeFrame := False;
            DoGrabFrame (FBurstType, '', false, FBurstMode);
         end;

         if FCurrent.MotionDetectorEnabled then begin
            PerformDetectMotion (MustReturnFrame);
         end;
      end;

      if FSampleInfoVideo.FrameAvail then begin
         ReturnRawFrameAsync (true, @FSampleInfoVideo);
      end;
      if FSampleInfoAudio.FrameAvail then begin
         ReturnRawFrameAsync (false, @FSampleInfoAudio);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.SaveFrameGrabberMediaType;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FilterIn: IPin;
begin
   if assigned (FFrameGrabberMediaType) then begin
      DeleteMediaType (FFrameGrabberMediaType);
      FFrameGrabberMediaType := nil;
   end;
   if not assigned (FGrabberHandlers[gh_RGB].Grabber) then Exit;
   if Failed (F_CaptureGraphBuilder2.FindPin (FGrabberHandlers[gh_RGB].Grabber, PINDIR_INPUT, nil, nil, False, 0, FilterIn)) then Exit;
   FFrameGrabberMediaType := CoTaskMemAlloc (sizeof (TAM_MEDIA_TYPE));
   if Succeeded (FilterIn.ConnectionMediaType (FFrameGrabberMediaType)) then begin
      DistributeSlaveMediaType;
   end
   else begin
      CoTaskMemFree (FFrameGrabberMediaType);
      FFrameGrabberMediaType := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetVdgrFromID (CurrentVdgr: TVdgr; ID: LongInt): TVdgr;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Vdgr: TVdgr;
   iNext: LongInt;
   Done: Boolean;
begin
   Result := nil;
   if ID < 0 then Exit;
   if not assigned (_SyncManager) then Exit;
   Vdgr := _SyncManager.FVideoGrabberList.First (iNext);
   Done := not assigned (Vdgr);
   while not Done do begin
      if CurrentVdgr <> Vdgr  then begin
         if Vdgr.FUniqueID = ID then begin
            Result := Vdgr;
            Done := True;
         end;
      end;
      if not Done then begin
         Vdgr := _SyncManager.FVideoGrabberList.Next (iNext);
         Done := not assigned (Vdgr);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.LinkSlaves: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
   VdgrSlave: TVdgr;
begin
   Result := False;
   if FMultiplexedRole <> mr_MultiplexedMaster then Exit;
   for i := MULTIPLEXEDSLAVE_MINBOUND to MULTIPLEXEDSLAVE_MAXBOUND do begin
       if FMultiplexedSlave[i].UniqueId <> -1 then begin
          VdgrSlave := GetVdgrFromID (Self, FMultiplexedSlave[i].UniqueId);
          if assigned (VdgrSlave) then begin
             FMultiplexedSlave[i].Vdgr := VdgrSlave;
             VdgrSlave.FMultiplexedMaster.Vdgr := Self;
             VdgrSlave.FSlaveMultiplexedData.pCxMediaType_OwnedByMaster := FFrameGrabberMediaType;
          end;
      end;
   end;
   Result := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.DistributeSlaveMediaType: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
begin
   Result := False;
   if FMultiplexedRole <> mr_MultiplexedMaster then Exit;
   if not assigned (FFrameGrabberMediaType) then Exit;
   for i := MULTIPLEXEDSLAVE_MINBOUND to MULTIPLEXEDSLAVE_MAXBOUND do begin
       if assigned (FMultiplexedSlave[i].Vdgr) then begin
          FMultiplexedSlave[i].Vdgr.FSlaveMultiplexedData.pCxMediaType_OwnedByMaster := FFrameGrabberMediaType;
      end;
   end;
   Result := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.SlavesNeedMotionDetection: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
begin
   Result := False;
   if FMultiplexedRole <> mr_MultiplexedMaster then Exit;
   for i := MULTIPLEXEDSLAVE_MINBOUND to MULTIPLEXEDSLAVE_MAXBOUND do begin
       if assigned (FMultiplexedSlave[i].Vdgr) then begin
          if FMultiplexedSlave[i].Vdgr.FMotionDetector.FEnabled then begin
             Result := True;
          end;
      end;
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ProcessNotifyFrame: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FrameInfo: TFrameInfo;
begin
         Result := False;
         if FDestroying then Exit;
         if FFilterState = state_Stopped then Exit;

         FNotifyingFrame := True;

         if CanInvokeEvent (TPObj(Intf.FOnFrameProgress)) then begin
            Windows.CopyMemory (@FrameInfo, @FFrameInfo_Current.FrameInfo, sizeof (TFrameInfo));
            Intf.FOnFrameProgress (Intf, FrameInfo);
         end;

         if not FFrameGrabberSynchrone then begin
            ProcessGrabFrames;
         end;

         if FCurrentFrameData.MustPausePreview then begin
            FCurrentFrameData.MustPausePreview := False;
            if FCurrent.VideoSource = vs_VideoCaptureDevice then begin
               ChangeGraphState (State_Paused, 'cspnf');
            end
            else begin
               ChangeGraphState (State_Stopped, 'cspnf');
            end;
         end;

         if assigned (FPlayerTrackBar) then begin
            if FGraphType  = cs_Playback then begin
               if (FCurrentFrameData.PlayerTrackBarNewPosition = -1) and (FFilterState = state_Running) then begin
                  FPlayerTrackBar.Position := FFrameInfo_Current.FrameInfo.FrameNumber;
               end
               else begin
                  if FCurrentFrameData.PlayerTrackBarNewPositionSet then begin
                     FCurrentFrameData.PlayerTrackBarNewPosition := -1;
                  end
                  else begin
                     FCurrentFrameData.PlayerTrackBarNewPositionSet := True;
                  end;
               end;
            end;
         end;

         FNotifyingFrame := False;

         Result := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ProcessPlayerNewPosition (Position: int64): int64;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Stop: int64;
   NewPosition: int64;
begin
   Result := 0;
   if FGraphType <> cs_Playback then Exit;
   if FCurrent.Networkstreaming <> ns_Disabled then Exit;
   if not assigned (F_MediaSeeking) then Exit;
   with FCurrentFrameData do begin
      SettingNewPosition := True;

      Stop := high(int64);
      NewPosition := Position;

      if NewPosition < 0 then begin
         NewPosition := 0;
      end;
      if NewPosition >= (FPlayerDuration - PlayerFrameInterval) then begin
         NewPosition := (FPlayerDuration - PlayerFrameInterval);
      end;

      if assigned (FPlayerTrackBar) then begin
         FPlayerTrackBar.Position := Round (NewPosition / PlayerFrameInterval) + 1;
      end;

      FFrameInfo_Current.PlayerNewPosition := NewPosition;
      F_MediaSeeking.SetPositions (@NewPosition, AM_SEEKING_AbsolutePositioning or AM_SEEKING_ReturnTime, @Stop, AM_SEEKING_AbsolutePositioning);

      Result := NewPosition;
      SettingNewPosition := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessNotifyEvent;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   NotifyEndOfStream: Boolean;
begin
   if FRaiseDeviceLost then begin
      FRaiseDeviceLost := false;
      PostCommand (WMDeviceLost);
   end;

   if FRaiseReencodingStreamControlStopped then begin
      FRaiseReencodingStreamControlStopped := False;
      FRaiseEndOfStream := True; // ativated just below
   end;

   if FRaiseGraphError then begin
      FRaiseGraphError := false;
      if FGraphType = cs_Recording then begin
         LogB (true, LERROR, e_graph_error, 'graph error while recording');
      end
      else begin
         LogB (true, LERROR, e_graph_error, 'graph error while previewing');
      end;
      PostStopGraphMessage;
   end;

   if FRaiseDiskFull then begin
      FRaiseDiskFull := False;
      FRecordingStarted := False; // OnRecordingCompleted Success will return "false"
      PostStopGraphMessage;
      if CanInvokeEvent (TPObj(Intf.FOnDiskFull)) then Intf.FOnDiskFull (Intf);
   end;

   if FRaiseBacktimedFramesCountReached then begin
      FRaiseBacktimedFramesCountReached := False;
      if CanInvokeEvent (TPObj(Intf.FOnBacktimedFramesCountReached)) then Intf.FOnBacktimedFramesCountReached (Intf);
   end;

   if FRaisePlayerStartBuffering then begin
      FRaisePlayerStartBuffering := False;
      if CanInvokeEvent (TPObj(Intf.FOnPlayerBufferingData)) then Intf.FOnPlayerBufferingData (Intf, True);
   end;

   if FRaisePlayerEndBuffering then begin
      FRaisePlayerEndBuffering := False;
      if CanInvokeEvent (TPObj(Intf.FOnPlayerBufferingData)) then Intf.FOnPlayerBufferingData (Intf, False);
   end;

   if FRaiseEndOfStream then begin
      FRaiseEndOfStream := False;
      NotifyEndOfStream := False;
      if FGraphType = cs_Reencoding then begin
         FReencodeOrRecopyDataSucceeded := True;
         PostStopGraphMessage;
      end
      else begin
         if FGraphType = cs_Playback then begin
            FCurrentFrameData.PlayerEndOfStreamReached := True;
            DoPausePlayer (False);
            NotifyEndOfStream := True;
         end
         else if (FVideoSource <> vs_VideoCaptureDevice) and (not FVideoFromImages_RepeatIndefinitely) then begin
            ProcessStopGraph;
            NotifyEndOfStream := True;

         end;
         if NotifyEndOfStream then begin
            if CanInvokeEvent (TPObj(Intf.FOnPlayerEndOfStream)) then Intf.FOnPlayerEndOfStream (Intf);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessNotifyDVCommandCompleted;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if CanInvokeEvent (TPObj(Intf.FOnDVCommandCompleted)) then Intf.FOnDVCommandCompleted (Intf, FCurrentFrameData.DVCommandState, GetVCRStateText (FCurrentFrameData.DVCommandState));
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure DrawShape (Dc: HDC; Shape: TShape);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   OldBrush: HBRUSH;
   OldPen: HPEN;
   XShape, YShape, WShape, HShape, SShape: LongInt;
begin
   if not assigned (Shape) then Exit;
   if not Shape.Enabled then Exit;

   OldBrush := SelectObject (Dc, TShapeOverlay (Shape).Brush.Handle);
   OldPen := SelectObject (Dc, TShapeOverlay (Shape).Pen.Handle);

   with TShapeOverlay (Shape) do begin
         XShape := Left;
         YShape := Top;
         WShape := Width - Pen.Width + 1;
         HShape := Height - Pen.Width + 1;
         if Pen.Width = 0 then begin
            Dec(WShape);
            Dec(HShape);
         end;
         if WShape < HShape then begin
            SShape := WShape;
         end
         else begin
            SShape := HShape;
         end;
         if Shape in [stSquare, stRoundSquare, stCircle] then begin
            Inc(XShape, (WShape - SShape) div 2);
            Inc(YShape, (HShape - SShape) div 2);
            WShape := SShape;
            HShape := SShape;
         end;
         case Shape of
            stRectangle, stSquare      : Rectangle(Dc, XShape, YShape, XShape + WShape, YShape + HShape);
            stRoundRect, stRoundSquare : RoundRect(Dc, XShape, YShape, XShape + WShape, YShape + HShape, SShape div 4, SShape div 4);
            stCircle, stEllipse        : Ellipse(Dc, XShape, YShape, XShape + WShape, YShape + HShape);
         end;
   end;

   SelectObject(Dc,OldPen);
   SelectObject(Dc,OldBrush);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ExtractTimeInfo (CurrentFrameInfo: pCurrentFrameInfo);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with CurrentFrameInfo^ do begin
      if FGraphType = cs_Playback then begin
         FrameInfo.FrameNumber := CurrentFrameNumber;
         FrameInfo.FrameTime := CurrentFrameTime;
      end
      else begin
         FrameInfo.FrameNumber := CurrentFrameNumber - FCurrentFrameData.InitialFrameNumber;
         FrameInfo.FrameTime := CurrentFrameTime - FCurrentFrameData.InitialFrameTime;
      end;
      if FGraphType = cs_Recording then begin
         FRecordingDuration := FrameInfo.FrameTime;
      end;
      FrameInfo.SampleTime_TotalHs   := FrameInfo.FrameTime div 100000;
      FrameInfo.SampleTime_TotalSec  := FrameInfo.SampleTime_TotalHs div 100;
      FrameInfo.SampleTime_Hs        := FrameInfo.SampleTime_TotalHs mod 100;
      FrameInfo.SampleTime_TotalMin  := FrameInfo.SampleTime_TotalSec div 60;
      FrameInfo.SampleTime_Sec       := FrameInfo.SampleTime_TotalSec mod 60;
      FrameInfo.SampleTime_Hour      := FrameInfo.SampleTime_TotalMin div 60;
      FrameInfo.SampleTime_Min       := FrameInfo.SampleTime_TotalMin mod 60;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessFrameTime (CurrentFrameInfo: pCurrentFrameInfo; StartTime: int64);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with CurrentFrameInfo^ do begin
    if FGraphType = cs_Playback then begin
       if FFilterState = State_Running then begin
          F_MediaSeeking.GetCurrentPosition(StartTime);
          if FPlayerSpeedRatio = 1 then begin
             CurrentFrameTime := StartTime;
          end
          else begin
             CurrentFrameTime := StartTime;
          end;
       end
       else begin
          if FPlayerSpeedRatio = 1 then begin
             CurrentFrameTime := PlayerNewPosition;
          end
          else begin
             CurrentFrameTime := PlayerNewPosition;
          end;
       end;
       CurrentFrameNumber := Round (CurrentFrameTime / FCurrentFrameData.PlayerFrameInterval) + 1;
    end
    else begin
      if not FGetTimeFromClock then begin
         FCurrentFrameData.RealFrameTime := StartTime;
      end
      else begin
         if assigned (F_ReferenceClock) then F_ReferenceClock.GetTime(FCurrentFrameData.RealFrameTime);
      end;

      if FCurrentFrameData.InitialFrameTime = -1 then begin
         FCurrentFrameData.InitialFrameTime := FCurrentFrameData.RealFrameTime;
         FCurrentFrameData.InitialFrameNumber := CurrentFrameNumber;
         FCurrentFrameData.InitialDroppedCount := FFrameInfo_Current.FrameInfo.DroppedFrameCount;
      end;

      if not FCurrentFrameData.AVIFrameCapturePaused then begin
         inc (CurrentFrameNumber);
         if FCurrentFrameData.PausedFrameTime > 0 then begin
            CurrentFrameTime := FCurrentFrameData.RealFrameTime - FCurrentFrameData.PausedFrameTime;
         end
         else begin
            CurrentFrameTime := FCurrentFrameData.RealFrameTime;
         end;
      end;
    end;
   end;
   ExtractTimeInfo (CurrentFrameInfo);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.PlayerTrackBarChange (Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FCurrent.Networkstreaming <> ns_Disabled then Exit;
   if FFilterState <> State_Paused then Exit;
   if Intf.GetInFrameProgressEvent then Exit; { to avoid loopback troubles if tbrPlayerProgress.Position is set from the FrameProgess event }
   if FFrameGrabber <> fg_Disabled then begin
      if  FCurrentFrameData.PlayerPausedType <> ppt_None then Exit;
   end;
   if TTrackBar(Sender).Position = FCurrentFrameData.PlayerTrackBarNewPosition then Exit;
   FCurrentFrameData.PlayerTrackBarNewPositionSet := False;
   FCurrentFrameData.PlayerTrackBarNewPosition := TTrackBar(Sender).Position;
   PostCommand (WMPlayerSetTrackBarPosition);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.SetPlayer_FramePosition (Value: Int64);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not FPlayerCanSeek then Exit;
   if not FGraphAccessAllowed then Exit;

   if Value < 1 then begin
      Value := 1;
   end;
   ProcessPlayerNewPosition ((Value - 1) * FCurrentFrameData.PlayerFrameInterval);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.SetPlayer_TimePosition (Value: Int64);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FCurrentFrameData.SettingNewPosition then Exit;
   if not FGraphAccessAllowed then Exit;
   if Value < 0 then Exit;
   if not FPlayerCanSeek then Exit;
   if Value = FFrameInfo_Current.CurrentFrameTime then Exit;
   ProcessPlayerNewPosition (Value);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
Procedure TVdgr.SetNeedFrameOverlayDC;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FNeedFrameOverlayDC := (FShapeOverlayList.Count> 0) or FShapeOverlayEnabled or FTextOverlayEnabled or assigned (Intf.FOnFrameOverlayUsingDC);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function DoEncodeTime(Hour, Min, Sec, MSec: Word; var Time: TDateTime): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
  Result := False;
  if (Hour < 24) and (Min < 60) and (Sec < 60) and (MSec < 1000) then
  begin
    Time := ((Hour * 3600000) + (Min * 60000) + (Sec * 1000) + MSec) / MSecsPerDay;
    Result := True;
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function DoEncodeDVDate (Year, Month, Day: Word; var Date: TDateTime): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   I: LongInt;
   DayTable: PDayTable;
begin
   Result := True;
   DayTable := @MonthDays[IsLeapYear(Year)];
   if Month <> 0 then begin { date already checked }
      for I := 1 to Month - 1 do begin
         inc (Day, DayTable^[I]);
      end;
      I := Year - 1;
      Date := (I * 365) + (I div 4) - (I div 100) + (I div 400) + Day - DateDelta;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.GETDVDateTime (CurrentFrameInfo: pCurrentFrameInfo; var DVDateTime: TDateTime): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Time: TDateTime;
   Date: TDateTime;
begin
   Result := False;
   if not CurrentFrameInfo^.FrameInfo.DVDateTime.IsAvailable then Exit;
   with CurrentFrameInfo^.FrameInfo.DVDateTime do begin
      Result := DoEncodeTime (Hour, Minute, Second, 0, Time) and DoEncodeDVDate (Year, Month, Day, Date);
      if Result then begin
         if Date >= 0 then begin
            DVDateTime := Date + Time;
         end
         else begin
            DVDateTime := Date - Time;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessFrameOverlays (CurrentFrameInfo: pCurrentFrameInfo; Bitmap: HBitmap; Dib: pDibSection);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   VideoHdr: TVideoHdr;

   procedure PrepareVideoHdr;
   begin
      ZeroMemory (@VideoHdr, sizeof (TVideoHdr));
      VideoHdr.lpData := Dib^.dsBm.bmBits;
      VideoHdr.dwBufferLength:= Dib^.dsBmih.biSizeImage;
      VideoHdr.dwBytesUsed := Dib^.dsBmih.biSizeImage;
      if CurrentFrameInfo^.FrameInfo.FrameTime >= 0 then begin
         VideoHdr.dwTimeCaptured := Round (CurrentFrameInfo^.FrameInfo.FrameTime / 10000);
      end
      else begin
         VideoHdr.dwTimeCaptured := 0;
      end;
   end;
begin
   if FDestroying then Exit;

   if FNeedFrameOverlayDC then begin
      DrawOverBitmap (CurrentFrameInfo, Bitmap);
   end;

   if CanInvokeEvent (TPObj(Intf.FOnFrameOverlayUsingDIB)) then Intf.FOnFrameOverlayUsingDIB (Intf, CurrentFrameInfo^.FrameInfo, Dib);
   if CanInvokeEvent (TPObj(Intf.FOnFrameOverlayUsingVIDEOHDR)) then begin
      PrepareVideoHdr;
      Intf.FOnFrameOverlayUsingVIDEOHDR (Intf, CurrentFrameInfo^.FrameInfo, VideoHdr);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.DrawOverBitmap (CurrentFrameInfo: pCurrentFrameInfo; Bitmap: HBITMAP);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   OldFont: HFONT;
   OldBitmap: HBITMAP;
   OldTextColor, OldBkColor, OldBkMode: LongInt;
   Writtenstring: string;
   Done: Boolean;
   FrameStartTimestring: string;
   FrameStartTimestringSet: Boolean;
   i: LongInt;
   SystemTime: TSystemTime;
   TextOverlayRect: TRect;
   VarStackSelector: TVarParseText;
   CompatibleDC: HDC;
   DateTime: TDateTime;
begin
   with FCurrentFrameData do begin
      with CurrentFrameInfo^ do begin
          CompatibleDc := CreateCompatibleDc (0);
          OldBitmap := SelectObject (CompatibleDc, Bitmap);

          if (OldBitmap <> 0) and (oldbitmap <> GDI_ERROR) then begin

             if FShapeOverlayEnabled then begin
                if assigned (FShapeOverlay) then begin
                   DrawShape (CompatibleDc, FShapeOverlay);
                end;
             end;
             for i := 0 to FShapeOverlayList.Count - 1 do begin
                DrawShape (CompatibleDc, FShapeOverlayList[i]);
             end;

             if FTextOverlayEnabled then begin
                with FTextOverlayData[FTextOverlayDataInUse] do begin
                   if not Assigning then begin
                      Processing := True;
                      Writtenstring := '';
                      FrameStartTimestringSet := false;

                      i := 0;
                      Done := false;
                      while not Done do begin
                         if i = iStack then begin
                            Done := true;
                         end
                         else if i = MAXSTACKARRAY then begin
                            Done := true;
                         end
                         else begin
                            VarStackSelector := VarStack[i];
                            case VarStackSelector of
                               ptTimeCode: begin
                                  Writtenstring := Writtenstring + TextStack[i];
                                  if FrameInfo.DVTimeCode.IsAvailable then begin
                                     Writtenstring := Writtenstring + Format ('%.2u:%.2u:%.2u:%.2u', [FrameInfo.DVTimeCode.Hour, FrameInfo.DVTimeCode.Min, FrameInfo.DVTimeCode.Sec, FrameInfo.DVTimeCode.Ff]);
                                  end;
                               end;
                               ptCurrentFrameNumber: begin
                                  Writtenstring := Writtenstring + TextStack[i];
                                  Writtenstring := Writtenstring + IntToStr (FrameInfo.FrameNumber);
                               end;
                               ptTime100Ns: begin
                                  Writtenstring := Writtenstring + TextStack[i];
                                  if not FrameStartTimestringSet then begin
                                     FrameStartTimestring := IntToStr (FrameInfo.FrameTime);
                                     FrameStartTimestringSet := true;
                                  end;
                                  Writtenstring := Writtenstring + FrameStartTimestring;
                               end;
                               ptTimeSec: begin
                                  Writtenstring := Writtenstring + TextStack[i];
                                  Writtenstring := Writtenstring + Format ('%d.%.2d', [FrameInfo.SampleTime_TotalSec, FrameInfo.SampleTime_Hs]);
                               end;
                               ptFullTime: begin
                                  Writtenstring := Writtenstring + TextStack[i];
                                  Writtenstring := Writtenstring + Format ('%.2d:%.2d:%.2d %.2d', [FrameInfo.SampleTime_Hour, FrameInfo.SampleTime_Min, FrameInfo.SampleTime_Sec, FrameInfo.SampleTime_Hs]);
                               end;
                               ptSysTime: begin
                                  GetLocalTime(SystemTime);
                                  Writtenstring := Writtenstring + FormatDateTime (TextStack[i], SystemTimeToDateTime(SystemTime));
                               end;
                               ptDVTime: begin
                                  if GetDVDateTime (CurrentFrameInfo, DateTime) then begin
                                     Writtenstring := Writtenstring + FormatDateTime (TextStack[i], DateTime);
                                  end;
                               end;
                            else
                               Writtenstring := Writtenstring + TextStack[i];
                               if VarStackSelector in [ptCustom0..ptCustom9] then begin
                                  Writtenstring := Writtenstring + FTextOverlayCustomVars[Ord (VarStackSelector) - Ord(ptCustom0)];
                               end;
                            end;
                         end;
                         inc (i);
                      end;
                   end;

                   SetRect (TextOverlayRect, FTextOverlayLeft, FTextOverlayTop, FTextOverlayRight, MAXINT);

                   if FTextOverlayTransparent then begin
                      OldBkMode := SetBkMode(CompatibleDc,TRANSPARENT);
                      OldBkColor := -1;
                   end
                   else begin
                      OldBkMode := SetBkMode(CompatibleDc,OPAQUE);
                      OldBkColor := SetBkColor(CompatibleDc, FTextOverlayBkColor);
                   end;

                   OldTextColor := SetTextColor(CompatibleDc, FTextOverlayFont.Color);
                   OldFont := SelectObject(CompatibleDc, FTextOverlayFont.Handle);

                   case FTextOverlayAlign of
                      tf_Left  : DrawText (CompatibleDc, PChar(Writtenstring), Length(Writtenstring), TextOverlayRect, DT_NOCLIP or DT_WORDBREAK or DT_TOP or DT_LEFT);
                      tf_Center: DrawText (CompatibleDc, PChar(Writtenstring), Length(Writtenstring), TextOverlayRect, DT_NOCLIP or DT_WORDBREAK or DT_TOP or DT_CENTER);
                      tf_Right : DrawText (CompatibleDc, PChar(Writtenstring), Length(Writtenstring), TextOverlayRect, DT_NOCLIP or DT_WORDBREAK or DT_TOP or DT_RIGHT);
                   end;

                   if FTextOverlayTransparent then begin
                      SetBkMode (CompatibleDc, OldBkMode);
                   end
                   else begin
                      SetBkMode (CompatibleDc, OldBkMode);
                      SetBkColor (CompatibleDc, OldBkColor);
                   end;

                   SetTextColor(CompatibleDc, OldTextColor);
                   SelectObject(CompatibleDc,OldFont);
                   Processing := False;
                end;
             end;
          end;

          DrawingOverFramesDxDc := CompatibleDc;
          DrawingOverFrames := True;
          if CanInvokeEvent (TPObj(Intf.FOnFrameOverlayUsingDC)) then Intf.FOnFrameOverlayUsingDC (Intf, FrameInfo, CompatibleDc);
          DrawingOverFrames := False;

          SelectObject (CompatibleDc, OldBitmap);
          DeleteDC (CompatibleDc);
          GdiFlush;
         end;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure GrabberProcessRGBFrame (GrabberControl: pGrabberControl; StartTime: int64; EndTime: int64; pSample: IMediaSample; DataLength: LongInt; DxBitmap: HBitmap; FDxDc: HDC; DxDibData: pDibData); stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Ok: Boolean;
   OldBitmap: HBITMAP;
   OldBitmap2: HBITMAP;
   BitmapBits: pointer;
   i: LongWord;
   CompatibleDC: HDC;
   CaptureFrame: Boolean;
   CanNotifyFrame: Boolean;
   CurrentFrameInfo: pCurrentFrameInfo;

begin
   Ok := False;
   CanNotifyFrame := False;
   with TVdgr (GrabberControl^.Component) do begin
       if FDestroying then Exit;
       with FCurrentFrameData do begin
              if not FGraphAccessAllowed then Exit;
              if DxBitmap = 0 then Exit;
              try
                 FProcessingRGBFrame := True;
                 Windows.CopyMemory (@GrabberControl^.Effects, @FVideoEffects, sizeof (TVideoEffects));

                 CurrentFrameInfo := @FFrameInfo_Grabber;

                 if FGraphType = cs_Playback then begin
                    FFrameInfo_Grabber.PlayerNewPosition := FFrameInfo_Current.PlayerNewPosition;
                 end;

                 ProcessFrameTime (CurrentFrameInfo, StartTime);

                 //ReadTimeCode (@FFrameInfo_Grabber); NO, SLOWS DOWN AT 2-3 FPS ON SOME PLATFORMS





                 CanNotifyFrame := (not NewFrameAvailable) and GrabberControl^.CanCaptureAndNotifyFrame;
                 CaptureFrame := False;
                 if CanNotifyFrame then begin
                    if FBurstMode then begin
                       CaptureFrame := FBurstInterval = 0;
                       if not CaptureFrame then begin
                          if FCurrent.BurstInterval = 0 then begin
                             CaptureFrame := True;
                            FCurrent.BurstInterval := FBurstInterval;
                           end
                          else begin
                             dec (FCurrent.BurstInterval);
                          end;
                       end;
                       if CaptureFrame then begin
                          if FBurstCount > 0 then begin
                             if FCurrent.BurstCount = 0 then begin
                                FBurstMode := False;
                             end
                             else begin
                                dec (FCurrent.BurstCount);
                                ReturnBurstModeFrame := True;
                             end;
                          end
                          else begin
                             ReturnBurstModeFrame := True;
                          end;
                       end;
                    end;
                    if not CaptureFrame then begin
                       CaptureFrame := FCurrent.MotionDetectorEnabled or ReturnOneShotFrame or ReturnBurstModeFrame or RequestLastFrame or (FGraphType = cs_Playback);
                    end;

                    if RequestLastFrame then begin
                       CaptureFrame := True;
                       RequestLastFrame := False;
                       LastFrameAvailable := True;
                       if FGraphType in [cs_Preview, cs_Recording] then begin
                          MustPausePreview := True;
                       end;
                    end;
                 end;

                 if (not FCurrent.FrameCaptureWithoutOverlay) and (not FCurrent.MotionDetectorEnabled) then begin
                    ProcessFrameOverlays (CurrentFrameInfo, DxBitmap, @DxDibData.Dib_Section);
                 end;

                 if CanNotifyFrame then begin
                    if FCurrent.MotionDetectorEnabled or CaptureFrame then begin
                     if assigned (FFrameGrabberMediaType) then begin
                       CurrentFrameInfo^.FrameBitmapData.FrameBitmap := TBitmap.Create;
                       CurrentFrameInfo^.FrameBitmapData.FrameBitmap.Width := pVideoInfoHeader (FFrameGrabberMediaType^.pbFormat)^.bmiHeader.biWidth;
                       CurrentFrameInfo^.FrameBitmapData.FrameBitmap.Height := abs (pVideoInfoHeader (FFrameGrabberMediaType^.pbFormat)^.bmiHeader.biHeight);
                       CurrentFrameInfo^.FrameBitmapData.FrameBitmap.Handle := CreateDIBSection (FDxDc, PBitmapInfo (@pVideoInfoHeader (FFrameGrabberMediaType^.pbFormat).bmiHeader)^, DIB_RGB_COLORS, BitmapBits, 0, 0);
                       if CurrentFrameInfo^.FrameBitmapData.FrameBitmap.Handle <> 0 then begin
                          GetObject (CurrentFrameInfo^.FrameBitmapData.FrameBitmap.Handle, Sizeof (TDibSection), @CurrentFrameInfo^.FrameBitmapData.FrameDibSection);
                          Windows.CopyMemory (BitmapBits, DxDibData.pBase, DataLength);
                          CurrentFrameInfo^.FrameBitmapData.FrameBitmapNumber := CurrentFrameInfo^.FrameInfo.FrameNumber;
                          CurrentFrameInfo^.FrameBitmapData.FrameBitmapTime := CurrentFrameInfo^.FrameInfo.FrameTime;
                       end;
                     end;
                    end;
                    EnterCriticalSection (FTransmitFrameInfoSection);
                    Windows.CopyMemory (@FFrameInfo_Transmit, @FFrameInfo_Grabber, sizeof (TCurrentFrameInfo));
                    CurrentFrameInfo^.FrameBitmapData.FrameBitmap := nil; // passed, now must not to be freed in FFrameInfo_Grabber
                    LeaveCriticalSection (FTransmitFrameInfoSection);
                 end;


                 if FCurrent.FrameCaptureWithoutOverlay or ((not FCurrent.FrameCaptureWithoutOverlay) and (FCurrent.MotionDetectorEnabled)) then begin
                    ProcessFrameOverlays (CurrentFrameInfo, DxBitmap, @DxDibData.Dib_Section);
                 end;

                 if FGraphType = cs_Reencoding then Exit;

                 if FRecordingBacktimedFramesCount > 0 then begin
                    if FRecordingBacktimedFramesArray.Count < LongInt (FRecordingBacktimedFramesCount) then begin
                       FRecordingBacktimedFramesArrayIndex := FRecordingBacktimedFramesArray.Add (Pointer (0));
                    end
                    else begin
                       inc (FRecordingBacktimedFramesArrayIndex);
                       if FRecordingBacktimedFramesArrayIndex >= FRecordingBacktimedFramesCount then begin
                          FRecordingBacktimedFramesArrayIndex := 0;
                       end;
                    end;
                    if HBITMAP (FRecordingBacktimedFramesArray[FRecordingBacktimedFramesArrayIndex]) <> 0 then begin
                       DeleteObject (HBITMAP (FRecordingBacktimedFramesArray[FRecordingBacktimedFramesArrayIndex]));
                    end;
                    BitmapBits := nil;
                    FRecordingBacktimedFramesArray[FRecordingBacktimedFramesArrayIndex] := Pointer(CreateDIBSection (FDxDc, PBitmapInfo (@DxDibData.Dib_Section.dsBmih)^, DIB_RGB_COLORS, BitmapBits, 0, 0));
                    if HBITMAP(FRecordingBacktimedFramesArray[FRecordingBacktimedFramesArrayIndex]) <> 0 then begin
                       Windows.CopyMemory (BitmapBits, DxDibData.pBase, DataLength);
                    end;
                    if FRecordingBacktimedFramesArray.Count >= LongInt (FRecordingBacktimedFramesCount) then begin
                       i := FRecordingBacktimedFramesArrayIndex + 1; { next }
                       if i >= FRecordingBacktimedFramesCount then begin
                          i := 0;
                       end;
                       if HBITMAP(FRecordingBacktimedFramesArray[i]) <> 0 then begin
                          { DisplayDc := GetDC (0); }
                          OldBitmap := SelectObject (FDxDc, DxBitmap);
                          CompatibleDc := CreateCompatibleDc (FDxDc);
                          OldBitmap2 := SelectObject (CompatibleDc, HBITMAP(FRecordingBacktimedFramesArray[i]));
                          BitBlt (FDxDc, 0, 0, DxDibData.Dib_Section.dsBmih.biWidth, abs(DxDibData.Dib_Section.dsBmih.biHeight), CompatibleDc, 0, 0, SRCCOPY);
                          SelectObject (CompatibleDc, OldBitmap2);
                          SelectObject (FDxDc, OldBitmap);
                          DeleteDC (CompatibleDc);
                          { ReleaseDc (0, DisplayDc); }
                          DeleteObject (HBITMAP(FRecordingBacktimedFramesArray[i]));
                          FRecordingBacktimedFramesArray[i] := Pointer(0);
                          if not FRaiseBacktimedFramesCountReachedDone then begin
                             FRaiseBacktimedFramesCountReachedDone := True;
                             FRaiseBacktimedFramesCountReached := True;
                              if FGraphAccessAllowed then PostCommand (WMProcessNotifyEvent);
                          end;
                       end;
                    end;
                 end;

                 Ok := True;

              finally
                 GdiFlush;

                 if Ok then begin
                    if FFrameGrabberSynchrone then begin
                       ProcessGrabFrames;
                    end;
                    if FGraphAccessAllowed and CanNotifyFrame then begin
                       NewFrameAvailable := True;
                    end;
                 end;
                 FProcessingRGBFrame := False;
              end;
           end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function NoSignalDetected (pImage: pByte; RGBSize: LongWord; ImageWidth, ImageHeight: LongWord): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
   BorderSpacing = 10;
   BorderSpacing2 = 20;

   function TestLine (Line: LongWord): Boolean;
   var
      FirstLinePixel: LongWord;

      function TestPixel (Column: LongWord): Boolean;
      var
         pPixel: LongWord;
      begin
         pPixel := FirstLinePixel + (BorderSpacing * RGBSize);
         Result := (pTBgr(pPixel)^[Rc] = $00) and (pTBgr(pPixel)^[Gc] = $00) and (pTBgr(pPixel)^[Bc] = $C0);
      end;
   begin
      FirstLinePixel := LongWord (pImage) + (LongWord (ImageHeight - Line) * LongWord (ImageWidth) * RGBSize);
      Result := TestPixel (BorderSpacing) and TestPixel (ImageWidth shr 1) and TestPixel (ImageWidth - BorderSpacing);
   end;
begin
   if (ImageWidth < (BorderSpacing2)) or (ImageHeight < (BorderSpacing2)) then begin
      Result := False;
   end
   else begin
      Result := TestLine (BorderSpacing) and TestLine (ImageHeight shr 1) and TestLine (ImageHeight - BorderSpacing);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure GrabberProcessRGBFrameMultiplexed (GrabberControl: pGrabberControl; StartTime: int64; EndTime: int64; pSample: IMediaSample; DataLength: LongInt; DxBitmap: HBitmap; FDxDc: HDC; DxDibData: pDibData); stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pData: pByte;

   Slave: TVdgr;
   MultiplexedFrameId: Byte;
   CanProcessFrame: Boolean;

begin
   with TVdgr (GrabberControl^.Component) do begin
      with FGrabberHandlers[gh_RGB].Control^ do begin
         with FCurrentFrameData do begin

              Windows.CopyMemory (@Effects, @FVideoEffects, sizeof (TVideoEffects));

              if not assigned (FGrabberHandlers[gh_RGB].Control) then Exit;
              if not FGraphAccessAllowed then Exit;
              if DxBitmap = 0 then Exit;

              try


                 ProcessFrameTime (@FFrameInfo_Grabber, StartTime);


                 pSample.GetPointer (pData);
                 MultiplexedFrameId := pData^;
                 if not (MultiplexedFrameId in [MULTIPLEXEDSLAVE_MINBOUND..MULTIPLEXEDSLAVE_MAXBOUND]) then begin
                    MultiplexedFrameId := MULTIPLEXEDSLAVE_MINBOUND;
                 end;


                 case DxDibData.Dib_Section.dsBmih.biBitCount of
                    24: begin
                       CanProcessFrame := not NoSignalDetected (DxDibData.Dib_Section.dsBm.bmBits, 3, DxDibData.Dib_Section.dsBmih.biWidth, abs(DxDibData.Dib_Section.dsBmih.biHeight));
                    end;
                    32: begin
                       CanProcessFrame := not NoSignalDetected (DxDibData.Dib_Section.dsBm.bmBits, 4, DxDibData.Dib_Section.dsBmih.biWidth, abs(DxDibData.Dib_Section.dsBmih.biHeight));
                    end;
                 else
                    CanProcessFrame := True;
                 end;

                 if CanProcessFrame then begin
                    Slave := FMultiplexedSlave[MultiplexedFrameId].Vdgr;
                    if assigned (Slave) then begin
                       if Slave.FSlaveMultiplexedData.CanCreateLastFrame then begin
                          Slave.FSlaveMultiplexedData.CanCreateLastFrame := False;
                          GetMem (Slave.FSlaveMultiplexedData.LastFrameData, DataLength);
                          Windows.CopyMemory (Slave.FSlaveMultiplexedData.LastFrameData, DxDibData.Dib_Section.dsBm.bmBits, DataLength);
                          Slave.FSlaveMultiplexedData.CanAccessLastFrame := True;
                       end;
                    end;
                 end;
              finally
                 GdiFlush;
              end;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessGraphNotify;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ receives the media events sent by the graph.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
 var
   EventCode, Param1, Param2: LongInt;
   Done: Boolean;
begin
      Done := false;
      while not Done do begin
         if not assigned (F_MediaEventEx) then begin
            Done := true;
         end
         else begin
            if F_MediaEventEx.GetEvent (EventCode, Param1, Param2, 0) <> S_OK then begin
               Done := true;
            end
            else begin
               case EventCode of
                  EC_PAUSED: begin
                     if FGraphType in [cs_Recording, cs_Reencoding] then begin
                        if not CheckFreeDiskSpace (FRealRecordingFileName) then begin
                           if FGraphAccessAllowed then begin
                              FRaiseDiskFull := true;
                              PostCommand (WMProcessNotifyEvent);
                           end;
                        end;
                     end;
                  end;

                  EC_DEVICE_LOST: begin
                     if FGraphAccessAllowed then begin
                        FRaiseDeviceLost := true;
                        PostCommand (WMProcessNotifyEvent);
                     end;
                  end;

                  EC_VIDEO_SIZE_CHANGED: begin
                     ResizeVideoWindows (True);
                  end;

                  EC_ERRORABORT: begin
                     if FGraphType in [cs_Recording, cs_Reencoding] then begin
                        if not CheckFreeDiskSpace (FRealRecordingFileName) then begin
                           if FGraphAccessAllowed then begin
                              FRaiseDiskFull := true;
                              PostCommand (WMProcessNotifyEvent);
                           end;
                        end;
                     end;
                  end;

                  EC_BUFFERING_DATA: begin
                     if Boolean (Param1) then begin
                        FRaisePlayerStartBuffering := True;
                        PostCommand (WMProcessNotifyEvent);
                     end
                     else begin
                        FPlayerBufferingData := False;
                        FRaisePlayerEndBuffering := True;
                        PostCommand (WMProcessNotifyEvent);
                     end;
                  end;

                  EC_STREAM_CONTROL_STARTED: begin
                  end;

                  EC_STREAM_CONTROL_STOPPED: begin
                     FRaiseReencodingStreamControlStopped := True;
                     PostCommand (WMProcessNotifyEvent);
                  end;

                  EC_COMPLETE: begin
                     FRaiseEndOfStream := True;
                     PostCommand (WMProcessNotifyEvent);
                  end;

                  EC_STEP_COMPLETE: begin
                  end;

                  $43: begin { network source }
                     FPlayerBufferingData := True;
                  end;
               end;
               if assigned (F_MediaEventEx) then F_MediaEventEx.FreeEventParams (EventCode, Param1, Param2);
            end;
         end;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ChangeDVResolution (DVDecFilter: IBaseFilter);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the DV resolution of the DVDec Filter
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   DVDecProp: IIPDVDec;
   IntfDVRgb219: IDVRGB219;
   CurrentFormat: string;
   displayPix: LongInt;
   FormatIndex: LongInt;
begin
   try
      if DVDecFilter.QueryInterface (IIPDVDec, DVDecProp) <> S_OK then Exit;
      if FVideoSizes.Count = 0 then begin
          WriteLog (nil, sRed, 'ERROR: NO FORMATS');
          Exit;
      end;
      if FVideoRegSave[_VideoSize].i >= FVideoSizes.Count then begin
         FVideoRegSave[_VideoSize].i := 0;
         LogB (FVideoSizes.Count > 0, LERROR, e_index_out_of_range, 'DV VideoSize index out of range, index 0 used instead');
      end;

      if (FPreferredVideoWidth > 0) and (FPreferredVideoHeight > 0) then begin
         FormatIndex := SearchNearestVideoSizeUsingRatio (FPreferredVideoWidth, FPreferredVideoHeight);
      end
      else begin
         FormatIndex := FVideoRegSave[_VideoSize].i;
      end;

      CurrentFormat := trim (FVideoSizes[FormatIndex]);

      DisplayPix := DVRESOLUTION_HALF;

      if       CurrentFormat = 'dc'      then DisplayPix := DVRESOLUTION_DC
       else if CurrentFormat = 'quarter' then DisplayPix := DVRESOLUTION_QUARTER
       else if CurrentFormat = 'half'    then DisplayPix := DVRESOLUTION_HALF
       else if CurrentFormat = 'full'    then DisplayPix := DVRESOLUTION_FULL;

      DVDecProp.put_IPDisplay(DisplayPix);
      if DVDecFilter.QueryInterface (IDVRGB219, IntfDVRgb219) = S_OK then begin
         if assigned (IntfDVRgb219) then begin
            IntfDVRgb219.SetRGB219 (FDVRgb219);
         end;
      end;
  finally
     if assigned (DVDecProp) then DVDecProp := nil;
     if assigned (IntfDVRgb219) then IntfDVRgb219 := nil;
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.CreateDisplayForm (Renderer: pRenderer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with Renderer^ do begin
       if not assigned (Display) then begin
          Display := TDisplayForm.CreateNew (Intf);
          Display.TVGOwner := Self;
          Display.CreateWnd;
          Display.Visible := False;
          Display.FormStyle := fsNormal;
          Display.HorzScrollBar.Visible := false;
          Display.VertScrollBar.Visible := false;
          SetWindowLong(Display.Handle, GWL_STYLE, GetWindowLong(Display.Handle, GWL_STYLE) and not WS_CAPTION);
          Display.OnClick := OnDisplayFormClick;
          Display.OnDblClick := OnDisplayFormDblClick;
          Display.OnKeyUp := OnDisplayFormKeyUp;
          Display.OnKeyPress := OnDisplayFormKeyPress;
          Display.OnMouseMove := OnDisplayFormMouseMove;
          Display.OnMouseDown := OnDisplayFormMouseDown;
          Display.OnMouseUp := OnDisplayFormMouseUp;
          Display.Left := 10;
          Display.Top := 10;
          Display.Width := FVideoSourceWidth;
          Display.Height := FVideoSourceHeight;
          Display.BorderStyle := bsSingle;
          Display.BorderStyle := bsNone;
          Display.AssociatedRenderer := Renderer;
          Display.FOldWndProc := Display.WindowProc;
          Display.WindowProc := Display.NewWndProc;
       end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.OnDisplayFormClick (Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if CanInvokeEvent (TPObj(Intf.FOnClick)) then Intf.FOnClick (Intf);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.OnDisplayFormDblClick (Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if CanInvokeEvent (TPObj(Intf.FOnDblClick)) then Intf.FOnDblClick (Intf);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.OnDisplayFormKeyPress (Sender: TObject; var Key: Char);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TDisplayForm(Sender).AssociatedRenderer^ do begin
      if assigned (FAssociatedWindow) then begin
         FAssociatedWindow.FKeyPressed := Key;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.MouseEventIsMovingWindow (Renderer: pRenderer): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with Renderer^ do begin
      if assigned (FAssociatedWindow) then begin
         with FAssociatedWindow do begin
            Result := FBool[vwMouseMovesWindow] and (not FBool[vwFullScreen]) and (not IsWindowEmbedded (FAssociatedWindow));
         end
      end
      else begin
         Result := False;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.OnDisplayFormKeyUp (Sender: TObject; var Key: Word; Shift: TShiftState);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TDisplayForm(Sender).AssociatedRenderer^ do begin
      if assigned (FAssociatedWindow) then begin
         with FAssociatedWindow do begin
            if CanInvokeEvent (TPObj(Intf.FOnKeyPress)) then Intf.FOnKeyPress (Self, FId, FKeyPressed, Key, Shift);
            if FKeyPressed = Char(VK_ESCAPE) then begin
               FullScreen := False;
            end;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.OnDisplayFormMouseDown (Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Cur: TPoint;
begin
 if (Sender.ClassType <> TDisplayForm) or (not FGraphAccessAllowed) then begin
    if CanInvokeEvent (TPObj(Intf.FOnMouseDown)) then Intf.FOnMouseDown (Sender, -1, Button, Shift, X, Y);
 end
 else begin
   with TDisplayForm(Sender).AssociatedRenderer^ do begin
      if assigned (FAssociatedWindow) then begin
         with FAssociatedWindow do begin
            GetCursorPos (FPrevMousePoint);
            dec (FPrevMousePoint.x);
            dec (FPrevMousePoint.y);
            dec (X);
            dec (Y);
            if MouseEventIsMovingWindow (TDisplayForm(Sender).AssociatedRenderer) then Exit;
            if CanInvokeEvent (TPObj(Intf.FOnMouseDown)) then begin
               if FTranslateMouseCoordinates then begin
                  GetCursorPos (Cur);
                  if ScreenToClient (RenderHandle, Cur) then begin
                     if Cur.X < 0 then Exit;
                     if Cur.X > (Display.VideoRect.Right - Display.VideoRect.Left) then Exit;
                     if Cur.Y < 0 then Exit;
                     if Cur.Y > (Display.VideoRect.Bottom - Display.VideoRect.Top) then Exit;
                     Intf.FOnMouseDown (Intf, FId, Button, Shift,
                           Round ((Cur.X * FVideoSourceWidth) / (Display.VideoRect.Right - Display.VideoRect.Left)),
                           Round ((Cur.Y * FVideoSourceHeight) / (Display.VideoRect.Bottom - Display.VideoRect.Top))
                     );
                  end;
               end
               else begin
                  Intf.FOnMouseDown (Intf, FId, Button, Shift, X, Y);
               end;
            end;
         end;
      end;
   end;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.OnDisplayFormMouseUp (Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Cur: TPoint;
begin
 if (Sender.ClassType <> TDisplayForm) or (not FGraphAccessAllowed) then begin
    if CanInvokeEvent (TPObj(Intf.FOnMouseUp)) then Intf.FOnMouseUp (Sender, -1, Button, Shift, X, Y);
 end
 else begin
   with TDisplayForm(Sender).AssociatedRenderer^ do begin
      if assigned (FAssociatedWindow) then begin
         with FAssociatedWindow do begin
          if MouseEventIsMovingWindow (TDisplayForm(Sender).AssociatedRenderer) then begin
             FPrevMousePoint.x := -1;
          end
          else begin
            if CanInvokeEvent (TPObj(Intf.FOnMouseUp)) then begin
               if FTranslateMouseCoordinates then begin
                  GetCursorPos (Cur);
                  if ScreenToClient (RenderHandle, Cur) then begin
                     if Cur.X < 0 then Exit;
                     if Cur.X > (Display.VideoRect.Right - Display.VideoRect.Left) then Exit;
                     if Cur.Y < 0 then Exit;
                     if Cur.Y > (Display.VideoRect.Bottom - Display.VideoRect.Top) then Exit;
                     Intf.FOnMouseup (Intf, FId, Button, Shift,
                        Round ((Cur.X * FVideoSourceWidth) / (Display.VideoRect.Right - Display.VideoRect.Left)),
                        Round ((Cur.Y * FVideoSourceHeight) / (Display.VideoRect.Bottom - Display.VideoRect.Top))
                     );
                  end;
               end
               else begin
                  Intf.FOnMouseup (Intf, FId, Button, Shift, X, Y);
               end;
            end
            else begin
               FPrevMousePoint.x := -1;
            end;
          end;
         end;
      end;
   end;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.OnDisplayFormMouseMove (Sender: TObject; Shift: TShiftState; X, Y: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Cur: TPoint;
   MonitorRect: TRect;
begin
 if (Sender.ClassType <> TDisplayForm) or (not FGraphAccessAllowed) then begin
    if CanInvokeEvent (TPObj(Intf.FOnMouseMove)) then Intf.FOnMouseMove (Sender, -1, Shift, X, Y);
 end
 else begin
   with TDisplayForm(Sender).AssociatedRenderer^ do begin
      if assigned (FAssociatedWindow) then begin
         with FAssociatedWindow do begin
            if (FPrevMousePoint.x <> -1) and MouseEventIsMovingWindow (TDisplayForm(Sender).AssociatedRenderer) then begin
               if FPrevMousePoint.x <> -1 then begin
                  GetCursorPos (Cur);
                  Dec (Cur.x);
                  Dec (Cur.y);

                  FLongInt[vwLeft] := Display.Left + (Cur.x - FPrevMousePoint.x);
                  FLongInt[vwTop] := Display.Top + (Cur.y - FPrevMousePoint.y);
                  Display.SetBounds (FLongInt[vwLeft], FLongInt[vwTop], Display.Width, Display.Height);
                  if MonitorBounds (FAssociatedWindow.FLongInt[vwMonitor], MonitorRect) then begin
                     dec (FLongInt[vwLeft], MonitorRect.Left);
                     dec (FLongInt[vwTop] , MonitorRect.Top);
                  end;
                  FPrevMousePoint := Cur;
                end;
            end
            else if CanInvokeEvent (TPObj(Intf.FOnMouseMove)) then begin
               if FTranslateMouseCoordinates then begin
                  GetCursorPos (Cur);
                  if ScreenToClient (RenderHandle, Cur) then begin
                     if Cur.X < 0 then Exit;
                     if Cur.X > (Display.VideoRect.Right - Display.VideoRect.Left) then Exit;
                     if Cur.Y < 0 then Exit;
                     if Cur.Y > (Display.VideoRect.Bottom - Display.VideoRect.Top) then Exit;
                     Intf.FOnMouseMove (Intf, FId, Shift,
                        Round (((Cur.X) * FVideoSourceWidth) / (Display.VideoRect.Right - Display.VideoRect.Left)),
                        Round (((Cur.Y) * FVideoSourceHeight) / (Display.VideoRect.Bottom - Display.VideoRect.Top))
                        );
                  end;
               end
               else begin
                  Intf.FOnMouseMove (Intf, FId, Shift, X, Y);
               end;
            end;
         end;
      end;
   end;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function CreateOrOpenFileStream (FileName: String; Mode: Word): TFileStream;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   fs: TFileStream;
   Ok: Boolean;
begin
   Ok := False;
   fs := nil;
   try
      fs := TFileStream.Create (FileName, Mode);
      if assigned (fs) then begin
         Ok := True;
      end;
   finally
      if Ok then begin
         Result := fs;
      end
      else begin
         Result := nil;
      end;
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ReadBufferToFile (Prefix: String; BufferLoaderFunction: TBufferLoaderFunction): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Count: LongInt;
   k: LongInt;
   OutBuff, memoOutBuff: pByte;
   OutBuffLength: LongInt;
   Done: Boolean;
   Handle: LongInt;
   BufferEnd: pByte;
   BufferData: pByte;
   pBufferData: pByte;
   BufferSize: LongWord;
begin
   Result := '';
   if BufferLoaderFunction (BufferData, BufferSize) then begin
     pBufferData := BufferData;
     Result := _SyncManager.CreateTempFile (Prefix);
     if Result <> '' then begin
      BufferEnd := Pointer (LongWord (pBufferData) + BufferSize);
      OutBuffLength := pLongWord (pBufferData)^;
      GetMem (OutBuff, OutBuffLength);
      MemoOutBuff := OutBuff;
      inc (pBufferData, sizeof (LongWord));
      Done := False;
      while not Done do begin
         if LongWord (pBufferData) >= LongWord(BufferEnd) then begin
            Done := True;
         end
         else begin
            Count := pLongInt (pBufferData)^;
            inc (pBufferData, sizeof (LongInt));
            if Count > 0 then begin
               for k := 1 to Count do begin
                  OutBuff^ := pBufferData^;
                  inc (OutBuff);
                  inc (pBufferData);
               end;
            end
            else begin
               Count := - Count;
               for k := 1 to Count do begin
                  OutBuff^ := pBufferData^;
                  inc (OutBuff);
               end;
               inc (pBufferData);
            end;
         end;
      end;
      Handle := FileCreate (Result);
      if Handle <> -1 then begin
         FileWrite (Handle, MemoOutBuff^, OutBuffLength);
         FileClose (Handle);
      end
      else begin
         Result := '';
      end;
      FreeMem (MemoOutBuff);
     end;
     FreeMem (BufferData);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function LoadMemoryFilterFromFile (FileName: String; var Handle: HMODULE; ProcName: String; out Filter: IBaseFilter): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
type
   ptUnknown = ^IUnknown;
   TRegProc = function (out BaseFilter: IBaseFilter): HResult; stdcall;
var
   RegProc: TRegProc;
begin
   Result := false;
   if FileName = '' then Exit;
   if Handle = 0 then begin
      Handle := SafeLoadLibrary (FileName);
   end;
   if Handle > HINSTANCE_ERROR then begin
      RegProc := GetProcAddress(Handle, PChar(ProcName));
      if assigned (RegProc) then begin
         if Succeeded (RegProc (Filter)) then begin
            Result := true;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function LoadMemoryFilterFromBuffer (Prefix: String; BufferLoaderFunction: TBufferLoaderFunction; var Handle: HMODULE; ProcName: String; var Filter: IBaseFilter): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TempFile: String;
begin
   Result := false;
   TempFile := _SyncManager.FindTempFileByPrefix (Prefix);
   if TempFile = '' then begin
      TempFile := ReadBufferToFile (Prefix, BufferLoaderFunction);
   end;
   if TempFile <> '' then begin
      Result := LoadMemoryFilterFromFile (TempFile, Handle, ProcName, Filter);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.LoadFilter (clsid: pCLSID; Prefix: String; BufferLoaderFunction: TBufferLoaderFunction; var Handle: HMODULE; ProcName: String; var Filter: IBaseFilter; ObjName: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := LoadMemoryFilterFromBuffer (Prefix, BufferLoaderFunction, Handle, ProcName, Filter);
   LogB (not Result, LERROR, e_load_filter, 'cannot load filter ' + ObjName);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TVdgr.ConfDm (Graph: IGraphBuilder; OutPin: IPin; out Pin1, Pin2: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   MPegDMux: IBaseFilter;
   MpegAudioPin, MpegVideoPin: IPin;
   MpegVideoOut: pAM_MEDIA_TYPE;
   Mpeg2VideoInfo: pMPEG2VIDEOINFO;
   Mpeg1VideoInfo: pMPEG1VIDEOINFO;
   MpegAudioOut:  pAM_MEDIA_TYPE;
   AudioInfo: pMPEG1WAVEFORMAT;
   IsMpeg1: Boolean;
begin
         Result := False;

         Mpeg2VideoInfo:= nil;
         Mpeg1VideoInfo:= nil;

         if not AddFilterByName (@CLSID_LegacyAmFilterCategory, 'MPEG-2 Demultiplexer', mk_FullString, MPegDMux) then Exit;

         MpegAudioOut:= CoTaskMemAlloc (sizeof (TAM_MEDIA_TYPE));
         ZeroMemory( MpegAudioOut,  sizeof (TAM_MEDIA_TYPE));

         AudioInfo:= CoTaskMemAlloc (sizeof (TMPEG1WAVEFORMAT));
         ZeroMemory( AudioInfo,     sizeof (TMPEG1WAVEFORMAT));

         if not ConnectPins (OutPin, MPegDMux, 'MPEG-2 Stream', False) then Exit;

         IsMpeg1 := FMpegStreamType in [mpst_MPEG1, mpst_MPEG1_VCD];
         if IsMpeg1 then begin
            Mpeg1VideoInfo:= CoTaskMemAlloc (sizeof (TMpeg1VIDEOINFO));
            ZeroMemory( Mpeg1VideoInfo, sizeof (TMpeg1VIDEOINFO));

            Mpeg1VideoInfo.hdr.rcSource         := Rect(0, 0, 720, 576);
            Mpeg1VideoInfo.hdr.rcTarget         := Rect(0, 0, 720, 576);
            Mpeg1VideoInfo.cbSequenceHeader     := 0;
         end
         else begin
            Mpeg2VideoInfo:= CoTaskMemAlloc (sizeof (TMPEG2VIDEOINFO));
            ZeroMemory( Mpeg2VideoInfo, sizeof (TMPEG2VIDEOINFO));

            Mpeg2VideoInfo.hdr.rcSource         := Rect(0, 0, 720, 576);
            Mpeg2VideoInfo.hdr.rcTarget         := Rect(0, 0, 720, 576);
            Mpeg2VideoInfo.hdr.dwInterlaceFlags := 0;
            Mpeg2VideoInfo.dwProfile            := 2;
            Mpeg2VideoInfo.dwLevel              := 2;
            Mpeg2VideoInfo.cbSequenceHeader     := 0;
         end;

         MpegVideoOut:= CoTaskMemAlloc (sizeof (TAM_MEDIA_TYPE));
         ZeroMemory( MpegVideoOut,  sizeof (TAM_MEDIA_TYPE));

         MpegVideoOut.majortype            := MEDIATYPE_Video;
         MpegVideoOut.bFixedSizeSamples    := false;
         MpegVideoOut.bTemporalCompression := true;
         MpegVideoOut.lSampleSize          := 0;
         MpegVideoOut.pUnk                 := nil;
         if IsMpeg1 then begin
            MpegVideoOut.subtype              := MEDIASUBTYPE_MPEG1VIDEO;
            MpegVideoOut.formattype           := FORMAT_MPEG1Video;
            MpegVideoOut.cbFormat             := sizeof (TMpeg1VIDEOINFO);
            MpegVideoOut.pbFormat             := Mpeg1VideoInfo;
         end
         else begin
            MpegVideoOut.subtype              := MEDIASUBTYPE_MPEG2_VIDEO;
            MpegVideoOut.formattype           := FORMAT_MPEG2Video;
            MpegVideoOut.cbFormat             := sizeof (TMpeg2VIDEOINFO);
            MpegVideoOut.pbFormat             := Mpeg2VideoInfo;
         end;

         AudioInfo.wfx.wFormatTag           := WAVE_FORMAT_MPEG;
         AudioInfo.wfx.nChannels            := 2;
         AudioInfo.wfx.nSamplesPerSec       := 48000; 
         AudioInfo.wfx.nAvgBytesPerSec      := 0;
         AudioInfo.wfx.nBlockAlign          := 1;
         AudioInfo.wfx.wBitsPerSample       := 0;
         AudioInfo.wfx.cbSize               := 22;
         AudioInfo.fwHeadLayer              := ACM_MPEG_LAYER2;
         AudioInfo.dwHeadBitrate            := 0;
         AudioInfo.fwHeadMode               := ACM_MPEG_STEREO;
         AudioInfo.fwHeadModeExt            := 0;
         AudioInfo.wHeadEmphasis            := 1;
         AudioInfo.fwHeadFlags              := ACM_MPEG_ID_MPEG1;
         AudioInfo.dwPTSHigh                := 0;
         AudioInfo.dwPTSLow                 := 0;

         MpegAudioOut.majortype             := MEDIATYPE_Audio;
         MpegAudioOut.subtype               := MEDIASUBTYPE_MPEG1AudioPayload;
         MpegAudioOut.bFixedSizeSamples     := FALSE;
         MpegAudioOut.bTemporalCompression  := TRUE;
         MpegAudioOut.lSampleSize           := 0;
         MpegAudioOut.formattype            := FORMAT_WaveFormatEx;
         MpegAudioOut.cbFormat              := sizeof (TMPEG1WAVEFORMAT);
         MpegAudioOut.pbFormat              := AudioInfo;
         if not ConfDMux (MPegDMux, MpegVideoOut, 'Video Out', $E0, MpegVideoPin) then Exit;
         if not ConfDMux (MPegDMux, MpegAudioOut, 'Audio Out', $C0, MpegAudioPin) then Exit;

         if F_CaptureGraphBuilder2.FindPin (MpegDMux, PINDIR_OUTPUT, nil, @MEDIATYPE_Audio, true, 0, Pin2) <> S_OK then Exit;

         if F_CaptureGraphBuilder2.FindPin (MPegDMux, PINDIR_OUTPUT, nil, @MEDIATYPE_Video, true, 0, Pin1) <> S_OK then Exit;

         Result := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ConfDMux (var Filter: IBaseFilter; pmt: PAM_MEDIA_TYPE; PinName: String; StrId: ULONG; var OutPin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Mpeg2Demultiplexer: IMpeg2Demultiplexer;
   MPEG2StreamIdMap: IMPEG2StreamIdMap;
   MPEG2PIDMap: IMPEG2PIDMap;
   sName: pOleStr;
begin
   Result := False;
   try
      if not assigned (Filter) then Exit;
      if Filter.QueryInterface (IMpeg2Demultiplexer, Mpeg2Demultiplexer) <> S_OK then Exit;
      sName := StringToOleStr (PinName);
      if Mpeg2Demultiplexer.CreateOutputPin (pmt, sName, OutPin) <> S_OK then Exit;
      SysFreeString (sName);
      if OutPin.QueryInterface (IMPEG2StreamIdMap, MPEG2StreamIdMap) = S_OK then begin
         if MPEG2StreamIdMap.MapStreamId (StrId, MPEG2_PROGRAM_ELEMENTARY_STREAM, 0, 0) <> S_OK then Exit;
      end
      else if OutPin.QueryInterface (IMPEG2PIDMap, MPEG2PIDMap) = S_OK then begin
         if MPEG2PIDMap.MapPID (1, StrId, MPEG2_PROGRAM_ELEMENTARY_STREAM) <> S_OK then Exit;
      end
      else begin
         Exit;
      end;
      Result := True;
   finally
      Mpeg2Demultiplexer := nil;
      MPEG2StreamIdMap := nil;
      MPEG2PIDMap := nil;
      if not Result then begin
         OutPin := nil;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function BindFilterFromCLSID (FilterCategory: pGUID; FilterCLSID: pGUID; var FilterName: String; out Filter: IBaseFilter): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ rescans all the devices available, builds the list of names, detects if
{ the device is WDM compliant. Adjusts the FDevices array size.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
  SysDevEnum: ICreateDevEnum;
  EnumCat: IEnumMoniker;
  Moniker: IMoniker;
  cFetched: LongInt;
  PropBag: IPropertyBag;
  varName: OleVariant;
  Found: Boolean;
  CLSIDSearched: String;
  CLSIDRead: String;
begin
   try
      Result := False;

      CLSIDSearched := GUIDToSTring (FilterCLSID^);

      if not CreateInstance(@CLSID_SystemDeviceEnum, ICreateDevEnum, SysDevEnum, 'create sys dev enum') then Exit;

      if SysDevEnum.CreateClassEnumerator(FilterCategory^, EnumCat, 0) <> S_OK then Exit;

      Found := False;
      EnumCat.Reset;
      while (EnumCat.Next(1, Moniker, @cFetched) = S_OK) and (Not Found) do begin

         if assigned (Moniker) then begin
            if Moniker.BindToStorage(nil, nil, IPropertyBag, PropBag) = S_OK then begin
               if PropBag.Read('CLSID', varName, nil) = S_OK then begin
                  CLSIDRead := varName;
                  VarClear (varName);
                  if CLSIDRead = CLSIDSearched then begin
                     Found := True;
                     if PropBag.Read('FriendlyName', varName, nil) = S_OK then begin
                        FilterName := VarName;
                        VarClear (varName);
                        Result := Moniker.BindToObject (nil, nil, IBaseFilter, Filter) = S_OK;
                     end;
                  end;
               end;
               PropBag := nil;
            end;
            Moniker := nil;
         end;
      end;
   finally
      if assigned (EnumCat) then EnumCat := nil;
      if assigned (SysDevEnum) then SysDevEnum := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function BindFilterFromSubname (FilterCategory: pGUID; SubName: String; var FilterName: String; out Filter: IBaseFilter): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ rescans all the devices available, builds the list of names, detects if
{ the device is WDM compliant. Adjusts the FDevices array size.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
  SysDevEnum: ICreateDevEnum;
  EnumCat: IEnumMoniker;
  Moniker: IMoniker;
  cFetched: LongInt;
  PropBag: IPropertyBag;
  varName: OleVariant;
  FriendlyName: string;
  Found: Boolean;
begin
   try
      Result := False;

      if not CreateInstance(@CLSID_SystemDeviceEnum, ICreateDevEnum, SysDevEnum, 'create sys dev enum') then Exit;

      if SysDevEnum.CreateClassEnumerator(FilterCategory^, EnumCat, 0) <> S_OK then Exit;

      Found := False;
      EnumCat.Reset;
      while (EnumCat.Next(1, Moniker, @cFetched) = S_OK) and (Not Found) do begin

         if assigned (Moniker) then begin
            if Moniker.BindToStorage(nil, nil, IPropertyBag, PropBag) = S_OK then begin
               if PropBag.Read('FriendlyName', varName, nil) = S_OK then begin
                  FriendlyName := VarName;
                  VarClear (varName);
                  if pos (SubName, FriendlyName) > 0 then begin
                     Found:= True;
                     Result := Moniker.BindToObject (nil, nil, IBaseFilter, Filter) = S_OK;
                     FilterName := FriendlyName;
                  end;
               end;
               PropBag:= nil;
            end;
            Moniker:= nil;
         end;
      end;
   finally
      if assigned (EnumCat) then EnumCat := nil;
      if assigned (SysDevEnum) then SysDevEnum := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.HoldStreaming: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   if not FGraphAccessAllowed then Exit;
   if assigned (FGrabberHandlers[gh_LockingVideo].Control) then begin
      if not FGrabberHandlers[gh_LockingVideo].Control^.LockState then begin
         FGrabberHandlers[gh_LockingVideo].Control^.LockState := true;
         Result := True;
      end;
   end;
   if Result then begin
      FCUrrentFrameData.AVIFrameCapturePaused := true;
      FCurrentFrameData.HoldStreamingFrameTime := FCurrentFrameData.RealFrameTime;
   end;
   if assigned (FGrabberHandlers[gh_LockingAudio].Control) then begin
      if not FGrabberHandlers[gh_LockingAudio].Control^.LockState then begin
         FGrabberHandlers[gh_LockingAudio].Control^.LockState := true;
         Result := True;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ReleaseStreaming: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   if assigned (FGrabberHandlers[gh_ClearVideo].Control) then begin
      FGrabberHandlers[gh_ClearVideo].Control.ClearFrame := True;
   end;
   if assigned (FGrabberHandlers[gh_ClearAudio].Control) then begin
      FGrabberHandlers[gh_ClearAudio].Control.ClearFrame := True;
   end;
   if assigned (FGrabberHandlers[gh_LockingVideo].Control) then begin
      if FGrabberHandlers[gh_LockingVideo].Control^.LockState then begin
         FGrabberHandlers[gh_LockingVideo].Control^.LockState := false;
         Result := True;
      end;
   end;
   if Result then begin
      inc (FCurrentFrameData.PausedFrameTime, FCurrentFrameData.RealFrameTime - FCurrentFrameData.HoldStreamingFrameTime);
      FCurrentFrameData.HoldStreamingFrameTime := 0;

      FCurrentFrameData.AVIFrameCapturePaused := False;
   end;
   if assigned (FGrabberHandlers[gh_LockingAudio].Control) then begin
      if FGrabberHandlers[gh_LockingAudio].Control^.LockState then begin
         FGrabberHandlers[gh_LockingAudio].Control^.LockState := false;
         Result := True;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RetrieveVideoQualityCurrentSettings;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: TVideoQuality;
   DummyFlags: LongInt;
begin
   if not assigned (F_AMVideoQuality) then Exit;
   for i := low (TVideoQuality) to high(TVideoQuality) do begin
      with FVideoQuality[i] do begin
         Available := F_AMVideoQuality.GetRange (LongInt (i), min, max, SteppingDelta, Default_, DummyFlags) = S_OK;
         if Available then begin
            F_AMVideoQuality.Get (LongInt (i), Value, DummyFlags);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ProcessCommand: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TaskData: pTaskData;
begin
   Result := False;
   if FProcessingCommand then Exit;
   FProcessingCommand := True;
   FTaskList.Lock;
   if FTaskList.Count > 0 then begin
      TaskData := FTaskList[0];
      FTaskList.Delete (0);
      FTaskList.UnLock;
      ProcessTaskCommand (TaskData.Task);
      Result := True;
      FProcessingCommand := False;
      FreeMem (TaskData);
   end
   else begin
      FTaskList.UnLock;
   end;
   FProcessingCommand := False;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ProcessEvent: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   EventData: pEventData;
begin
   Result := False;
   if FEventList.Count = 0 then Exit;
   FEventList.Lock;
   EventData := FEventList[0];
   FEventList.Delete (0);
   FEventList.UnLock;
   DoProcessEvent (EventData);
   Result := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.DoProcessEvent (EventData: pEventData);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with EventData^.Vdgr do begin
      if EventData^.Event = @Intf.FOnRecordingStarted then begin
         if CanInvokeEvent (TPObj(Intf.FOnRecordingStarted)) then Intf.FOnRecordingStarted (Intf, FRealRecordingFileName);
      end
      else if EventData^.Event = @Intf.FOnPreviewStarted then begin
         if CanInvokeEvent (TPObj(Intf.FOnPreviewStarted)) then Intf.FOnPreviewStarted (Intf);
      end
      else if EventData^.Event = @Intf.FOnDeviceLost then begin
         if CanInvokeEventWithoutHandle (TPObj(Intf.FOnDeviceLost)) then Intf.FOnDeviceLost (Intf);
      end
      else if EventData^.Event = @Intf.FOnPlayerOpened then begin
         if CanInvokeEvent (TPObj(Intf.FOnPlayerOpened)) then Intf.FOnPlayerOpened (Intf);
      end
      else if EventData^.Event = @Intf.FOnCopyPreallocDataProgress then begin
         if CanInvokeEvent (TPObj(Intf.FOnCopyPreallocDataProgress)) then Intf.FOnCopyPreallocDataProgress (Intf, FReencodingProgressInfo);
      end
      else if EventData^.Event = @Intf.FOnReencodingProgress then begin
         if CanInvokeEvent (TPObj(Intf.FOnReencodingProgress)) then Intf.FOnReencodingProgress (Intf, FReencodingProgressInfo);
      end
      else if EventData^.Event = @Intf.FOnReencodingStarted then begin
         if CanInvokeEvent (TPObj(Intf.FOnReencodingStarted)) then Intf.FOnReencodingStarted (Intf, FReencodingSettings.SourceVideoClip, FReencodingSettings.NewVideoClip);
      end
      else if EventData^.Event = @Intf.FOnInactive then begin
         if CanInvokeEvent (TPObj(Intf.FOnInactive)) then Intf.FOnInactive (Intf);
      end
      else if EventData^.Event = @Intf.FOnTVChannelSelected then begin
         if CanInvokeEvent (TPObj(Intf.FOnTVChannelSelected)) then Intf.FOnTVChannelSelected (Intf, FTVChannelInfo);
      end
      else if EventData^.Event = @Intf.FOnTVChannelScanStarted then begin
         if CanInvokeEvent (TPObj(Intf.FOnTVChannelScanStarted)) then Intf.FOnTVChannelScanStarted (Intf, FTVScanCurrentChannel, FTVScanMaxChannel);
      end
      else if EventData^.Event = @Intf.FOnRecordingCompleted then begin
         if CanInvokeEvent (TPObj(Intf.FOnRecordingCompleted)) then Intf.FOnRecordingCompleted (Intf, FRealRecordingFileName, FRecordingSuccessful);
      end
      else if EventData^.Event = @Intf.FOnReencodingCompleted then begin
         if CanInvokeEvent (TPObj(Intf.FOnReencodingCompleted)) then Intf.FOnReencodingCompleted (Intf, FLastReencodingSourceFileName, FLastReencodingNewFileName, FReencodeOrRecopyDataSucceeded);
      end
      else if EventData^.Event = @Intf.FOnCopyPreallocDataCompleted then begin
         if CanInvokeEvent (TPObj(Intf.FOnCopyPreallocDataCompleted)) then Intf.FOnCopyPreallocDataCompleted (Intf, FLastReencodingSourceFileName, FLastReencodingNewFileName, FReencodeOrRecopyDataSucceeded);
      end
      else if EventData^.Event = @Intf.FOnVideoDeviceSelected then begin
         if CanInvokeEventWithoutHandle (TPObj(Intf.FOnVideoDeviceSelected)) then Intf.FOnVideoDeviceSelected (Intf);
      end
      else if EventData^.Event = @Intf.FOnAudioDeviceSelected then begin
         if CanInvokeEventWithoutHandle (TPObj(Intf.FOnAudioDeviceSelected)) then Intf.FOnAudioDeviceSelected (Intf);
      end
      else if EventData^.Event = @Intf.FOnCreatePreallocFileStarted then begin
         if CanInvokeEvent (TPObj(Intf.FOnCreatePreallocFileStarted)) then Intf.FOnCreatePreallocFileStarted (Intf, FUsedPreallocFileName);
      end
      else if EventData^.Event = @Intf.FOnCreatePreallocFileCompleted then begin
         if CanInvokeEvent (TPObj(Intf.FOnCreatePreallocFileCompleted)) then Intf.FOnCreatePreallocFileCompleted (Intf, FUsedPreallocFileName, FPreallocatedFileSuccessfullyCreated);
      end
      else if EventData^.Event = @Intf.FOnDiskFull then begin
         if CanInvokeEvent (TPObj(Intf.FOnDiskFull)) then Intf.FOnDiskFull (Intf);
      end
      else if EventData^.Event = @Intf.FOnCopyPreallocDataStarted then begin
         if CanInvokeEvent (TPObj(Intf.FOnCopyPreallocDataStarted)) then Intf.FOnCopyPreallocDataStarted (Intf, FTemporaryRecordingFileName, FRealRecordingFileName);
      end
      else if EventData^.Event = @Intf.FOnReencodingStarted then begin
         if CanInvokeEvent (TPObj(Intf.FOnReencodingStarted)) then Intf.FOnReencodingStarted (Intf, FTemporaryRecordingFileName, FRealRecordingFileName);
      end
      else if EventData^.Event = @Intf.FOnNoVideoDevices then begin
         if CanInvokeEvent (TPObj(Intf.FOnNoVideoDevices)) then Intf.FOnNoVideoDevices (Intf);
      end
      else if EventData^.Event = @Intf.FOnDirectNetworkStreamingHostUrl then begin
         if CanInvokeEvent (TPObj(Intf.FOnDirectNetworkStreamingHostUrl)) then Intf.FOnDirectNetworkStreamingHostUrl (Intf, FStreamingUrl, FStreamingHostName, FStreamingHostPort);
      end;
   end;
   FreeMem (EventData);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RestoreVideoQualitySettingsFromRegistry;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: TVideoQuality;
begin
   if not FVideoQualitySettings then Exit;
   if not assigned (F_AMVideoQuality) then Exit;
   for i := low (TVideoQuality) to high(TVideoQuality) do begin
      if FVideoRegSave[_VideoQuality_Auto].b then begin
         F_AMVideoQuality.Set_ (LongInt (i), FVideoQuality[i].Default_, AM_Flags_Auto);
      end
      else begin
         F_AMVideoQuality.Set_ (LongInt (i), FVideoQuality[i].Value, AM_Flags_Manual);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RetrieveCameraControlCurrentSettings;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: TCameraControl;
   DummyFlags: LongInt;
begin
   if not assigned (F_AMCameraControl) then Exit;
   for i := low(TCameraControl) to high (TCameraControl) do begin
      with FCameraControl[i] do begin
         Available := F_AMCameraControl.GetRange (LongInt (i), min, max, SteppingDelta, Default_, DummyFlags) = S_OK;
         if Available then begin
            F_AMCameraControl.Get (LongInt (i), Value, DummyFlags);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RestoreCameraControlSettingsFromRegistry;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: TCameraControl;
begin
   if not FCameraControlSettings then Exit;
   if not assigned (F_AMCameraControl) then Exit;
   for i := low(TCameraControl) to high (TCameraControl) do begin
      if FVideoRegSave[_CameraControl_Auto].b then begin
         F_AMCameraControl.Set_ (LongInt (i), FCameraControl[i].Default_, AM_Flags_Auto);
      end
      else begin
         F_AMCameraControl.Set_ (LongInt (i), FCameraControl[i].Value, AM_Flags_Manual);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.PerformSetVideoInput (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   PhysicalType: LongInt;
   DummyPinIndexRelated: LongInt;
begin
   if not assigned (F_AMVideoCrossbar) then Exit;

   if F_AMVideoCrossbar.Route (0, FVideoRegSave[_VideoInput].i) = S_OK then begin
      FCrossbar[LongInt(cs_VideoCrossbar)].ReadCrossbar (F_AMVideoCrossbar);
      if assigned (FCrossbarAutoRouter) then begin
         FCrossbarAutoRouter.SetCurrentInputFromCrossbar (F_AMVideoCrossbar);
      end
      else begin
         RouteAudioRelatedPin;
      end;

      if F_AMVideoCrossbar.get_CrossbarPinInfo (True, FVideoRegSave[_VideoInput].i, DummyPinIndexRelated, PhysicalType) = S_OK then begin
         FIsTunerInputSelected := PhysicalType = PhysConn_Video_Tuner;
      end;
      if FIsTunerInputSelected then begin
         TVDoSetChannel (FVideoRegSave[_TVChannel].i, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
      end;
   end
   else begin
      LogB (true, LERROR, e_failed_to_connect_crossbar_pin, 'Cannot route video crossbar input');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ClearMutedAudioDeviceInput;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FMutedSPKDeviceInput <> -1 then begin
      MuteInputVolume (FMutedSPKDevice, FMutedSPKDeviceInput, False);
      FMutedSPKDevice:= -1;
      FMutedSPKDeviceInput:= -1;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.GetAudioInputName: String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if CanAssociateAudioAndVideoDevices then begin
      Result := FVideoRegSave[_AudioInputNameAssociated].s;
   end
   else begin
      Result := FAudioRegSave[_AudioInputName].s;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ActivateAudioInputAndSetValues: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TstringList;
var
   FilterPin: IPin;
   Pins: IEnumPins;
   cFetched: ULONG;
   Direction: TPin_Direction;
   Done: Boolean;
   PinInfo: TPin_Info;
   AMAudioInputMixer: IAMAudioInputMixer;
   AudioInputName: String;
begin
   Result := False;

   List := TstringList.Create;
   List.Text := FAudioRegSave[_AudioInputs].s;
   if List.Count > 0 then begin
      if CanAssociateAudioAndVideoDevices then begin
         if FVideoRegSave[_AudioInputAssociated].i >= List.Count then begin
            FVideoRegSave[_AudioInputAssociated].i := 0;
         end;
         FVideoRegSave[_AudioInputNameAssociated].s := List[FVideoRegSave[_AudioInputAssociated].i];
      end
      else begin
         if FAudioRegSave[_AudioInput].i >= List.Count then begin
            FAudioRegSave[_AudioInput].i := 0;
         end;
         FAudioRegSave[_AudioInputName].s := List[FAudioRegSave[_AudioInput].i];
      end;
   end;
   List.Free;

   if not assigned (F_AudioDevice) then Exit;
   if assigned (F_AMAudioInputMixerPin) then F_AMAudioInputMixerPin :=  nil;

   if CanAssociateAudioAndVideoDevices then begin
      AudioInputName := FVideoRegSave[_AudioInputNameAssociated].s;
   end
   else begin
      AudioInputName := FAudioRegSave[_AudioInputName].s;
   end;

   if F_AudioDevice.EnumPins(Pins) <> S_OK then Exit;
   if not assigned (Pins)  then Exit;
   Done := false;
   while not Done do begin
      if Pins.Next(1, FilterPin, @cFetched) = S_OK then begin
         if assigned (FilterPin) then begin
            FilterPin.QueryDirection (Direction);
            if Direction = PINDIR_INPUT then begin
               if FilterPin.QueryInterface (IAMAudioInputMixer, AMAudioInputMixer) = S_OK then begin
                  if FilterPin.QueryPinInfo (PinInfo) = S_OK then begin
                     if PinInfo.achName = AudioInputName then begin
                        AMAudioInputMixer.put_Enable (TRUE);
                        F_AMAudioInputMixerPin := AMAudioInputMixer;
                        Result := True;
                     end
                     else begin
                        AMAudioInputMixer.put_Enable (FALSE);
                        AMAudioInputMixer.put_MixLevel(0);
                     end;
                     PinInfo.pFilter := nil;
                  end;
                  AMAudioInputMixer := nil;
               end;
            end;
            FilterPin := nil;
         end;
      end
      else begin
         Done := true;
      end;
   end;
   Pins:= nil;
   if Result then begin
      SetAudioInputValues;
   end;
end;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.SetAudioInputValues;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   AudioInputLevel: LongInt;
   AudioInputMono: Boolean;
   AudioInputBalance: LongInt;

   MixerAudioInputLevel: Double;
   MixerAudioInputBalance: Double;
   MixerAudioInputMono: BOOL;

   MixerAudioInputLevelOK: Boolean;
   MixerAudioInputBalanceOK: Boolean;
   MixerAudioInputMonoOK: Boolean;
begin
   if CanAssociateAudioAndVideoDevices then begin
      AudioInputLevel := FVideoRegSave[_AudioInputLevelAssociated].i;
      AudioInputBalance := FVideoRegSave[_AudioInputBalanceAssociated].i;
      AudioInputMono := FVideoRegSave[_AudioInputMonoAssociated].b;
   end
   else begin
      AudioInputLevel := FAudioRegSave[_AudioInputLevel].i;
      AudioInputBalance := FAudioRegSave[_AudioInputBalance].i;
      AudioInputMono := FAudioRegSave[_AudioInputMono].b;
   end;

   if AudioInputLevel <= 0 then begin
      MixerAudioInputLevel := 0.0;
   end
   else if AudioInputLevel >= 65535 then begin
     MixerAudioInputLevel := 1.0;
   end
   else begin
      MixerAudioInputLevel := AudioInputLevel / 65535;
   end;

   if AudioInputBalance <= -32768 then begin 
      MixerAudioInputBalance := -1.0;
   end
   else if AudioInputBalance >= 32767 then begin
      MixerAudioInputBalance := 1.0;
   end
   else begin
      MixerAudioInputBalance := (AudioInputBalance - 32767) / 65535;
   end;

   MixerAudioInputMono := AudioInputMono;

   MixerAudioInputMonoOK := False;
   MixerAudioInputLevelOK := False;
   MixerAudioInputBalanceOK := False;

   if assigned (F_AMAudioInputMixerPin) then begin
      MixerAudioInputMonoOK := Succeeded (F_AMAudioInputMixerPin.put_Mono (MixerAudioInputMono));
      MixerAudioInputLevelOK := Succeeded (F_AMAudioInputMixerPin.put_MixLevel (MixerAudioInputLevel));
      MixerAudioInputBalanceOK := Succeeded (F_AMAudioInputMixerPin.put_Pan (MixerAudioInputBalance));
   end;

   if assigned (F_AMAudioInputMixerGeneral) then begin
      if not MixerAudioInputMonoOK then begin
         F_AMAudioInputMixerGeneral.put_Mono (MixerAudioInputMono);
      end;
      if not MixerAudioInputLevelOK then begin
         F_AMAudioInputMixerGeneral.put_MixLevel (MixerAudioInputLevel);
      end;
      if not MixerAudioInputBalanceOK then begin
         MixerAudioInputBalanceOK := Succeeded (F_AMAudioInputMixerGeneral.put_Pan (MixerAudioInputBalance));
      end;
   end;

   if MixerAudioInputBalanceOK then begin
      FIsAudioInputBalanceAvailable:= ts_True;
   end
   else begin
      FIsAudioInputBalanceAvailable:= ts_False;
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ChangeBusyStateAndCursor (Value: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ switches the cursor to HourGlass or Normal
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if Value then begin
      inc (BusyCursorCount);
      WriteLog (nil, sGrey, 'cursor + ' + inttostr (BusyCursorCount));
      if FBusyCursor <> crDefault then begin
         Screen.Cursor := FBusyCursor;
      end;
      FBusy := True;
   end
   else begin
      dec (BusyCursorCount);
      if BusyCursorCount < 0 then begin
         BusyCursorCount := 0;
      end;
      WriteLog (nil, sGrey, 'cursor - ' + inttostr (BusyCursorCount));
      if BusyCursorCount = 0 then begin
         if FBusyCursor <> crDefault then begin
            Screen.Cursor := FNormalCursor;
         end;
         FBusy := False;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.CalcSize (var w, h: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FStretchPreferredVideoSize and ((FPreferredVideoWidth > 0) and (FPreferredVideoHeight > 0)) then begin
      w  := FPreferredVideoWidth;
      h := FPreferredVideoHeight;
   end
   else begin
      w  := FVideoSourceWidth;
      h := FVideoSourceHeight;
   end;
   if FPreviewZoomSize <> 100 then begin
      w := Round (w * LongInt (FPreviewZoomSize) / 100);
      h := Round (h * LongInt (FPreviewZoomSize) / 100);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.IsWindowEmbedded (VideoWindow: TVideoWindow): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   if not assigned (VideoWindow) then Exit;
   Result := VideoWindow.FBool[vwEmbedded] and (not VideoWindow.FBool[vwFullScreen]); // and Intf.HasParent;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RefreshWindowPos (Renderer: pRenderer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with Renderer^ do begin
      if not assigned (FAssociatedWindow) then Exit;
      if not assigned (Display) then Exit;
      if not FAssociatedWindow.FBool[vwEmbedded] then Exit;
      Display.AdjustSize;
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ResizeRenderer (Renderer: pRenderer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   DisplayRect: TRect;
   TempWidth, TempHeight: LongInt;
   Ratio: Double;
   intfWidth, intfHeight: LongInt;
   dispLeft, dispTop: LongInt;
   CanApplyKeepAspectRatio: Boolean;
   CanResizeControl: Boolean;
begin
   with Renderer^ do begin
      if not assigned (FAssociatedWindow) then Exit;
      if not assigned (Display) then Exit;

      IntfHeight := -1;
      IntfWidth := -1;

      CanApplyKeepAspectRatio := True;
      CanResizeControl := MustResizeControl (FAssociatedWindow);
      { EXTERNAL, FULL SCREEN }
      if FAssociatedWindow.FBool[vwFullScreen] then begin
         if MonitorBounds (FAssociatedWindow.FLongInt[vwMonitor], DisplayRect) then begin
            dispLeft := DisplayRect.Left;
            dispTop := DisplayRect.Top;
            FAssociatedWindow.FLongInt[vwVideoWidth] := DisplayRect.Right - DisplayRect.Left;
            FAssociatedWindow.FLongInt[vwVideoHeight] := DisplayRect.Bottom - DisplayRect.Top;
         end
         else begin
            dispLeft := 0;
            dispTop := 0;
            FAssociatedWindow.FLongInt[vwVideoWidth] := Screen.Width;
            FAssociatedWindow.FLongInt[vwVideoHeight] := Screen.Height;
         end;
      end
      { EXTERNAL }
      else if not IsWindowEmbedded (FAssociatedWindow) then begin
         if FAssociatedWindow.FBool[vwAutoSize] then begin
            CalcSize (FAssociatedWindow.FLongInt[vwVideoWidth], FAssociatedWindow.FLongInt[vwVideoHeight]);
         end
         else begin
            CanApplyKeepAspectRatio := True;
            FAssociatedWindow.FLongInt[vwVideoWidth] := FAssociatedWindow.Width;
            FAssociatedWindow.FLongInt[vwVideoHeight] := FAssociatedWindow.Height;
         end;
         if MonitorBounds (FAssociatedWindow.FLongInt[vwMonitor], DisplayRect) then begin
            dispLeft := DisplayRect.Left + FAssociatedWindow.FLongInt[vwLeft];
            dispTop := DisplayRect.Top + FAssociatedWindow.FLongInt[vwTop];
         end
         else begin
            dispLeft := FAssociatedWindow.Left;
            dispTop := FAssociatedWindow.Top;
         end;
      end
      { EMBEDDED }
      else begin
         CanApplyKeepAspectRatio := FAssociatedWindow.FBool[vwKeepAspectRatio];

         dispLeft := 0;
         dispTop := 0;

         if CanResizeControl then begin
            CalcSize (FAssociatedWindow.FLongInt[vwVideoWidth], FAssociatedWindow.FLongInt[vwVideoHeight]);
            intfWidth := FAssociatedWindow.FLongInt[vwVideoWidth] + FBorderThickness;
            intfHeight := FAssociatedWindow.FLongInt[vwVideoHeight] + FBorderThickness;
         end
         else begin
            FAssociatedWindow.FLongInt[vwVideoWidth]  := Intf.Width - FBorderThickness;
            FAssociatedWindow.FLongInt[vwVideoHeight] := Intf.Height - FBorderThickness;
         end;
      end;

      if FAssociatedWindow.FBool[vwKeepAspectRatio] and CanApplyKeepAspectRatio then begin
         if IsOverlay and FAssociatedWindow.FBool[vwVideoPortEnabled] then begin { USUALLY IS THE SAME }
            Ratio := FVideoPortWidth / FVideoPortHeight;
         end
         else begin
            Ratio := FVideoSourceWidth / FVideoSourceHeight;
         end;

         TempHeight := Round (FAssociatedWindow.FLongInt[vwVideoWidth] / Ratio);
         if TempHeight <= (FAssociatedWindow.FLongInt[vwVideoHeight]) then begin
            Display.VideoRect.Left := 0;
            Display.VideoRect.Top := (FAssociatedWindow.FLongInt[vwVideoHeight] - TempHeight) shr 1;
            Display.VideoRect.Right := FAssociatedWindow.FLongInt[vwVideoWidth];
            Display.VideoRect.Bottom := Display.VideoRect.Top + TempHeight;
         end
         else begin
            TempWidth := Round ((FAssociatedWindow.FLongInt[vwVideoHeight]) * Ratio);
            Display.VideoRect.Top := 0;
            Display.VideoRect.Left := (FAssociatedWindow.FLongInt[vwVideoWidth] - TempWidth) shr 1;
            Display.VideoRect.Bottom  := FAssociatedWindow.FLongInt[vwVideoHeight];
            Display.VideoRect.Right := Display.VideoRect.Left + TempWidth;
         end;
      end
      else begin
         SetRect (Display.VideoRect, 0, 0, FAssociatedWindow.FLongInt[vwVideoWidth], FAssociatedWindow.FLongInt[vwVideoHeight]);
      end;

      if CanResizeControl then begin
         if IntfWidth <> -1 then begin
            Intf.SetBounds (Intf.Left, Intf.Top, intfWidth, intfHeight);
         end;
      end;
      Display.SetBounds (dispLeft, dispTop, FAssociatedWindow.FLongInt[vwVideoWidth], FAssociatedWindow.FLongInt[vwVideoHeight]);
      SetRect (CurrentDisplayBounds, dispLeft, dispTop, FAssociatedWindow.FLongInt[vwVideoWidth], FAssociatedWindow.FLongInt[vwVideoHeight]);

      if assigned (VideoWindow) then begin
         VideoWindow.SetWindowPosition (Display.VideoRect.Left, Display.VideoRect.Top, Display.VideoRect.Right - Display.VideoRect.Left, Display.VideoRect.Bottom - Display.VideoRect.Top);
      end;

   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CheckDualDisplay: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := (FVideoWindow.FBool[vwActive]
                                and FVideoWindow2.FBool[vwActive])
                                and (not (FVideoRegSave[_IsVideoPortAvailable].b and (FVideoWindow.VideoPortEnabled
                                   or FVideoWindow2.VideoPortEnabled
                                   )));

   if LogB (Result and FColorKeyEnabled, LERROR, e_incompatible_options, 'window transparency incompatible with dual display') then begin
      Result := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.MustResizeControl (VideoWindow: TVideoWindow): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with VideoWindow do begin
      Result := IsWindowEmbedded (VideoWindow) and FBool[vwAutoSize];
      if Result then begin
         Result := not (Intf.Align = alClient);
         if Result then begin
            Result := not ((akLeft in Intf.Anchors) and (akRight in Intf.Anchors));
            if Result then begin
               Result := not ((akTop in Intf.Anchors) and (akBottom in Intf.Anchors));
            end;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ResizeVideoWindows (ProcessMessages: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ resizes the video window according to the current video stream size
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not FInitializedAtRuntime then Exit;
   if FResizingWindow then Exit;

   FResizingWindow := true; { to disallow reentrance when calling from SetAutoSize }

   if (FGraphType > cs_Down) and (FGraphType < cs_Reencoding) then begin
      ResizeRenderer (@FVideoRendererW);
      ResizeRenderer (@FVideoRendererW2);
      ResizeRenderer (@FOverlayRendererW);
   end
   else begin { if not ((FGraphType > cs_Down) and (FGraphType < cs_Reencoding))  then begin  }
      if MustResizeControl (FVideoWindow) then begin
         if DecodeVideoSizeUsingDefault (-1, FVideoSourceWidth, FVideoSourceHeight) then begin
            CalcSize (FVideoWindow.FLongInt[vwVideoWidth], FVideoWindow.FLongInt[vwVideoHeight]);
            Intf.SetBounds (Intf.Left, Intf.Top, FVideoWindow.FLongInt[vwVideoWidth] + FBorderThickness, FVideoWindow.FLongInt[vwVideoHeight] + FBorderThickness);
         end;
      end
      else if MustResizeControl (FVideoWindow2) then begin
         if DecodeVideoSizeUsingDefault (-1, FVideoSourceWidth, FVideoSourceHeight) then begin
            CalcSize (FVideoWindow2.FLongInt[vwVideoWidth], FVideoWindow2.FLongInt[vwVideoHeight]);
            Intf.SetBounds (Intf.Left, Intf.Top, FVideoWindow2.FLongInt[vwVideoWidth] + FBorderThickness, FVideoWindow2.FLongInt[vwVideoHeight] + FBorderThickness);
         end;
      end;
   end;

   if CanInvokeEvent (TPObj(Intf.FOnResizeVideo)) then Intf.FOnResizeVideo (Intf, FVideoSourceWidth, FVideoSourceHeight);

   Intf.Invalidate;

   //if ProcessMessages then begin // ZZZZZZ
   //   FlushMessages; { OTHERWISE FLICKER }
   //end;

   FResizingWindow := false;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.AssociateVideoWindows;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      if not FInitializedAtRuntime then Exit;
      if not assigned (FVideoRendererW.RenderFilter) and not assigned (FVideoRendererW2.RenderFilter) and not assigned (FOverlayRendererW.RenderFilter) then Exit;

      FVideoWindow.FAssociatedRenderer := nil;
      FVideoWindow2.FAssociatedRenderer := nil;

      FVideoRendererW.FAssociatedWindow := nil;
      FVideoRendererW2.FAssociatedWindow := nil;
      FOverlayRendererW.FAssociatedWindow := nil;

      if assigned (FOverlayRendererW.RenderFilter) then begin
         if FVideoWindow.FBool[vwActive] and FVideoWindow.VideoPortEnabled then begin
            FVideoWindow.FAssociatedRenderer := @FOverlayRendererW;
            FOverlayRendererW.FAssociatedWindow := FVideoWindow;
         end
         else if FVideoWindow2.FBool[vwActive] and FVideoWindow2.VideoPortEnabled then begin
            FVideoWindow2.FAssociatedRenderer := @FOverlayRendererW;
            FOverlayRendererW.FAssociatedWindow := FVideoWindow2;
         end
         else begin
            {if FColorKeyEnabled then begin             otherwise transparency fails when graph starts, video port disabled and transparency enabled }
               FVideoWindow.FAssociatedRenderer := @FOverlayRendererW;
               FOverlayRendererW.FAssociatedWindow := FVideoWindow;
               ChangeDisplayParent (FVideoWindow.FAssociatedRenderer, False);
               ResizeRenderer (@FOverlayRendererW);
               FVideoWindow.FAssociatedRenderer := nil;
               FOverlayRendererW.FAssociatedWindow := nil;
            { end; }
         end;
      end;

      if assigned (FVideoRendererW.RenderFilter) then begin
         if (not assigned (FVideoWindow.FAssociatedRenderer)) and FVideoWindow.FBool[vwActive] then begin
            FVideoWindow.FAssociatedRenderer := @FVideoRendererW;
            FVideoRendererW.FAssociatedWindow := FVideoWindow;
         end
         else if (not assigned (FVideoWindow2.FAssociatedRenderer)) and FVideoWindow2.FBool[vwActive] then begin
            FVideoWindow2.FAssociatedRenderer := @FVideoRendererW;
            FVideoRendererW.FAssociatedWindow := FVideoWindow2;
         end;
      end;

      if assigned (FVideoRendererW2.RenderFilter) then begin
         if (not assigned (FVideoWindow.FAssociatedRenderer)) and FVideoWindow.FBool[vwActive] then begin
            FVideoWindow.FAssociatedRenderer := @FVideoRendererW2;
            FVideoRendererW2.FAssociatedWindow := FVideoWindow;
         end
         else if (not assigned (FVideoWindow2.FAssociatedRenderer)) and FVideoWindow2.FBool[vwActive] then begin
            FVideoWindow2.FAssociatedRenderer := @FVideoRendererW2;
            FVideoRendererW2.FAssociatedWindow := FVideoWindow2;
         end;
      end;

      if assigned (FVideoWindow.FAssociatedRenderer) then begin
         if IsWindowEmbedded (FVideoWindow) and (not FVideoWindow.FBool[vwFullScreen]) then begin
            ChangeDisplayParent (FVideoWindow.FAssociatedRenderer, False);
         end
         else begin
            ChangeDisplayParent (FVideoWindow.FAssociatedRenderer, False);
         end;
      end;

      if assigned (FVideoWindow2.FAssociatedRenderer) then begin
         if IsWindowEmbedded (FVideoWindow2) then begin
            ChangeDisplayParent (FVideoWindow2.FAssociatedRenderer, False);
         end
         else begin
            ChangeDisplayParent (FVideoWindow2.FAssociatedRenderer, False);
         end;
      end;

      if assigned (FVideoWindow.FAssociatedRenderer) then FVideoWindow.FActivated := True;
      if assigned (FVideoWindow2.FAssociatedRenderer) then FVideoWindow2.FActivated := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InstallDisplay (var OutputPin: IPin; CanUseVMR: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   InPin: IPin;
   CxPin: IPin;
   InfTee: IBaseFilter;
   IsVMRUsed: Boolean;
   VideoOut2: IPin;
   TempPin: IPin;
begin
   Result := false;
   try

      WriteLog (nil, sGrey, 'installing display');
      if not assigned (OutputPin) then Exit;
      WriteLog (nil, sGrey, 'installing display/2');

      if (FCurrent.FrameGrabber in [fg_CaptureStream, fg_Disabled]) and
       (
         (isDVSource and (FVideoRegSave[_VideoSize].i = 4))
         or
         ((FGraphType = cs_Playback) and FCurrentFrameData.DVDataAvailable and (FPlayerDVSize = dvFull))
       )
      then begin
         if FCurrent.VideoRenderer in [vr_AutoSelect, vr_VMR9] then begin
            FCurrent.VideoRenderer := vr_VMR7;
         end
         else if FCurrent.VideoRenderer = vr_AutoSelect then begin
            FCurrent.VideoRenderer := vr_StandardRenderer;
         end;
      end;
      if FCurrent.VideoRenderer = vr_AutoSelect then begin
         if FGraphType = cs_Playback then begin
            FCurrent.VideoRenderer := vr_VMR7;
         end
         else begin
            FCurrent.VideoRenderer := vr_StandardRenderer;
         end;
      end;

      if (FCurrent.FrameGrabber = fg_Disabled) and (isMPEGSource) then begin
         InsertGrabberFilter (OutputPin, gf_Notify, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleNotify], nil); { will be inserted before the decoder, no topdown problem }
      end;

      if FCurrent.VideoRenderer = vr_None then begin
         WriteLog (nil, sGrey, 'installing display/3');
         Result := InsertNullRenderer (OutputPin, True);
         Exit;
      end;

      if CheckDualDisplay then begin
         WriteLog (nil, sGrey, 'installing display/3');
         if FCurrent.FrameGrabber <> fg_Disabled then begin
            { InsertFilterInline (@CLSID_Colour, SingleText('csc'), @MEDIATYPE_Video, OutputPin);    was required by CVideoGrabberInPin::GetMediaType bug }
         end;
         WriteLog (nil, sGrey, 'installing display/4');
         if not InsertFilterInlineGetFilter (@CLSID_InfTee, SingleText('Inf Tee 2nd rnd'), InfTee, @MEDIATYPE_Video, OutputPin) then Exit;
         WriteLog (nil, sGrey, 'installing display/5');
      end;

      WriteLog (nil, sGrey, 'IVR add rend');
      if (not assigned (F_Overlay)) and (FCurrent.FrameGrabber <> fg_Disabled) and not (isMPEGSource) then begin { if no transparency }
         { if not InsertFilterInline (@CLSID_Colour, SingleText('csc'), @MEDIATYPE_Video, OutputPin) then Exit; }
      end;
      if not AddRendererFilterGetPin (SingleText ('rndr'), @FVideoRendererW, InPin, CanUseVMR, IsVMRUsed) then Exit;

      if F_CaptureGraphBuilder2.RenderStream (nil, nil, OutputPin, nil, FVideoRendererW.RenderFilter) <> S_OK then begin
         F_GraphBuilder.RemoveFilter(FVideoRendererW.RenderFilter);
         ClearWindow (@FVideoRendererW);
         Exit;
      end;

      WriteLog (nil, sGrey, 'IVR cx ok');

      if assigned (OutputPin) then OutputPin := nil;
      RetrieveVideoFormatInfo (InPin);
      Result := true;

      if CheckDualDisplay then begin
         if F_CaptureGraphBuilder2.FindPin (InfTee, PINDIR_OUTPUT, nil, nil, true, 0, OutputPin) = S_OK then begin
            if FCurrent.FrameGrabber <> fg_Disabled then begin
               { InsertFilterInline (@CLSID_Colour, SingleText('csc'), @MEDIATYPE_Video, OutputPin); }
            end;
            if assigned (InPin) then InPin := nil;
            if AddRendererFilterGetPin (SingleText ('rndr'), @FVideoRendererW2, InPin, CanUseVMR, IsVMRUsed) then begin
               Result := Connect (OutputPin, InPin); { no ConnectDirect }
            end;
         end;
      end;

   finally
      if assigned (OutputPin) then OutputPin := nil;
      if assigned (InPin) then InPin := nil;
      if assigned (CxPin) then CxPin := nil;
      if assigned (InfTee) then InfTee := nil;
      if assigned (VideoOut2) then VideoOut2 := nil;
      if assigned (TempPin) then TempPin := nil;
      LogB (not Result, LTRACE, e_failed, 'installing display done');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ReadTimeCode (CurrentFrameInfo: pCurrentFrameInfo): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TimecodeSample: TTimeCode_Sample;
   BCDhh, BCDmm, BCDss, BCDff: LongInt;
begin
   with CurrentFrameInfo^ do begin
    with FrameInfo do begin
     with FCurrentFrameData do begin
      Result := false;
      if not assigned (F_AMTimeCodeReader) then Exit;

      ZeroMemory (@TimeCodeSample, sizeof (TTimeCode_Sample));
      TimeCodeSample.TimeCode.dwFrames := 0;
      TimecodeSample.dwFlags := ED__DEVCAP_TIMECODE_READ;
      if F_AMTimeCodeReader.GetTimeCode (TimecodeSample) = S_OK then begin
         BCDff := (TimecodeSample.timecode.dwFrames and $000000FF);
         BCDss := (TimecodeSample.timecode.dwFrames and $0000FF00) shr 8;
         if (BCDff <> $FF) and (BCDss <> $FF) then begin
            BCDmm := (TimecodeSample.timecode.dwFrames and $00FF0000) shr 16;
            BCDhh := (TimecodeSample.timecode.dwFrames and $FF000000) shr 24;
            DVTimeCode.Hour := (((BCDhh and $F0) shr 4) * 10) + (BCDhh and $0F);
            DVTimeCode.Min := (((BCDmm and $F0) shr 4) * 10) + (BCDmm and $0F);
            DVTimeCode.Sec := (((BCDss and $F0) shr 4) * 10) + (BCDss and $0F);
            DVTimeCode.Ff := (((BCDff and $F0) shr 4) * 10) + (BCDff and $0F);
            DVTimeCode.IsAvailable := True;
            Result := True;
         end
         else begin
            ZeroMemory (@DVTimeCode, sizeof (TDVTimeCode));
         end;
      end
      else begin
         ZeroMemory (@DVTimeCode, sizeof (TDVTimeCode));
      end;
      if Result then begin
         if not CompareMem (@DVTimeCode, @FCurrentFrameData.OldDVTimeCode, sizeof (TDVTimeCode)) then begin
            Windows.CopyMemory (@FCurrentFrameData.OldDVTimeCode, @DVTimeCode, sizeof (TDVTimeCode));
            Result := True;
         end
         else begin
            Result := False;
         end;
      end;
    end;
   end;
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AutoGenerateFileName (AutoFileNameType: TAutoFileNameType; Extension: string; var AutoFileSequentialCountIndex: LongInt): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ generates automatically a file name
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   sFileNum: string;
   Counter: LongInt;
begin
   if not assigned (_SyncManager) then begin
      Result := '';
   end
   else begin
      if FAutoFileName = fn_sequential then begin
         Counter := 1;
         case AutoFileNameType of
            afn_BmpFile  : Counter := _SyncManager.GetNextFileSequentialCount (CurrentStoragePath, FAutoFilePrefix, 'bmp', AutoFileSequentialCountIndex);
            afn_JpegFile : Counter := _SyncManager.GetNextFileSequentialCount (CurrentStoragePath, FAutoFilePrefix, 'jpg', AutoFileSequentialCountIndex);
            afn_Custom   : Counter := _SyncManager.GetNextFileSequentialCount (CurrentStoragePath, FAutoFilePrefix, Extension, AutoFileSequentialCountIndex);
         end;
         sFileNum:= IntToStr (Counter);
         while length (sFileNum) < 6 do begin
            sFileNum:= '0' + sFileNum;
         end;
      end
      else begin
         sFileNum:= FormatDateTime ('yymmdd_hhmmss_zzz', Now);
      end;
      case AutoFileNameType of
         afn_BmpFile  : Result := CurrentStoragePath + FAutoFilePrefix + sFileNum + '.bmp';
         afn_JpegFile : Result := CurrentStoragePath + FAutoFilePrefix + sFileNum + '.jpg';
         afn_Custom   : Result := CurrentStoragePath + FAutoFilePrefix + sFileNum + '.' + Extension;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function  TVdgr.NoDevicesOrIndexOutOfRange (Index: LongInt; Count: LongInt; DeviceType: String) : Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if Count = 0 then begin
      Result := LogB (TRUE, LINFO, e_no_device_available, 'no ' + DeviceType + ' available');
   end
   else begin
      Result := LogB ((Index >= 0) and (Index >= Count), LERROR, e_index_out_of_range, 'index of ' + DeviceType + ' out of range');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ChangeGraphState (NewState: TFilter_State; LogTrace: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ change the running state of the current graph
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := false;
   if not assigned (F_MediaControl) then Exit;

   if NewState <> state_Stopped then begin // for 1st frame when recording starts
      if assigned (F_AMTimeCodeReader) then begin
         ReadTimeCode (@FFrameInfo_Current);
         Windows.CopyMemory (@FFrameInfo_Grabber.FrameInfo.DVTimeCode, @FFrameInfo_Current.FrameInfo.DVTimeCode, sizeof (TDVTimeCode));
      end;
   end;

   case NewState of
      state_Stopped: begin
         FGraphAccessAllowed := False;
         WriteLog (nil, sBlue, 'ch graph state stopped ' + LogTrace);
         FCurrentFrameData.LastFrameAvailable := False;
         Result := Succeeded (F_MediaControl.Stop);
         FFilterState := State_Stopped;
      end;
      state_Paused:  begin
         WriteLog (nil, sBlue, 'ch graph state paused ' + LogTrace);
         if (FGraphType = cs_Playback) and FCurrent.PlayerAudioRendering then begin // positionning problems if done without audio
            ApplyPlayerSpeedRatio (1);
         end;
         Result := Succeeded (F_MediaControl.Pause);
         FFilterState := State_Paused;
         FCheckVMR7Location := (FCurrent.VideoRenderer = vr_VMR7);
         FGraphAccessAllowed := True;
      end;
      state_Running: begin
         if FFilterState = State_Stopped then begin
            //Sleep (20);
         end;
         FCurrentFrameData.LastFrameAvailable := False;

         ApplyPlayerSpeedRatio (FPlayerSpeedRatio);

         WriteLog (nil, sBlue, 'ch graph state running ' + LogTrace);
         F_MediaControl.Stop;
         Result := Succeeded (F_MediaControl.Run);
         if not Result then begin
            F_MediaControl.Stop;
            Result := Succeeded (F_MediaControl.Run);
            if Result then begin
               WriteLog (nil, sBlue, 'successfully restarted ' + LogTrace);
            end
            else begin
               WriteLog (nil, sRed, 'ERROR: failed to run' + LogTrace);
               F_MediaControl.Stop;
            end;
         end;
         FFilterState := State_Running;

         //Sleep (50); // minimizes black video

         FGraphAccessAllowed := True;

      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ReadStoredInterfaceValues;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ Closes the current graph, if any.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      if assigned (F_AMAnalogVideoDecoder) then begin
         F_AMAnalogVideoDecoder.Get_TVFormat (FVideoRegSave[_ANVTVFormat].i);
         F_AMAnalogVideoDecoder.Get_VCRHorizontalLocking(FVideoRegSave[_ANVVCRHorzLocking].i);
         F_AMAnalogVideoDecoder.Get_OutputEnable(FVideoRegSave[_ANVOutputEnable].i);
      end;

      if assigned (F_AMVideoCrossbar) then begin
         FVideoRegSave[_VIDEOCROSSBARAVAIL].b := true;
         FVideoRegSave[_AMVideoCrossbar].s := SaveCrossbarState (F_AMVideoCrossbar);
      end;

      if assigned (F_AMAudioCrossbar) then begin
         FVideoRegSave[_AUDIOCROSSBARAVAIL].b := true;
         FVideoRegSave[_AMAudioCrossbar].s := SaveCrossbarState (F_AMAudioCrossbar);
      end;

      TVRetrieveState;

      RetrieveVideoQualityCurrentSettings;
      RetrieveCameraControlCurrentSettings;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RefreshPreview (LogTrace: String);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if IsInDesignMode then Exit;
   if FAutoRefreshPreview then begin
      if FVideoDevice = -1 then Exit;
      Allow ([cs_Down, cs_Preview], LERROR, True);
      if (FGraphType = cs_Preview) or ((FGraphType = cs_Down) and FLastPreviewFailed) then begin
         WriteLog (nil, sPurple, 'REFRESHING PREVIEW FROM ' + LogTrace);
         Intf.StartPreview;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.PostStopGraphMessage;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ Closes the current graph, if any.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FGraphType = cs_Down then Exit;
   PostCommand (WMStopGraph);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ClearGraph (ClearGraphState: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ Closes the current graph, if any.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
   j: LongInt;
   LiveSourceWasRunning: Boolean;
begin

      LiveSourceWasRunning := IsLiveVideoSource and (FGraphType in [cs_Preview, cs_Recording]) and (FFilterState <> State_Stopped);

      FGraphAccessAllowed := False;

      if assigned (FAutoTuningStepThread) then begin
         FAutoTuningStepThread.SuspendOrTerminateIfDestroying (FDestroying);
      end;

      ClearAudioDeviceRendering (@FAudioRendering);

      FIsTVAutoTuneRunning := False;

      FPlayerBackwardTimerEnabled := False;

      WriteLog (nil, sPurple, 'begin clear');

      //ClearPpSaver (@FPpSaver_VideoDevice);
      ClearPpSaver (@FPpSaver_MPEGWriter);

      ClearWindow (@FVideoRendererW);
      ClearWindow (@FVideoRendererW2);

      ChangeGraphState (state_Stopped, 'clear');

      if FMultiplexedRole = mr_MultiplexedMaster then begin
         for i := MULTIPLEXEDSLAVE_MINBOUND to MULTIPLEXEDSLAVE_MAXBOUND do begin
             if assigned (FMultiplexedSlave[i].Vdgr) then begin
                if not FMultiplexedSlave[i].Vdgr.FDestroying then begin
                   FMultiplexedSlave[i].Vdgr.ChangeGraphState (state_Stopped, 'clearslaver');
                end;
             end;
         end;
      end;

      WriteLog (nil, sBlue, 'stopped');

      //if not FDestroying then begin
      //   FlushMessages; // ZZZZZ
      //end;

      if FGraphType = cs_Recording then begin
         if FSaveSequentialFileCount <> -1 then begin
            if not FRecordingStarted then begin
               if assigned (_SyncManager) then begin
                  if FSaveSequentialFileCount = _SyncManager.GetAutoFileSequentialCount (FRecordingAutoFileSequentialCountIndex) then begin
                     _SyncManager.DecAutoFileSequentialCount (FRecordingAutoFileSequentialCountIndex);
                     if FTemporaryRecordingFileName = FRealRecordingFileName then begin { not preallocated }
                        DeleteFile (FTemporaryRecordingFileName);
                     end;
                  end;
               end;
            end;
         end;
         FSaveSequentialFileCount := -1;
      end;

      if ClearGraphState then begin
         FGraphType := cs_Down;
         FCurrentParamsInitialized := False;
      end;

      FRecordingStarted:= false;

      WriteLog (nil, sBlue, 'cleared');

      ReinitCurrentFrameData;
      ReinitFrameInfos;

      if LiveSourceWasRunning then begin
         ReadStoredInterfaceValues;
      end;

      WriteLog (nil, sBlue, 'saved');

      if assigned (F_MediaEventEx) then begin
         F_MediaEventEx.SetNotifyWindow(0, WM_NOTIFYWINDOW, 0);
         F_MediaEventEx.SetNotifyFlags(AM_MEDIAEVENT_NONOTIFY);
      end;

      for j := 0 to TThirdPartyFilterListBound do begin
          for i := 0 to ThirdPartyFilterMaxCount - 1 do begin
              with FThirdPartyFilter[j, i] do begin
                   if assigned (Filter) then Filter := nil;
                   if assigned (FilterIntf) then FilterIntf := nil;
              end;
          end;
      end;

      if assigned (F_ScCapturePinVideo) then F_ScCapturePinVideo := nil;
      if assigned (F_ScCapturePinAudio) then F_ScCapturePinAudio := nil;

      if assigned (F_VideoDeviceSelectedPin) then F_VideoDeviceSelectedPin := nil;
      if assigned (F_PushSourceConfig) then F_PushSourceConfig := nil;
      if assigned (F_AMGraphStreams) then F_AMGraphStreams := nil;
      if assigned (F_AMAnalogVideoDecoder) then F_AMAnalogVideoDecoder:= nil;
      if assigned (F_AMAudioCrossbar) then F_AMAudioCrossbar:= nil;
      if assigned (F_AMAudioDevCrossbar) then F_AMAudioDevCrossbar:= nil;
      if assigned (F_AMDroppedFrames) then F_AMDroppedFrames:= nil;
      if assigned (F_AMExtTransport) then F_AMExtTransport:= nil;
      if assigned (F_AMTimeCodeReader) then F_AMTimeCodeReader:= nil;
      if assigned (F_AMTVAudio) then F_AMTVAudio:= nil;
      if assigned (F_AMTVTuner) then F_AMTVTuner:= nil;
      if assigned (F_AMVideoControl) then F_AMVideoControl:= nil;
      if assigned (F_AMVideoCrossbar) then F_AMVideoCrossbar:= nil;
      if assigned (F_AMVideoQuality) then F_AMVideoQuality:= nil;
      if assigned (F_AMCameraControl) then F_AMCameraControl:= nil;
      if assigned (F_AMVideoStreamConfig) then F_AMVideoStreamConfig:= nil;
      if assigned (F_AMAudioInputMixerPin) then F_AMAudioInputMixerPin:= nil;
      if assigned (F_AMAudioInputMixerGeneral) then F_AMAudioInputMixerGeneral:= nil;
      if assigned (F_AudioCompressor) then F_AudioCompressor:= nil;
      if assigned (F_AudioDevice) then F_AudioDevice:= nil;
      if assigned (F_ASFFileMux) then F_ASFFileMux:= nil;
      if assigned (F_AVIFileMux) then F_AVIFileMux:= nil;
      if assigned (F_ASFFileSink) then F_ASFFileSink:= nil;
      if assigned (F_MediaControl) then F_MediaControl:= nil;
      if assigned (F_IQualProp) then F_IQualProp:= nil;
      if assigned (F_MediaSeeking) then F_MediaSeeking:= nil;
      if assigned (F_VideoFrameStep) then F_VideoFrameStep:= nil;
      if assigned (F_MediaEventEx) then F_MediaEventEx:= nil;
      if assigned (F_ReferenceClock) then F_ReferenceClock:= nil;
      if assigned (F_CustomClock) then F_CustomClock := nil;
      if assigned (F_VideoCompressor) then F_VideoCompressor:= nil;
      if assigned (F_VideoDevice) then F_VideoDevice:= nil;
      if assigned (F_VideoDeviceKsPropertySet) then F_VideoDeviceKsPropertySet:= nil;
      if assigned (F_VideoCapturePin) then F_VideoCapturePin:= nil;
      if assigned (F_AudioRecordingPin) then F_AudioRecordingPin:= nil;
      if assigned (F_VideoPreviewPin) then F_VideoPreviewPin:= nil;
      if assigned (F_AudioRenderPin) then F_AudioRenderPin:= nil;
      if assigned (F_Overlay) then F_Overlay:= nil;
      if assigned (F_ScPreviewPin) then F_ScPreviewPin:= nil;
      if assigned (F_GraphVideoWindow) then F_GraphVideoWindow:= nil;
      if assigned (F_TransformConfig) then F_TransformConfig:= nil;
      if assigned (F_ScCapturePinVideo) then F_ScCapturePinVideo := nil;
      if assigned (F_ScCapturePinAudio) then F_ScCapturePinAudio := nil;

      if assigned (F_WMWriterNetworkSink) then begin
         F_WMWriterNetworkSink.Close;
         F_WMWriterNetworkSink := nil;
      end;
      if assigned (F_WMWriterPushSink) then begin
         F_WMWriterPushSink.Disconnect;
         F_WMWriterPushSink := nil;
      end;

      FCrossbar[LongInt(cs_VideoCrossbar)].Clear;
      FCrossbar[LongInt(cs_AudioCrossbar)].Clear;

      if assigned (F_GraphBuilder) then begin
         RemoveFilters;

      end;

      if assigned (F_FilterGraph2) then F_FilterGraph2 := nil;
      if assigned (F_GraphBuilder) then F_GraphBuilder:= nil;
      if assigned (F_CaptureGraphBuilder2) then F_CaptureGraphBuilder2:= nil;

      WriteLog (nil, sGrey, 'interfaces cl');

      if assigned (FCrossbarAutoRouter) then begin
         FCrossbarAutoRouter.Free;
         FCrossbarAutoRouter := nil;
      end;

      FPlayerCanSeek := True;
      FGetTimeFromClock:= False;
      FRealFrameRate := 0;
      FPlayerCanRefreshPosition := False;

      ClearWindow (@FOverlayRendererW);

      if not FDestroying then Intf.Repaint;

      WriteLog (nil, sBlue, 'all cleared');

      ClearSampleCaptureInfo (@FSampleInfoVideo);
      ClearSampleCaptureInfo (@FSampleInfoAudio);

      FIsRecordingPaused := False;
      FVideoPinCategoryUsed := @PIN_CATEGORY_CAPTURE;

      if assigned (FpVideoDeviceInUse) then begin
         FpVideoDeviceInUse^ := False;
         FpVideoDeviceInUse := nil;
      end;

      while FRecordingBacktimedFramesArray.Count > 0 do begin
         if HBITMAP(FRecordingBacktimedFramesArray[0]) <> 0 then begin
            DeleteObject (HBITMAP(FRecordingBacktimedFramesArray[0]));
         end;
         FRecordingBacktimedFramesArray.Delete (0);
      end;

      FVideoWindow.FAssociatedRenderer := nil;
      FVideoWindow.FActivated := False;

      FVideoWindow2.FAssociatedRenderer := nil;
      FVideoWindow2.FActivated := False;

      FVideoRendererW.FAssociatedWindow := nil;
      FVideoRendererW2.FAssociatedWindow := nil;
      FOverlayRendererW.FAssociatedWindow := nil;

      FIsAudioInputBalanceAvailable := ts_Undefined;
      FOutputFileName := '';
      FMPEGWriterBaseFilterName:= '';
      FUseMasterStream := ms_AudioMaster;

      FIsTVAutoTuneRunning := False;
      FIsTunerInputSelected := False;
      FTVScanStopRequest := False;
      FTVScanCurrentCountryCode := -1;
      FTVScanCurrentTunerInputType := -1;
      FTVFrequencyOverrideInUse:= False;
      FRenderingAudio := False;
      FMPEGWriterFilter := '';
      FIsPlayerAudioStreamAvailable := ts_Undefined;
      FStreamingURL := '';
      FPlayerDuration := 1;
      FCheckVMR7Location := False;
      FPlayerAudioCodec:= '';
      FPlayerVideoCodec:= '';

      ClearMutedAudioDeviceInput;

      with FVideoFromImages do begin
         if InUse then begin
            InUse := False;
            if assigned (BitmapsFileStream) then begin
               BitmapsFileStream.Free;
               BitmapsFileStream := nil;
            end;
         end;
      end;

      if FSavedVolume <> -1 then begin
         SetMixerVolume (FSavedVolume, FSavedBalance);
      end;

      if assigned (FExternalSourceFrameData.FrameData) then begin
         FreeMem (FExternalSourceFrameData.FrameData);
         FExternalSourceFrameData.FrameData := nil;
      end;
      FExternalSourceFrameData.CanAccessFrame := False;
      FExternalSourceFrameData.CanCreateNewFrame := True;

      if assigned (FFrameInfo_Current.FrameBitmapData.FrameBitmap) then begin
         FFrameInfo_Current.FrameBitmapData.FrameBitmap.Free;
         FFrameInfo_Current.FrameBitmapData.FrameBitmap := nil;
      end;
      if assigned (FFrameInfo_Grabber.FrameBitmapData.FrameBitmap) then begin
         FFrameInfo_Grabber.FrameBitmapData.FrameBitmap.Free;
         FFrameInfo_Grabber.FrameBitmapData.FrameBitmap := nil;
      end;
      if assigned (FFrameInfo_Transmit.FrameBitmapData.FrameBitmap) then begin
         FFrameInfo_Transmit.FrameBitmapData.FrameBitmap.Free;
         FFrameInfo_Transmit.FrameBitmapData.FrameBitmap := nil;
      end;

      if FMultiplexedRole = mr_MultiplexedSlave then begin
         if assigned (FSlaveMultiplexedData.LastFrameData) then begin
            FreeMem (FSlaveMultiplexedData.LastFrameData);
            FSlaveMultiplexedData.LastFrameData := nil;
         end;
         FSlaveMultiplexedData.CanAccessLastFrame := False;
         FSlaveMultiplexedData.CanCreateLastFrame := True;
      end;

      DeleteMediaType (FFrameGrabberMediaType);
      FFrameGrabberMediaType := nil;

      FMotionDetector.FReset := True;
      FMotionDetector.FLatestFrameTime := -1;

      FSavedVolume := -1;
      FSavedBalance := -1;
      FStreamingHostName:= '';
      FStreamingHostPort:= 0;
      FPlayerFailedToInsertFrameGrabber := False;


      ClearGrabberHandlers (False);

      ClearOldSavedFrame;
      
      FGraphState := gs_None;

      CopyGUID (@FRecordingSubtype, @GUID_NULL);

      WriteLog (nil, sPurple, 'end clear');
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function EnumWindows_StoreAll (Handle: Hwnd; Param: LPARAM): BOOL; stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
type
   pHwnd = ^Hwnd;
var
   wCaption: array[0..200] of Char;
begin
   Result := true;
   //if GetWindowText (Handle, wCaption, 200) <> 0 then begin
   if GetClassName (Handle, wcaption, 200) <> 0 then begin
      //if wCaption = 'ActiveMovie Window' then begin
      if wCaption = 'VideoRenderer' then begin
         pHWND (Param)^ := Handle;
         Result := False;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.FindVideoWindow (Renderer: pRenderer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not assigned (Renderer) then Exit;
   with Renderer^ do begin
      RenderHandle := 0;
      if assigned (Display) then begin
         EnumChildWindows (Display.Handle, @EnumWindows_StoreAll, LongInt (@RenderHandle));
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ClearWindow (Renderer: pRenderer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not assigned (Renderer) then Exit;
   with Renderer^ do begin
      if assigned (Display) then begin
         if assigned (FAssociatedWindow) then begin
            if not FAssociatedWindow.FBool[vwFullScreen] then begin
               if not FDestroying then begin
                  ChangeDisplayParent (Renderer, True); // required otherwise OCX exits on ClearGraph
                  Display.Visible := False;
               end;
           end;
         end;
      end;
      if assigned (VideoWindow) then begin
         VideoWindow.Put_Visible (False);
         VideoWindow := nil;
      end;
      if assigned (RenderFilter) then RenderFilter := nil;

      if RenderHandle <> 0 then begin
         RenderHandle := 0;
      end;
      DisplayInUse := False;
      IsOverlay := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.GetWindowHandle (Renderer: pRenderer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not assigned (Renderer) then Exit;
   with Renderer^ do begin
      if not assigned (RenderFilter) then Exit;
      if not assigned (Renderer^.Display) then begin
         CreateDisplayForm (Renderer);
      end;
      if RenderFilter.QueryInterface (IVideoWindow, VideoWindow) = S_OK then begin
         VideoWindow.Put_AutoShow (False);
      end;
      RenderFilter.QueryInterface (IQualProp, F_IQualProp);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ChangeDisplayParent (Renderer: pRenderer; UnSetParent: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      if not assigned (Renderer) then Exit;
      with Renderer^ do begin
         if assigned (FAssociatedWindow) then begin
            if not FAssociatedWindow.FBool[vwFullScreen] then begin
               Display.Visible := False;
               //if not FDestroying then FlushMessages; ZZZZZ
            end;
         end
         else begin
            Display.Visible := False;
            //if not FDestroying then FlushMessages;
         end;

         if assigned (VideoWindow) then begin
            VideoWindow.put_Visible (False);
            VideoWindow.put_Owner(FAssociatedWindow.FHandleForIVideoWindow);
         end;

         //if IsWindowEmbedded (FAssociatedWindow) then begin EXITS OCX
         if (not UnSetParent) and IsWindowEmbedded (FAssociatedWindow) then begin
            Display.Parent := Intf;
            Display.Align := alClient;
            Display.Color := FBackgroundColor;
         end
         else begin
            Display.Align := alNone;
            Display.Parent := nil;
            if assigned (FAssociatedWindow) then begin
               if FAssociatedWindow.FBool[vwStayOnTop] <> (Display.FormStyle = fsStayOnTop) then begin
                  case FAssociatedWindow.FBool[vwStayOnTop] of
                       true : Display.FormStyle := fsStayOnTop;
                       false: Display.FormStyle := fsNormal;
                  end;
               end;
            end;
         end;

         if assigned (VideoWindow) then begin
            VideoWindow.put_Visible (False);
            VideoWindow.put_Owner(Display.Handle);
            VideoWindow.put_WindowStyle(WS_CHILD); { or WS_CLIPSIBLINGS); }
            VideoWindow.Put_MessageDrain (Display.Handle);
            VideoWindow.put_Visible (True);
         end;

         Display.Color := FBackgroundColor;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.AssignPpSaver (ppSaver: pPpSaver; InterfaceId: String; RegInterfaceId: String);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not assigned (ppSaver) then Exit;
   with ppSaver^ do begin
      if not assigned (ppInstance) then begin
         ppInstance := FPropertyPageSaver.CreateNewInstance (Intf);
         { ppInstance.SetIdentifyProperties (True); }
      end;
      ppInstance.SetRegistryKey (RegInterfaceId);
      ppInstance.SetDialogTitle (InterfaceId);
      ppInstance.SetRegistrySubKey ('PPSaver');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.BindPpSaver (ppSaver: pPpSaver; ppInterface: IUnknown): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with ppSaver^ do begin
      Result := False;
      if not assigned (ppInstance) then Exit;
      if ppInstance.Activate (ppInterface) then begin
         Result := True;
         if ppRestoreProperties then begin
            Result := ppInstance.RestoreProperties;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ClearPpSaver (ppSaver: pPpSaver);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with ppSaver^ do begin
      if assigned (ppInstance) then begin
         if ppSaveProperties then begin
            ppInstance.SaveProperties;
         end;
         ppInstance.Deactivate;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.BindAndAddCompressor (var FilterGraph: IFilterGraph2; var DeviceClass: TDevices; var CurrentDevice: LongInt; ForcedName: String; out DeviceFilter: IBaseFilter; DoLogInfo: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Dummy: pBoolean;
begin
   Result := BindAndAddDevice (FilterGraph, DeviceClass, CurrentDevice, ForcedName, DeviceFilter, false, Dummy, DoLogInfo, '');
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AddFilterByName (ClassId: pGUID; FilterName: String; MonikerNameId: TMonikerNameId; out Filter: IBaseFilter): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Moniker: IMoniker;
   FriendlyName: String;
   OleStr: pOleStr;
begin
   Result := False;
   try
      if not RetrieveMoniker (ClassId, FilterName, MonikerNameId, Moniker, FriendlyName) then Exit;
      if not assigned (Moniker) then Exit;
      Result := F_FilterGraph2.AddSourceFilterForMoniker (Moniker, nil, OleS(FriendlyName, OleStr), Filter) = S_OK;
      SysFreeString (OleStr);
   finally
      if assigned (Moniker) then Moniker := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.BindAndAddDevice (var FilterGraph: IFilterGraph2; var DeviceClass: TDevices; var CurrentDevice: LongInt; ForcedName: String; out DeviceFilter: IBaseFilter; CheckSingleBindedDevice: Boolean; var pSingleBindedDevice: pBoolean; DoLogInfo: Boolean; InputName: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ binds the CurrentDevice moniker to the filter (if not already done),
{ then adds the filter to the graph
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   hr: Hresult;
   Moniker: IMoniker;
   FriendlyName: String;
   OleStr: pOleStr;
   FilterName: String;
begin
   Result := false;
   try
      if LogB (CurrentDevice = -1, LWARNING, e_index_out_of_range, DeviceClass.FDeviceClassName + ' not selected!') then Exit;
      if DeviceClass.Count < 1 then Exit;
      if (CurrentDevice < 0) or (CurrentDevice >= DeviceClass.Count) then begin
         CurrentDevice := 0;
         LogB (true, LERROR, e_index_out_of_range, DeviceClass.FDeviceClassName + ' index out of range, index 0 used instead');
      end;

      if CheckSingleBindedDevice then begin
         if LogB (TCapDeviceInfo(DeviceClass.FDevices.Objects[CurrentDevice]).InUse, LERROR, e_device_in_use_in_another_graph, DeviceClass.FDevices[CurrentDevice] + ' is already in use') then Exit;
      end;

      if DoLogInfo then begin
         if InputName = '' then begin
            LogB (True, LINFO, i_binding_device_or_compressor, 'using ' + DeviceClass.FDeviceClassName + ': ' + DeviceClass.FDevices[CurrentDevice]);
         end
         else begin
            LogB (True, LINFO, i_binding_device_or_compressor, 'using ' + DeviceClass.FDeviceClassName + ':' + #13#10 + DeviceClass.FDevices[CurrentDevice] + #13#10 + 'on input ' + InputName);
         end;
      end;
      if not RetrieveMoniker (@TCapDeviceInfo(DeviceClass.FDevices.Objects[CurrentDevice]).ClsidDeviceClass, TCapDeviceInfo(DeviceClass.FDevices.Objects[CurrentDevice]).RegistryStringId, mk_UseFormat, Moniker, FriendlyName) then Exit;
      if ForcedName <> '' then begin
         FilterName := ForcedName;
      end
      else begin
         FilterName := IntToStr (CurrentDevice) + ' ' + DeviceClass.FDevices[CurrentDevice];
      end;
      Hr := FilterGraph.AddSourceFilterForMoniker (Moniker, nil, OleS (FilterName, OleStr), DeviceFilter);
      SysFreeString (OleStr);
      if not LogH (Hr, LERROR, e_bind_moniker_to_filter, 'bind ' + DeviceClass.FDevices[CurrentDevice] + ' device moniker to filter') then Exit;
      if CheckSingleBindedDevice then begin
         pSingleBindedDevice := @TCapDeviceInfo(DeviceClass.FDevices.Objects[CurrentDevice]).InUse;
         pSingleBindedDevice^ := True;
      end;
      Result := true;
   finally
      if assigned (Moniker) then Moniker := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure ReinitFrameInfo (CurrentFrameInfo: pCurrentFrameInfo);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with CurrentFrameInfo^ do begin
      with FrameInfo do begin
         FrameNumber := 0;
         FrameTime := 0;
         DroppedFrameCount := 0;
         SampleTime_TotalMin:= 0;
         SampleTime_TotalSec:= 0;
         SampleTime_TotalHs:= 0;
         SampleTime_Hour:= 0;
         SampleTime_Min:= 0;
         SampleTime_Sec:= 0;
         SampleTime_Hs:= 0;
         ZeroMemory (@DVTimeCode, sizeof (TDVTimeCode));
         ZeroMemory (@DVDateTime, sizeof (TDVDateTime));
      end;
      CurrentFrameNumber := 0;
      CurrentFrameTime := 0;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ReinitFrameInfos;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   ReinitFrameInfo (@FFrameInfo_Current);
   ReinitFrameInfo (@FFrameInfo_Grabber);
   ReinitFrameInfo (@FFrameInfo_Transmit);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ReinitCurrentFrameData;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin

   with FCurrentFrameData do begin

      ReturnOneShotFrame := False; // TOCOMPLETE
      ReturnBurstModeFrame := False;
      OneShotDest:= fc_TBitmap;
      OneShotFileName := '';

      if assigned (PreviousFrameBitmapData.FrameBitmap) then begin
         PreviousFrameBitmapData.FrameBitmap.Free;
      end;
      PreviousFrameBitmapData.FrameBitmap := nil;

      ThreadPausedPlayerRefreshCount := MAXREFRESHFRAMECOUNT - 1;
      ThreadOldPosition := -1;
      ThreadOldFrameNumber := -1;
      ThreadNewFrameNumber := -1;
      ThreadAMExtTransportRefreshCount := 0;
      ThreadTransportOldState:= -1;
      ThreadOldReencodingPercent := -1;
      ThreadReencodingRefreshCount := 0;

      PlayerStepClockCount := Round (DEFAULTPLAYERSTEPSLEEPTIME / FNotificationSleepTimeUsed);
      PlayerStepClocki := 0;
      PlayerDoNotNotifyNextFrame := False;

      SettingNewPosition := False;
      NewFrameNotNotifiedByFrameGrabber := False;
      NewFrameAvailable := False;
      RequestLastFrame := False;
      LastFrameAvailable := False;

      OneShotSampleAvailable:= false;
      OneShotCaptureWaiting:= False;
      OneShotCaptureSuccess:= False;

      DrawingOverFrames := False;
      DrawingOverFramesDxDc := 0;
      PlayerEmulateSpeedRatio := False;
      PlayerEmulateSpeedRatioTickCountInterval := 0;
      PlayerStepClockLastTickCount := 0;
      PlayerStepClockLastPosition := 0;
      PlayerStepClockCalculatedNewPositionShift_100ns := 0;
      PlayerTrackBarNewPosition := -1;
      PlayerTrackBarNewPositionSet := True;
      PlayerEndOfStreamReached := False;

      InitialDroppedCount := 0;
      RealFrameTime := 0;
      HoldStreamingFrameTime := 0;
      PausedFrameTime := 0;
      InitialFrameNumber := -1;
      InitialFrameTime := -1;

      MustPausePreview:= False;

      gfNotifyPreviousTick := GetTickCount;

      PlayerPausedType := ppt_None;
      PlayerFastSeek := False;
      PLayerSeekBackwards := False;

      OldDVTimeCode.IsAvailable := False;
      OldDVTimeCode.Hour:= 0;
      OldDVTimeCode.Min:= 0;
      OldDVTimeCode.Sec:= 0;
      OldDVTimeCode.Ff:= 0;
      OldDVTimeCode.TrackNumber:= 0;
      DVCommandState := -1;

      PlayerFrameInterval := 1;
      AVIFrameCapturePaused := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CurrentCaptureFileExt: String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := FCaptureFileExt;
   if (Result = '') or (Result = 'default') then begin
      case FCurrent.RecordingMethod of
         rm_ASF         : Result := 'asf';
      else
         Result := 'avi';
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function VideoSubtypeIndexFromFourCC (VideoSubtypes: TStringList; FourCC: String): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
   Done: Boolean;
begin
   Result := -1;
   Done := False;
   i := 0;
   while not Done do begin
       if i >= VideoSubtypes.Count then begin
          Done := True;
       end
       else begin
          if ReturnFourCC (VideoSubtypes[i]) = FourCC then begin
             Result := i;
             Done := True;
          end;
          inc (i);
       end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure SelectFrameGrabberFormatFromVideoSubtype (FourCC: String; var FrameGrabberRGBFormat: TFrameGrabberRGBFormat);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FourCC = 'RGB32' then begin
      FrameGrabberRGBFormat := fgf_RGB32;
   end
   else if FourCC = 'RGB24' then begin
      FrameGrabberRGBFormat := fgf_RGB24;
   end
   else if FourCC = 'RGB565' then begin
      FrameGrabberRGBFormat := fgf_RGB565;
   end
   else if FourCC = 'RGB555' then begin
      FrameGrabberRGBFormat := fgf_RGB555;
   end
   else begin
      if GetScreenColorCount = 24 then begin
         FrameGrabberRGBFormat := fgf_RGB24;
      end
      else begin
         FrameGrabberRGBFormat := fgf_RGB32;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function SelectVideoSubtypeFromRGB24Or32 (VideoSubtypes: TStringList; var FrameGrabberRGBFormat: TFrameGrabberRGBFormat): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   SubtypeRGB24: LongInt;
   SubtypeRGB32: LongInt;
   SubtypeRGB656: LongInt;
   SubtypeRGB555: LongInt;
   PreferredColorCount: LongInt;
begin
            Result := -1;

            PreferredColorCount := GetScreenColorCount;

            if FrameGrabberRGBFormat = fgf_RGB32 then begin
               PreferredColorCount := 32;
            end
            else if FrameGrabberRGBFormat = fgf_RGB24 then begin
               PreferredColorCount := 24;
            end;

            SubtypeRGB24 := VideoSubtypeIndexFromFourCC (VideoSubtypes, 'RGB24');
            SubtypeRGB32 := VideoSubtypeIndexFromFourCC (VideoSubtypes, 'RGB32');
            SubtypeRGB656 := VideoSubtypeIndexFromFourCC (VideoSubtypes, 'RGB565');
            SubtypeRGB555 := VideoSubtypeIndexFromFourCC (VideoSubtypes, 'RGB555');

            if Result = -1 then begin
               if (PreferredColorCount = 24) and (SubtypeRGB24 <> -1) then begin
                  Result := SubtypeRGB24;
                  FrameGrabberRGBFormat := fgf_RGB24;
               end;
            end;

            if Result = -1 then begin
               if (PreferredColorCount = 32) and (SubtypeRGB32 <> -1) then begin
                  Result := SubtypeRGB32;
                  FrameGrabberRGBFormat := fgf_RGB32;
               end;
            end;

            if Result = -1 then begin
               if (PreferredColorCount = 16) and (SubtypeRGB656 <> -1) then begin
                  Result := SubtypeRGB656;
                  FrameGrabberRGBFormat := fgf_RGB32;
               end;
            end;

            if Result = -1 then begin
               if (PreferredColorCount = 16) and (SubtypeRGB555 <> -1) then begin
                  Result := SubtypeRGB555;
                  FrameGrabberRGBFormat := fgf_RGB32;
               end;
            end;

            if Result = -1 then begin
               if (PreferredColorCount <> 24) then begin
                  FrameGrabberRGBFormat := fgf_RGB32;
               end
               else begin
                  FrameGrabberRGBFormat := fgf_RGB24;
               end;
               if SubtypeRGB24 <> -1 then begin
                  Result := SubtypeRGB24;
               end
               else if SubtypeRGB32 <> -1 then begin
                  Result := SubtypeRGB32;
               end
               else if SubtypeRGB656 <> -1 then begin
                  Result := SubtypeRGB656;
               end
               else if SubtypeRGB555 <> -1 then begin
                  Result := SubtypeRGB555;
               end
            end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function SelectVideoSubtypeFromRGB (VideoSubtypes: TStringList; var FrameGrabberRGBFormat: TFrameGrabberRGBFormat): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   SubtypeRGB24: LongInt;
   SubtypeRGB32: LongInt;
   SubtypeRGB565: LongInt;
   SubtypeRGB555: LongInt;
   SubtypeRGB8: LongInt;

   function ReturnPreferredSubtype (Subtype1, Subtype2, Subtype3, Subtype4, Subtype5: LongInt): LongInt;
   begin
      if      Subtype1 <> -1 then Result := SubType1
      else if Subtype2 <> -1 then Result := SubType2
      else if Subtype3 <> -1 then Result := SubType3
      else if Subtype4 <> -1 then Result := SubType4
      else if Subtype5 <> -1 then Result := SubType5
      else Result := -1;
   end;
begin
            Result := -1;

            SubtypeRGB24 := VideoSubtypeIndexFromFourCC (VideoSubtypes, 'RGB24');
            SubtypeRGB32 := VideoSubtypeIndexFromFourCC (VideoSubtypes, 'RGB32');
            SubtypeRGB565 := VideoSubtypeIndexFromFourCC (VideoSubtypes, 'RGB565');
            SubtypeRGB555 := VideoSubtypeIndexFromFourCC (VideoSubtypes, 'RGB555');
            SubtypeRGB8 := VideoSubtypeIndexFromFourCC (VideoSubtypes, 'RGB8');

            if Result = -1 then begin
               if (FrameGrabberRGBFormat = fgf_RGB24) then begin
                  Result := ReturnPreferredSubtype (SubtypeRGB24, SubtypeRGB32, SubtypeRGB565, SubtypeRGB555, SubtypeRGB24);
               end;
            end;

            if Result = -1 then begin
               if (FrameGrabberRGBFormat = fgf_RGB32) then begin
                  Result := ReturnPreferredSubtype (SubtypeRGB32, SubtypeRGB24, SubtypeRGB565, SubtypeRGB555, SubtypeRGB24);
               end;
            end;

            if Result = -1 then begin
               if (FrameGrabberRGBFormat = fgf_RGB565) then begin
                  Result := ReturnPreferredSubtype (SubtypeRGB565, SubtypeRGB32, SubtypeRGB565, SubtypeRGB24, SubtypeRGB24);
               end;
            end;

            if Result = -1 then begin
               if (FrameGrabberRGBFormat = fgf_RGB555) then begin
                  Result := ReturnPreferredSubtype (SubtypeRGB555, SubtypeRGB565, SubtypeRGB32, SubtypeRGB24, SubtypeRGB24);
               end;
            end;

            if Result = -1 then begin
               if (FrameGrabberRGBFormat = fgf_RGB8) then begin
                  Result := ReturnPreferredSubtype (SubtypeRGB8, SubtypeRGB24, SubtypeRGB32, SubtypeRGB565, SubtypeRGB555);
               end;
            end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ReinitCurrentParams (FirstInitialization: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   MasterOk: Boolean;
begin
      Result := True;


      if FirstInitialization then begin
         FCurrent.AudioDevice := -1;
         FCurrent.VideoDevice := -1;
         Exit;
      end;

      ClearGraph (False);

      FCurrent.FrameCaptureWithoutOverlay := FFrameCaptureWithoutOverlay;
      FCurrent.FrameGrabber := FFrameGrabber;
      FCurrent.FrameGrabberRGBFormat:= FFrameGrabberRGBFormat;
      FCurrent.CompressionMode := FCompressionMode;
      FCurrent.CompressionType := FCompressionType;
      FCurrent.BurstCount := FBurstCount;
      FCurrent.BurstInterval := FBurstInterval;
      FCurrent.RecordingCanPause := FRecordingCanPause;
      FCurrent.RecordingInNativeFormat := FRecordingInNativeFormat;
      FCurrent.AudioDeviceRendering := FAudioDeviceRendering;
      FCurrent.PlayerAudioRendering := FPlayerAudioRendering;
      FCurrent.VideoSource := FVideoSource;
      FCurrent.SpeakerControl := FSpeakerControl;
      FCurrent.AudioRecording := FAudioRecording;
      FCurrent.VideoRenderer := FVideoRenderer;
      FCurrent.MotionDetectorEnabled := FMotionDetector.FEnabled;
      FCurrent.RecordingMethod := FRecordingMethod;
      FCurrent.NetworkStreaming := FNetworkStreaming;
      FCurrent.VideoSubtypeIndex := -1;
      FCurrent.HoldRecording := FHoldRecording;
      FCurrent.VideoRecording := True;
      FCurrent.PreallocCapFileEnabled := FPreallocCapFileEnabled;
      FCurrent.PreallocCapFileCopiedAfterRecording := FPreallocCapFileCopiedAfterRecording;
      FCurrent.FrameRate := FFrameRate;
      FCurrent.MultiplexedSlaveFrameRate := FMultiplexedSlaveFrameRate;
      FCurrent.RecordingOnMotion_MotionThreshold := FRecordingOnMotion_MotionThreshold;
      FCurrent.RecordingOnMotion_Enabled := FRecordingOnMotion_Enabled;
      FCurrent.RecordingOnMotion_NoMotionPauseDelayMs := FRecordingOnMotion_NoMotionPauseDelayMs;


      if FCurrent.RecordingOnMotion_Enabled then begin
         if FCurrent.RecordingMethod <> rm_AVI then begin
            LogB (True, LERROR, e_recording_on_motion_failed, 'recording on motion not compatible with ASF, change to RecordingMethod = rm_AVI');
            Result := False;
            Exit;
         end
         else begin
            FCurrent.RecordingCanPause := True;
            FCurrent.HoldRecording := False;
         end;
      end;

      EnableDisableVideoEffects;
      EnableDisableVideoTransform;

      if FGraphType = cs_Preview then begin
         if FCurrent.NetworkStreaming <> ns_Disabled then begin
            FCurrent.AudioRecording := FCurrent.AudioDeviceRendering;
         end;
      end;

      if FCurrent.FrameGrabber <> fg_Disabled then begin
         if FMultiplexedRole = mr_MultiplexedSlave then begin
            MasterOk := False;
            if assigned (FMultiplexedMaster.Vdgr) then begin
               if FMultiplexedMaster.Vdgr.FGraphType in [cs_Preview, cs_Recording] then begin
                  FCurrent.FrameGrabberRGBFormat := FMultiplexedMaster.Vdgr.FCurrent.FrameGrabberRGBFormat;
                  MasterOk := True;
               end;
            end;
            if LogB (not MasterOk, LERROR, e_must_restart_master, 'settings changed, the master component must be restarted') then begin
               Result := False;
            end;
         end else
         if FCurrent.MotionDetectorEnabled
         or FVideoEffects.Enabled
         or SlavesNeedMotionDetection
         or FTransformConfig.Enabled then begin
            FCurrent.VideoSubtypeIndex := SelectVideoSubtypeFromRGB24Or32 (FVideoSubtypes, FCurrent.FrameGrabberRGBFormat);
         end
         else if FCurrent.FrameGrabberRGBFormat <> fgf_Default then begin
            FCurrent.VideoSubtypeIndex := SelectVideoSubtypeFromRGB (FVideoSubtypes, FCurrent.FrameGrabberRGBFormat);
         end
         else begin
            FCurrent.VideoSubtypeIndex := FVideoRegSave[_VideoSubtype].i;
            if FVideoRegSave[_VideoSubtype].i < FVideoSubtypes.Count then begin
               SelectFrameGrabberFormatFromVideoSubtype (ReturnFourCC (FVideoSubtypes[FVideoRegSave[_VideoSubtype].i]), FCurrent.FrameGrabberRGBFormat);
            end;
         end;
      end;

      if FCurrent.VideoSubtypeIndex = -1 then begin // nothing found
         FCurrent.VideoSubtypeIndex := FVideoRegSave[_VideoSubtype].i;
      end;


      FFrameGrabberCurrentRGBFormat := FCurrent.FrameGrabberRGBFormat;

      FCurrentParamsInitialized:= True;

      ReinitFrameInfos;
      ReinitCurrentFrameData;
end;

(* DVENCODE
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AddDVMuxAndDVDevice (out MuxFilter: IBaseFilter): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   DVDevice: IBaseFilter;
   DVIn, MuxIn, MuxOut, DvEncOut: IPin;
   DVEnc: IBaseFilter;
begin
   Result := False;
   try
      if not CreateInstance (@CLSID_DVVideoEnc, IBaseFilter, DVEnc, 'DVEnc') then Exit;
      if not AddFilter (DVEnc, 'DEnc') then Exit;
      if Failed (F_CaptureGraphBuilder2.FindPin (DVEnc, PINDIR_OUTPUT, nil, nil, true, 0, DvEncOut)) then Exit;

      if not CreateInstance (@CLSID_DVMux, IBaseFilter, MuxFilter, 'DVMx') then Exit;
      if not AddFilter (MuxFilter, 'DVM') then Exit;
      if Failed (F_CaptureGraphBuilder2.FindPin (MuxFilter, PINDIR_INPUT, nil, nil, true, 0, MuxIn)) then Exit;

      if Failed (DVEncOut.Connect (MuxIn, nil)) then Exit;

      if not BindAndAddDevice (F_FilterGraph2, _VideoDevices, FUploadToDV_Device, '', DVDevice, True, FpVideoDeviceInUse, not FDiscovering, '') then Exit;
      if Failed (F_CaptureGraphBuilder2.FindPin (DVDevice, PINDIR_INPUT, nil, nil, true, 0, DVIn)) then Exit;
      if Failed (F_CaptureGraphBuilder2.FindPin (MuxFilter, PINDIR_OUTPUT, nil, nil, true, 0, MuxOut)) then Exit;
//      if not Connect (MuxOut, DVIn) then Exit;
      Result := True;
   finally
      if not Result then begin
         if assigned (MuxFilter) then MuxFilter := nil;
      end;
      if assigned (DVIn) then DVIn := nil;
      if assigned (MuxOut) then MuxOut := nil;
      if assigned (DvEncOut) then DvEncOut := nil;
      if assigned (DVDevice) then DVDevice := nil;
      if assigned (MuxIn) then MuxIn := nil;
   end;
end;
*)

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AddFileWriterFilter: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   StandardRecording: Boolean;
   CustomRecording: Boolean;
   OleStr: pOleStr;
   hr: HResult;
begin
   try
      Result := False;

      StandardRecording := ((FGraphType = cs_Recording) and (not NativeRawCapture)) or (FGraphType = cs_Reencoding) or ((FGraphType = cs_Preview) and (FCurrent.NetworkStreaming <> ns_Disabled));
      CustomRecording := StandardRecording and (FMPEGWriterFilter <> '');
      if StandardRecording and not CustomRecording then begin
         hr := E_FAIL;
         if (FGraphType in [cs_Recording, cs_Reencoding]) and (FCurrent.RecordingMethod = rm_ASF) then begin
            hr:= F_CaptureGraphBuilder2.SetOutputFileName(@MEDIASubtype_ASF, OleS(FOutputFileName, OleStr), F_ASFFileMux, F_ASFFileSink);
            SysFreeString (OleStr);
            if not InsertASFFilter then Exit;
         end
         else if IsASFRecordingOrStreaming then begin { stream only }
            hr:= F_CaptureGraphBuilder2.SetOutputFileName(@MEDIASubtype_ASF, OleS(_SyncManager.CreateTempFile ('v~a'), OleStr), F_ASFFileMux, F_ASFFileSink);
            SysFreeString (OleStr);
            if not InsertASFFilter then Exit;
         end;
         if (FGraphType in [cs_Recording, cs_Reencoding]) and (FCurrent.RecordingMethod = rm_AVI) then begin
            hr:= F_CaptureGraphBuilder2.SetOutputFileName(@MEDIASubtype_avi, OleS(FOutputFileName, OleStr), F_AVIFileMux, F_AVIFileSink);
            SysFreeString (OleStr);
         end;
         if not LogH (Hr, LERROR, e_set_output_file_name, 'set outputfilename (mux/sink') then Exit;

         hr:= F_CaptureGraphBuilder2.GetFiltergraph(F_GraphBuilder);
         if not LogH (Hr, LERROR, e_set_filter_graph, 'filter graph 1') then Exit;
      end;
      if CustomRecording then begin
         if not ConnectMPEGWriter then Exit;
      end;
      Result := True;
   finally
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CreateFilterGraph: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ creates the graph builder and the capture builder
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
begin
      Result := false;

      FGraphState := gs_Building;

      WriteLog ('c', sBlue, 'creating filter graph');

      if LogB (not FCurrentParamsInitialized, LERROR, e_set_filter_graph, 'current params not set') then Exit;

      CheckDualDisplay;

      if not CreateInstance (@CLSID_CaptureGraphBuilder2, ICaptureGraphBuilder2, F_CaptureGraphBuilder2, 'Graph Builder') then begin
         DirectX8OrHigher := dx_7orLess;
         LogB (True, LERROR, e_set_filter_graph, 'DirectX 8 or higher required!');
         Exit;
      end;
      DirectX8OrHigher := dx_8OrHigher;

      if not CreateInstance (@CLSID_FilterGraph, IGraphBuilder, F_GraphBuilder, 'Filter Graph') then Exit;

      hr:= F_CaptureGraphBuilder2.SetFiltergraph(F_GraphBuilder);
      if not LogH (Hr, LERROR, e_set_filter_graph, 'set filter graph') then Exit;

      hr := F_GraphBuilder.QueryInterface (IFilterGraph2, F_FilterGraph2);
      if not LogH (Hr, LERROR, e_get_interface, 'filter graph 2') then Exit;


      WriteLog ('c', sBlue, 'filter graph created');

      Result := true;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ReadRegistryData (Regkey: TRegistry2; RegistryData: pRegistryData): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   iRead: LongInt;
   bRead: Boolean;
   sRead: string;
   dRead: Double;
begin
   with RegistryData^ do begin
      Result := True;
      case t of
         tvLongInt: if RegKey.ReadInteger (RegId, iRead) then i := iRead else Result := False;
         tvstring:  if RegKey.Readstring (RegId, sRead) then s := sRead else Result := False;
         tvBoolean: if RegKey.ReadBool (RegId, bRead) then b := bRead else Result := False;
         tvFloat:   if RegKey.ReadDouble (RegId, dRead) then d := dRead else Result := False;
         tvBuffer:  begin
            if RegKey.ReadBinaryDataFixedSize (RegId, Data^, DataSize) then begin
               if not RegKey.ReadInteger (RegId + 'Size', DataSize) then begin
                  Result := False;
               end;
            end
            else begin
              Result := False;
            end;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure WriteRegistryData (Regkey: TRegistry2; RegistryData: pRegistryData);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with RegistryData^ do begin
      case t of
         tvLongInt: RegKey.WriteInteger (RegId, i);
         tvstring:  RegKey.WriteString (RegId, s);
         tvBoolean: RegKey.WriteBool (RegId, b);
         tvFloat:   RegKey.WriteDouble (RegId, d);
         tvBuffer: begin
            RegKey.WriteBinaryData (RegId, Data^, DataSize);
            RegKey.WriteInteger (RegId + 'Size', DataSize);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.LoadCurrentVideoDeviceSettingsFromRegistry: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey: TRegistry2;
   j: TVideoId;
begin
   Result := False;
   if not IsLiveVideoSource then Exit;
   if FCurrent.VideoDevice = -1 then Exit;
   RegKey := TRegistry2.Create (False);
   if RegKey.OpenKey (DeviceRegKeyId (_VideoDevices, FCurrent.VideoDevice), false) then begin
      Result := True;
      for j := low (TVideoId) to high (TVideoId) do begin
         if FStoreDeviceSettingsInRegistry or ((not FStoreDeviceSettingsInRegistry) and (j < _VIDEO_MAYNOTBESAVED)) then begin
            if not ReadRegistryData (RegKey, @FVideoRegSave[j]) then begin
               Result := False;
            end;
         end;
      end;
   end;
   RegKey.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.LoadCurrentAudioDeviceSettingsFromRegistry: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey: TRegistry2;
   j: TAudioId;
begin
   Result := False;
   RegKey := TRegistry2.Create (False);
   if RegKey.OpenKey (DeviceRegKeyId (_AudioDevices, FCurrent.AudioDevice), false) then begin
      Result := True;
      for j := low (TAudioId) to high (TAudioId) do begin
         if FStoreDeviceSettingsInRegistry or ((not FStoreDeviceSettingsInRegistry) and (j < _Audio_MAYNOTBESAVED)) then begin
            if not ReadRegistryData (RegKey, @FAudioRegSave[j]) then begin
               Result := False;
            end;
         end;
      end;
   end;
   RegKey.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.LoadGlobalSettingsFromRegistry: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey: TRegistry2;
   j: TGlobalId;
begin
   Result := False;
   RegKey := TRegistry2.Create (False);
   if RegKey.OpenKey (GlobalRegKeyId, false) then begin
      Result := True;
      for j := low (TGlobalId) to high (TGlobalId) do begin
         if not ReadRegistryData (RegKey, @FGlobalRegSave[j]) then begin
            Result := False;
         end;
      end;
   end;
   RegKey.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.SaveGlobalSettingsToRegistry;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey: TRegistry2;
   i: TGlobalId;
begin
   RegKey := TRegistry2.Create (False);
   if RegKey.OpenKey (GlobalRegKeyId, true) then begin
      for i := low (TGlobalId) to high (TGlobalId) do begin
         WriteRegistryData (RegKey, @FGlobalRegSave[i]);
      end;
   end;
   RegKey.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.SaveCurrentVideoDeviceSettingsToRegistry;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey: TRegistry2;
   i: TVideoId;
begin
   if not IsLiveVideoSource then Exit;
   if FCurrent.VideoDevice = -1 then Exit;
   if not FVideoRegSave[_DeviceDiscovered].b then Exit;
   RegKey := TRegistry2.Create (False);
   if RegKey.OpenKey (DeviceRegKeyId (_VideoDevices, FCurrent.VideoDevice), true) then begin
      for i := low (TVideoId) to high (TVideoId) do begin
         WriteRegistryData (RegKey, @FVideoRegSave[i]);
      end;
   end;
   RegKey.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.SaveCurrentAudioDeviceSettingsToRegistry;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey: TRegistry2;
   i: TAudioId;
begin
   if not IsLiveVideoSource then Exit;
   if FCurrent.AudioDevice = -1 then Exit;
   if not FAudioRegSave[_A_DeviceDiscovered].b then Exit;
   RegKey := TRegistry2.Create (False);
   if RegKey.OpenKey (DeviceRegKeyId (_AudioDevices, FCurrent.AudioDevice), true) then begin
      for i := low (TAudioId) to high (TAudioId) do begin
         WriteRegistryData (RegKey, @FAudioRegSave[i]);
      end;
   end;
   RegKey.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.EnableDisableVideoEffects;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FVideoEffects.Enabled := (FVideoEffects.Brightness <> 0)
                         or (FVideoEffects.Contrast <> 0)
                         or (FVideoEffects.Saturation <> 0)
                         or (FVideoEffects.Hue <> 0)
                         or (FVideoEffects.GrayScale)
                         or (FVideoEffects.InvertColors);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.EnableDisableVideoTransform;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FTransformConfig.Enabled := (FTransformConfig.VideoRotation_90_or_270)
                            or (FTransformConfig.VideoHalfDeinterlacing);
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function IsEqualObject(pFirst: IUnknown; pSecond: IUnknown): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pUnknown1, pUnknown2: IUnknown;
begin
   Result := false;
    if pFirst = pSecond then begin
       Result := true;
    end
    else begin
       if assigned (pFirst) and assigned (pSecond) then begin
          if pFirst.QueryInterface(IUnknown, pUnknown1) = S_OK then begin
             if pSecond.QueryInterface(IUnknown, pUnknown2) = S_OK then begin
                if pUnknown1 = pUnknown2 then begin
                   Result := true;
                end;
                pUnknown2 := nil;
             end;
             pUnknown1 := nil;
          end;
       end;
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function IsSubtypeAvailable (Pin: IPin; MajorType, Subtype: pGUID): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Done: Boolean;
   pmt: PAM_MEDIA_TYPE;
   EnumMediaTypes: IEnumMediaTypes;
begin
   Result := False;
   Done := False;
   try
      if not assigned (Pin) then Exit;
      if Pin.EnumMediaTypes (EnumMediaTypes) = S_OK then begin
         if assigned (EnumMediaTypes) then begin
            ENumMediaTypes.Reset;
            while (EnumMediaTypes.Next (1, pmt, nil) = S_OK) and (not Done) do begin
               if _IsEqualGUID (@pmt.MajorType, MajorType) then begin
                  if _IsEqualGUID (@pmt.Subtype, Subtype) then begin
                     Result := True;
                     Done := True;
                  end;
               end;
               DeleteMediaType (pmt);
            end;
            EnumMediaTypes := nil;
         end;
      end;
   finally
      Pin := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.SearchAudioOutOnVideoFilter (CurrentFilter: IBaseFilter; var AudioOut: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Pins: IEnumPins;
   hr: HRESULT;
   cFetched: ULONG;
   Direction: TPin_Direction;
   Done: Boolean;
   FilterPin: IPin;
   ConnectedTo: IPin;
   pmt: PAM_MEDIA_TYPE;
   PinInfo: TPin_Info;
   EnumMediaTypes: IEnumMediaTypes;
begin
   Result := false;
   if not assigned (CurrentFilter) then Exit;
   if assigned (AudioOut) then Exit;

   try
      Pins:= nil;
      Hr := CurrentFilter.EnumPins(Pins);
      if Hr <> S_OK then Exit;
      if Pins = nil then Exit;

      Pins.Reset;
      Done := false;
      while not Done do begin
         if Pins.Next(1, FilterPin, @cFetched) = S_OK then begin
            if assigned (FilterPin) then begin
               FilterPin.QueryDirection (Direction);
               if Direction = PinDir_Output then begin
                  FilterPin.QueryPinInfo (PinInfo);
                  PinInfo.pFilter := nil;
                  if FilterPin.ConnectedTo (ConnectedTo) <> S_OK then begin
                     if FilterPin.EnumMediaTypes (EnumMediaTypes) = S_OK then begin
                        if assigned (EnumMediaTypes) then begin
                           ENumMediaTypes.Reset;
                           while (EnumMediaTypes.Next (1, pmt, nil) = S_OK) and (not Done) do begin
                              if _IsEqualGUID (@pmt.MajorType, @MEDIATYPE_AnalogAudio) then begin
                                 AudioOut := FilterPin;
                                 Result := true;
                              end;
                              DeleteMediaType (pmt);
                           end;
                           EnumMediaTYpes := nil;
                        end;
                     end;
                  end;
                  ConnectedTo := nil;
               end;
               FilterPin := nil;
            end;
         end
         else begin
            Done := true;
         end;
      end;

      Pins.Reset;
      Done := Result; { if found above, done = true }

      while not Done do begin
         if Pins.Next(1, FilterPin, @cFetched) = S_OK then begin
            if assigned (FilterPin) then begin
               FilterPin.QueryDirection (Direction);
               if Direction = PinDir_Input then begin
                  if FilterPin.ConnectedTo (ConnectedTo) = S_OK then begin
                     ConnectedTo.QueryPinInfo (PinInfo);
                     if assigned (PinInfo.pFilter) then begin
                        Done := SearchAudioOutOnVideoFilter (PinInfo.pFilter, AudioOut);
                        PinInfo.pFilter := nil;
                     end;
                  end;
                  ConnectedTo := nil;
               end;
               FilterPin := nil;
            end;
         end
         else begin
            Done := true;
         end;
      end;
      Pins:= nil;
   finally
      Pins:= nil;
      CurrentFilter := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.RetrieveDVSignalType (var AvgTimePerFrame: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Mode: LongInt;
begin
   Result := False;
   if not assigned (F_AMExtTransport) then Exit;

   if F_AMExtTransport.GetTransportBasicParameters(ED__TRANSBASIC_INPUT_SIGNAL, Mode, nil) = S_OK then begin
      Result := True;
      case Mode of
         ED__TRANSBASIC_SIGNAL_525_60_SD: begin { NTSC SD }
            AvgTimePerFrame := 333667;  { 33 msec (29.97 FPS) }
            FVideoRegSave[_IsDVPal].b := False;
         end;
         ED__TRANSBASIC_SIGNAL_525_60_SDL: begin { NTSC SDL }
            AvgTimePerFrame := 333667;
            FVideoRegSave[_IsDVPal].b := False;
         end;
         ED__TRANSBASIC_SIGNAL_625_50_SD: begin { PAL SD }
            AvgTimePerFrame := 400000;  { 40 msec (25 FPS) }
            FVideoRegSave[_IsDVPal].b := True;
         end;
         ED__TRANSBASIC_SIGNAL_625_50_SDL: begin { PAL SDL }
            AvgTimePerFrame := 400000;
            FVideoRegSave[_IsDVPal].b := True;
         end;
         else begin
            AvgTimePerFrame := 333667; { Default }
            Result := False;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.RecordingAndCompressingVideo: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := (FCurrent.CompressionMode = cm_CompressOnTheFly) and (FCurrent.CompressionType in [ct_Video, ct_AudioVideo]);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.NativeRecording: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := (
               FGraphType = cs_Recording
             )
             and
             (    (
                     FCurrent.RecordingInNativeFormat
                  )
                  or
                  (
                     (
                        FCurrent.FrameGrabber in [fg_Disabled, fg_PreviewStream]
                     )
                     and
                     (
                        not RecordingAndCompressingVideo
                     )
                     and
                     (
                        (
                           not FVideoRegSave[_IsDigitalVideoIn].b
                        )
                        or
                        (
                           (
                              FVideoRegSave[_IsDigitalVideoIn].b
                           )
                           and
                           (
                              FVideoRegSave[_VideoSubtype].i = 0
                           )
                        )
                     )
                  )
             );
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.NativeRawCapture: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := NativeRecording and isMPEGSource;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.NativeRecordingSplitterRequired: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := NativeRecording and ((FCurrent.FrameGrabber = fg_PreviewStream) or (FCurrent.VideoRenderer <> vr_None));
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.PreviewStreamRequired: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := NativeRecordingSplitterRequired or (FCurrent.VideoRenderer <> vr_None) or (FCurrent.FrameGrabber <> fg_Disabled);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.DetectCxHap: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   sVideoDeviceName: String;
   HapDecoder: IBaseFilter;
begin
   sVideoDeviceName := lowercase (Intf.GetVideoDeviceName);
   Result := (pos ('hauppauge', sVideoDeviceName) > 0) and (pos ('pvr', sVideoDeviceName) > 0);
   if Result then begin
      try
      exit;
         if Succeeded (FindPinByName (F_VideoDevice, PINDIR_OUTPUT, '656', false, true, F_VideoPreviewPin)) then begin
            if not AddFilterByName (@CLSID_WDMStreamEncoders, 'PVR PCI II Encoder', mk_SubString, HapDecoder) then Exit;
            if not InsertExistingFilter (HapDecoder, F_VideoPreviewPin) then Exit;
         end;
      finally
         if assigned (HapDecoder) then HapDecoder := nil;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ConfCxHap;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   dwValue: dword;
   Hr: HResult;
begin
   if FMpegStreamType = mpst_Default then Exit;

   Hr := F_VideoDevice.QueryInterface (IKsPropertySet, F_VideoDeviceKsPropertySet);
   if not LogH (Hr, LTRACE, e_trace_log, 'find propertyset') then F_VideoDeviceKsPropertySet := nil;

   if assigned (F_VideoDeviceKsPropertySet) then begin
      case FMpegStreamType of
         mpst_Program: dwValue := HCW_Sys_StreamType_Program;
         mpst_Program_DVD: dwValue := HCW_Sys_StreamType_Program_DVD;
         mpst_Program_DVD_MC: dwValue := HCW_Sys_StreamType_Program_DVD_MC;
         mpst_Program_SVCD: dwValue := HCW_Sys_StreamType_Program_SVCD;
         mpst_MPEG1: dwValue := HCW_Sys_StreamType_MPEG1;
         mpst_MPEG1_VCD: dwValue := HCW_Sys_StreamType_MPEG1_VCD;
      end;
      F_VideoDeviceKsPropertySet.Set_ (PROPSETID_Hap_ENCODE_CONFIG_PROPERTIES, HCW_ECP_SYSTEM_StreamType, @dwValue, sizeof(dwValue), @dwValue, sizeof(dwValue));
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.RetrieveVideoPins: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   UseDvPin: Boolean;

   TempPin: IPin;
   DvPin: IPin;
   InterleavedPin: IPin;
   DVSplitter: IBaseFilter;
   SPlitterTee: IbaseFilter;
   DummyPin: Ipin;
   IsHauppaugePVR: Boolean;
   HapDecoder: IBaseFilter;
begin
   WriteLog ('b', sGrey, 'retrieving source pins');
   try
      Result := False;
      FVideoPinCategoryUsed := @PIN_CATEGORY_CAPTURE;

      IsHauppaugePVR := DetectCxHap;
      WriteLogBool (IsHauppaugePVR, sGrey, 'is hauppauge pvr');

      if IsHauppaugePVR then begin
         if Succeeded (FindPinByName (F_VideoDevice, PINDIR_OUTPUT, '656', false, true, F_VideoCapturePin)) then begin // PVR 150
            if Succeeded (FindPinByName (F_VideoDevice, PINDIR_OUTPUT, 'Capturer', false, true, F_VideoPreviewPin)) then begin
               FVideoRegSave[_IsMpegStream].b := True;
               RetrieveCommonInterfaces (F_VideoPreviewPin);
               if NativeRecording then begin
                  if not AddFilterByName (@CLSID_WDMStreamEncoders, 'PVR PCI II Encoder', mk_SubString, HapDecoder) then Exit;
                  if not InsertExistingFilter (HapDecoder, F_VideoCapturePin) then Exit;
                  if Failed (F_CaptureGraphBuilder2.FindPin (HapDecoder, PINDIR_OUTPUT, nil, @MEDIATYPE_Stream, true, 0, F_VideoCapturePin)) then Exit;
               end
               else begin  // treat as RGB video device
                  F_VideoCapturePin := nil;
               end;
               F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, nil, @MEDIATYPE_Audio, true, 0, F_AudioRenderPin);
            end;
         end;
      end;

      if not assigned (F_VideoPreviewPin) then begin // otherwise set by DetectCxHap
         FVideoRegSave[_IsMpegStream].b := F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, nil, @MEDIATYPE_Stream, true, 0, F_VideoPreviewPin) = S_OK;
         WriteLogBool (FVideoRegSave[_IsMpegStream].b, sBlue, 'is mpeg stream');
      end;

      if isMPEGSource then begin
         WriteLog (nil, sBlue, 'is mpeg source');
         RetrieveCommonInterfaces (F_VideoPreviewPin);

         if IsHauppaugePVR then begin
            WriteLog (nil, sGrey, 'conf cx hap');
            ConfCxHap;
         end;

         if NativeRecordingSplitterRequired then begin
            WriteLog (nil, sGrey, 'native capture splitter req');
            if FSampleCapture_Video = sc_Unsplitted then begin
               if not InsertGrabberFilter (F_VideoPreviewPin, gf_Sample, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleVideo], nil) then Exit;
            end;
            if not AddFilterGetInput (@CLSID_InfTee, SingleText('Capture Inf Tee'), SPlitterTee, TempPin) then Exit;
            if F_VideoPreviewPin.Connect (TempPin, nil) <> S_OK then Exit;
            if F_CaptureGraphBuilder2.FindPin (SPlitterTee, PINDIR_OUTPUT, nil, nil, true, 0, F_VideoPreviewPin) <> S_OK then Exit;
         end;

         if PreviewStreamRequired then begin
            WriteLog (nil, sGrey, 'preview stream req');
            if SearchMediaType (F_VideoPreviewPin, @MEDIATYPE_Stream, [@MEDIASUBTYPE_MPEG2_TRANSPORT]) then begin
               if InsertFilterInline (@CLSID_SnTS, SingleText('SnTS'), @MEDIATYPE_Video, F_VideoPreviewPin) then begin
                  if not InsertFilterInline (@CLSID_SnVDTN, SingleText('SnVDTN'), @MEDIATYPE_Video, F_VideoPreviewPin) then begin
                     InsertFilterInline (@CLSID_SnVD, SingleText('SnVD'), @MEDIATYPE_Video, F_VideoPreviewPin);
                  end;
               end;
            end;
            if SearchMediaType (F_VideoPreviewPin, @MEDIATYPE_Stream, [@MEDIASUBTYPE_MPEG2_PROGRAM]) then begin
               F_VideoPreviewPin.QueryInterface (IPin, TempPin);
               F_VideoPreviewPin := nil;
               if not ConfDm (F_GraphBuilder, TempPin, F_VideoPreviewPin, F_AudioRenderPin) then Exit;
               if (not FCurrent.AudioRecording) and (not FCurrent.AudioDeviceRendering) then begin
                  F_AudioRenderPin := nil;
               end;
            end;
         end;

         if NativeRecordingSplitterRequired then begin
            if not assigned (F_VideoCapturePin) then begin
               if assigned (SPlitterTee) then begin
                  WriteLog (nil, sGrey, 'inserting splitter tee');
                  if F_CaptureGraphBuilder2.FindPin (SPlitterTee, PINDIR_OUTPUT, nil, nil, true, 0, F_VideoCapturePin) <> S_OK then Exit;
                  F_ScCapturePinVideo := F_VideoCapturePin;
               end;
            end
            else begin
               if not InsertSmartTee (@CLSID_SmartTee, SingleText('CtrlTee'), F_VideoCapturePin, F_VideoCapturePin, DummyPin) then Exit;
               F_ScCapturePinVideo := F_VideoCapturePin;
            end;
         end
         else if NativeRecording then begin
            F_VideoCapturePin := F_VideoPreviewPin;
            F_VideoPreviewPin := nil;
            WriteLog (nil, sGrey, 'inserting sample notify');
            InsertGrabberFilter (F_VideoCapturePin, gf_Notify, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleNotify], nil); { will be inserted before the decoder, no topdown problem }
            F_ScCapturePinVideo := F_VideoCapturePin;
         end;
      end
      else begin { dv or normal (not mpeg) }
         if (not FCurrent.AudioRecording) and (not FCurrent.AudioDeviceRendering) then begin
            if F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, @PIN_CATEGORY_CAPTURE, @MEDIATYPE_Video, true, 0, DvPin) = S_OK then begin
               if SearchMediaType (DvPin, @MEDIATYPE_Video, [@MEDIASUBTYPE_dvsc, @MEDIASUBTYPE_dvsd, @MEDIASUBTYPE_dvsd2, @MEDIASUBTYPE_dvhd, @MEDIASUBTYPE_dvsl, @MEDIASUBTYPE_dv25, @MEDIASUBTYPE_dv50, @MEDIASUBTYPE_dvh1]) then begin
                  FVideoRegSave[_IsDigitalVideoIn].b := True;
                  WriteLogBool (FVideoRegSave[_IsDigitalVideoIn].b, sBlue, 'is DV 1');
                  RetrieveCommonInterfaces (DvPin);
               end
               else begin
                  DVPin := nil;
               end;
            end;
         end;

         if not assigned (DVPin) then begin
            if F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, nil, @MEDIATYPE_Interleaved, true, 0, InterleavedPin) = S_OK then begin
               FVideoRegSave[_IsDigitalVideoIn].b := True;
               WriteLogBool (FVideoRegSave[_IsDigitalVideoIn].b, sBlue, 'is DV 2');
               RetrieveCommonInterfaces (InterleavedPin);
            end;
         end;

         if not IsDVSource then begin
            WriteLog (nil, sBlue, 'normal video');
            if F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, @PIN_CATEGORY_CAPTURE, @MEDIATYPE_Video, true, 0, F_VideoPreviewPin) = S_OK then begin
               WriteLog (nil, sGrey, 'normal video cat capture');
               RetrieveCommonInterfaces (F_VideoPreviewPin);
            end
            else if F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, @PIN_CATEGORY_PREVIEW, @MEDIATYPE_Video, true, 0, F_VideoPreviewPin) = S_OK then begin
               WriteLog (nil, sGrey, 'normal video cat preview');
               RetrieveCommonInterfaces (F_VideoPreviewPin);
            end
            else if F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, nil, @MEDIATYPE_Video, true, 0, F_VideoPreviewPin) = S_OK then begin
               WriteLog (nil, sGrey, 'normal video cat not specified');
               RetrieveCommonInterfaces (F_VideoPreviewPin);
            end;
         end;

         if IsDVSource then begin
            WriteLog (nil, sBlue, 'DV settings');
            InsertGrabberFilter (DVPin, gf_DVData, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_NotifyDVData], nil);
            FCurrentFrameData.DVDataAvailable := True;
            if (not assigned (DvPin)) and (not assigned (InterleavedPin)) then Exit;
            UseDvPin := True;
            if assigned (DvPin) and assigned (InterleavedPin) then begin
               if FCurrent.AudioRecording or FCurrent.AudioDeviceRendering or (Intf.Visible and FDVReduceFrameRate) then begin
                  UseDvPin := False;
               end;
            end
            else if not assigned (DvPin) then begin
               UseDvPin := False;
            end;
            if useDvPin then begin
               DvPin.QueryInterface (IPin, F_VideoPreviewPin);
            end
            else begin
               InterleavedPin.QueryInterface (IPin, F_VideoPreviewPin);
            end;
            if FSampleCapture_Video = sc_Unsplitted then begin
               if not InsertGrabberFilter (F_VideoPreviewPin, gf_Sample, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleVideo], nil) then Exit;
            end;
            if NativeRecording then begin
               if not InsertSmartTee (@CLSID_SmartTee, SingleText('Capture Smart Tee'), F_VideoPreviewPin, F_VideoCapturePin, F_VideoPreviewPin) then Exit;
               if FRecordingMethod = rm_AVI then begin
                  InsertGrabberFilter (F_VideoCapturePin, gf_Dummy, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleDummy], nil);
               end;
            end;
            if (not NativeRecordingSplitterRequired) or PreviewStreamRequired then begin
               if not UseDvPin then begin
                  if not InsertFilter (@CLSID_DVSplitter, F_VideoPreviewPin, 'DV Splitter', DVSplitter) then Exit;
                  ReduceDVFrameRate (DVSplitter);
                  F_VideoPreviewPin := nil;
                  if F_CaptureGraphBuilder2.FindPin (DVSplitter, PINDIR_OUTPUT, nil, @MEDIATYPE_Video, true, 0, F_VideoPreviewPin) <> S_OK then Exit;
               end;
               if FCurrent.AudioRecording or FCurrent.AudioDeviceRendering then begin
                  if F_CaptureGraphBuilder2.FindPin (DVSplitter, PINDIR_OUTPUT, nil, @MEDIATYPE_Audio, true, 0, F_AudioRenderPin) <> S_OK then Exit;
               end;
            end
            else begin { only capture }
               F_VideoPreviewPin.QueryInterface (IPin, F_VideoCapturePin);
               F_VideoPreviewPin := nil;
            end;
         end;
      end;

      if assigned (F_VideoCapturePin) then begin
         if FSampleCapture_Video = sc_Native then begin
            if not InsertGrabberFilter (F_VideoCapturePin, gf_Sample, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleVideo], nil) then Exit;
         end;
      end
      else if assigned (F_VideoPreviewPin) then begin
         if FSampleCapture_Video = sc_Native then begin
            if not InsertGrabberFilter (F_VideoPreviewPin, gf_Sample, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleVideo], nil) then Exit;
         end;
      end;

      WriteLog ('b', sPurple, 'source pins retrieved');
      Result := True;
   finally
      if assigned (TempPin) then TempPin := nil;
      if assigned (DvPin) then DvPin := nil;
      if assigned (InterleavedPin) then InterleavedPin := nil;
      if assigned (DVSplitter) then DVSplitter := nil;
      if assigned (SPlitterTee) then SPlitterTee := nil;
      if assigned (DummyPin) then DummyPin := nil;
      if assigned (HapDecoder) then HapDecoder := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.BindAudioSection;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   BDummy: pBoolean;
begin
      if not assigned (F_AudioRenderPin) then begin
         if (not isMPEGSource) and (not IsDVSource) then begin
            if ((FGraphType = cs_Preview) and FCurrent.AudioDeviceRendering) or ((FGraphType = cs_Recording) and FCurrent.AudioRecording) then begin
               if (_AudioDevices.FDevices.Count = 0) and (FCurrent.AudioRecording or FCurrent.AudioDeviceRendering) then begin
                  LogB (true, LWARNING, w_find_audio_device, 'no audio device found');
               end
               else begin
                  if Succeeded (F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, nil, @MEDIATYPE_Audio, true, 0, F_AudioRenderPin)) then begin
                        F_VideoDevice.QueryInterface (IAMAudioInputMixer, F_AMAudioInputMixerGeneral);
                        F_VideoDevice.QueryInterface (IAMCrossbar, F_AMAudioDevCrossbar);
                  end
                  else begin
                     if BindAndAddDevice (F_FilterGraph2, _AudioDevices, FCurrent.AudioDevice, '', F_AudioDevice, False, BDummy, not FDiscovering, GetAudioInputName) then begin
                        F_AudioDevice.QueryInterface (IAMAudioInputMixer, F_AMAudioInputMixerGeneral);
                        F_AudioDevice.QueryInterface (IAMCrossbar, F_AMAudioDevCrossbar);
                        F_CaptureGraphBuilder2.FindPin (F_AudioDevice, PINDIR_OUTPUT, nil, @MEDIATYPE_Audio, true, 0, F_AudioRenderPin);
                     end;
                  end;
                  if not FDiscovering then begin
                     if assigned (F_AudioRenderPin) then begin
                        AudioStreamConfigSetFormat (F_AudioRenderPin);
                     end;
                  end;
               end;
            end;
         end;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.TVRetrieveState;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Dummy1, Dummy2: LongInt;
begin
   if not Assigned (F_AMTVTuner) then Exit;
   F_AMTVTuner.Get_Channel (FVideoRegSave[_TVChannel].i, Dummy1, Dummy2);
   F_AMTVTuner.Get_ConnectInput (FVideoRegSave[_TVConnectInput].i);
   F_AMTVTuner.Get_InputType (FVideoRegSave[_TVConnectInput].i, FVideoRegSave[_TVInputType].i);
   F_AMTVTuner.get_TuningSpace (FVideoRegSave[_TVTuningSpace].i);
   F_AMTVTuner.get_CountryCode (FVideoRegSave[_TVCountryCode].i);
   F_AMTVTuner.get_Mode (dword(FVideoRegSave[_TVMode].i));
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.TVInitState;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
   AMTUNER_MODE_TV = 1;
var
   Dummy1: dword;
   Dummy2: LongInt;
begin
   if not Assigned (F_AMTVTuner) then Exit;

      if assigned (F_AMAnalogVideoDecoder) then begin
         if F_AMAnalogVideoDecoder.Get_TVFormat (Dummy2) = S_OK then begin
            F_AMAnalogVideoDecoder.Put_TVFormat (FVideoRegSave[_ANVTVFormat].i);
         end;
      end;

      if F_AMTVTuner.Get_Mode (Dummy1) = S_OK then begin
         F_AMTVTuner.put_Mode(AMTUNER_MODE_TV); { no log, usually fails }
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CanPerformSetVideoFormatOnThisDevice: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   lDeviceName : String;
begin
   lDeviceName := lowercase (Intf.VideoDeviceName);
   Result := not (
      (pos ('pinnacle', lDeviceName) > 0) and (pos ('moviebox', lDeviceName) > 0)); // Pinnacle MovieBox
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.RetrieveCommonInterfaces (var Pin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
   DummyInt: LongInt;

   AnalogVideoPin: IPin;
   VideoCrossbarBaseFilter: IBaseFilter;
begin
   Result := False;
   if not IsLiveVideoSource then Exit;
   if FCurrent.VideoSource <> vs_VideoCaptureDevice then Exit;
   try
      if not FVideoRegSave[_IsMpegStream].b then begin
         if F_CaptureGraphBuilder2.RenderStream (nil, nil, Pin, nil, nil) = S_OK then begin { otherwise LiveView FlyTV fails in RGB24 or fgrabber disabled }
            DeleteDownStream (F_GraphBuilder, Pin, True);
         end;
      end;

      FVideoRegSave[_IsTVTunerAvail].b := F_CaptureGraphBuilder2.FindInterface(@LOOK_UPSTREAM_ONLY, nil, F_VideoDevice, IAMTVTuner, F_AMTVTuner) = S_OK;
      WriteLogBool (FVideoRegSave[_IsTVTunerAvail].b, sBlue, 'tv tuner available');

      FVideoRegSave[_IsAnalogVideoDecoderAvail].b := F_CaptureGraphBuilder2.FindInterface (nil, nil, F_VideoDevice, IAMAnalogVideoDecoder, F_AMAnalogVideoDecoder) = S_OK;
      if not FVideoRegSave[_IsAnalogVideoDecoderAvail].b then begin
         FVideoRegSave[_IsAnalogVideoDecoderAvail].b := F_CaptureGraphBuilder2.FindInterface (@LOOK_UPSTREAM_ONLY, nil, F_VideoDevice, IAMAnalogVideoDecoder, F_AMAnalogVideoDecoder) = S_OK;
      end;
      WriteLogBool (FVideoRegSave[_IsAnalogVideoDecoderAvail].b, sBlue, 'AnalogVideoDecoderAvail available');
      if FVideoRegSave[_IsAnalogVideoDecoderAvail].b then begin
         FVideoRegSave[_IsVCRHorizontalLockingAvail].b := F_AMAnalogVideoDecoder.get_VCRHorizontalLocking (DummyInt) = S_OK;
         if not FDiscovering then begin
            F_AMAnalogVideoDecoder.Put_TVFormat (FVideoRegSave[_ANVTVFormat].i);
            F_AMAnalogVideoDecoder.put_VCRHorizontalLocking(FVideoRegSave[_ANVVCRHorzLocking].i);
            F_AMAnalogVideoDecoder.put_OutputEnable(FVideoRegSave[_ANVOutputEnable].i);
         end;
      end
      else begin
         FVideoRegSave[_IsVCRHorizontalLockingAvail].b := False;
      end;

      Hr := Pin.QueryInterface (IAMStreamConfig, F_AMVideoStreamConfig);
      if not LogH (Hr, LTRACE, e_trace_log, 'find stream config') then F_AMVideoStreamConfig := nil;

      if not FDiscovering then begin
         if CanPerformSetVideoFormatOnThisDevice then begin
            if not VideoStreamConfigSetFormat (Pin) then begin
               if not VideoStreamConfigSetFormat2 then begin
                  VideoStreamConfigSetFrameRate;
               end;
            end;
         end;
      end;

      FVideoRegSave[_IsVideoQualityAvail].b := F_CaptureGraphBuilder2.FindInterface (nil, nil, F_VideoDevice, IAMVideoProcAmp, F_AMVideoQuality) = S_OK;
      WriteLogBool (FVideoRegSave[_IsVideoQualityAvail].b, sGrey, 'find video quality');

      FVideoRegSave[_IsCameraControlAvail].b := F_CaptureGraphBuilder2.FindInterface (nil, nil, F_VideoDevice, IAMCameraControl, F_AMCameraControl) = S_OK;
      WriteLogBool (FVideoRegSave[_IsCameraControlAvail].b, sGrey, 'find camera control');

      FVideoRegSave[_IsVideoControlAvail].b := F_CaptureGraphBuilder2.FindInterface (nil, nil, F_VideoDevice, IAMVideoControl, F_AMVideoControl) = S_OK;
      WriteLogBool (FVideoRegSave[_IsVideoControlAvail].b, sGrey, 'find video control');

      FVideoRegSave[_ExtTransportAvail].b := F_CaptureGraphBuilder2.FindInterface (nil, nil, F_VideoDevice, IAMExtTransport, F_AMExtTransport) = S_OK;
      WriteLogBool (FVideoRegSave[_ExtTransportAvail].b, sGrey, 'find ext transport');

      FVideoRegSave[_TimeCodeReaderAvail].b := F_CaptureGraphBuilder2.FindInterface (nil, nil, F_VideoDevice, IAMTimeCodeReader, F_AMTimeCodeReader) = S_OK;
      WriteLogBool (FVideoRegSave[_TimeCodeReaderAvail].b, sGrey, 'time code available');

      FVideoRegSave[_IsTVAudioAvail].b := F_CaptureGraphBuilder2.FindInterface (nil, nil, F_VideoDevice, IAMTVAudio, F_AMTVAudio) = S_OK;
      WriteLogBool (FVideoRegSave[_IsTVAudioAvail].b, sGrey, 'tv audio available');

      FVideoRegSave[_IsVideoCrossbarAvail].b := F_CaptureGraphBuilder2.FindInterface(nil, nil, F_VideoDevice, IAMCrossbar, F_AMVideoCrossbar) = S_OK;
      if not FVideoRegSave[_IsVideoCrossbarAvail].b then begin
         FVideoRegSave[_IsVideoCrossbarAvail].b := F_CaptureGraphBuilder2.FindInterface(@LOOK_UPSTREAM_ONLY, nil, F_VideoDevice, IAMCrossbar, F_AMVideoCrossbar) = S_OK;
      end;
      WriteLogBool (FVideoRegSave[_IsVideoCrossbarAvail].b, sGrey, 'video crossbar available');

      if FVideoRegSave[_IsVideoCrossbarAvail].b then begin
         FVideoRegSave[_VideoInputs].s := ReturnCrossbarInputs;
         if FDiscovering then begin
            FVideoRegSave[_VideoInput].i := ReturnCrossbarInput;
         end;
         WriteLog ('video crossbar inputs', sGrey, FVideoRegSave[_VideoInputs].s);

         if F_AMVideoCrossbar.QueryInterface (IBaseFilter, VideoCrossbarBaseFilter) = S_OK then begin
            FVideoRegSave[_IsAudioCrossbarAvail].b := F_CaptureGraphBuilder2.FindInterface(@LOOK_UPSTREAM_ONLY, nil, VideoCrossbarBaseFilter, IAMCrossbar, F_AMAudioCrossbar) = S_OK;
            WriteLogBool (FVideoRegSave[_IsAudioCrossbarAvail].b, sGrey, 'audio crossbar on video available');

            if FVideoRegSave[_IsAudioCrossbarAvail].b then begin
               if FAutoConnectRelatedPins then begin { here otherwise disturbs devices without related pins }
                  WriteLog (nil, sGrey, 'routing crossbar');
                  if F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_INPUT, nil, @MEDIATYPE_AnalogVideo, false, 0, AnalogVideoPin) = S_OK then begin
                     WriteLog (nil, sGrey, 'auto routing audio crossbar');
                     FCrossbarAutoRouter := TCrossbarTree.Create (AnalogVideoPin);
                     if assigned (AnalogVideoPin) then AnalogVideoPin := nil;
                  end;
              end;
            end;
         end;
      end;

      ProcessCrossbars;

      RetrieveVideoControlCaps (Pin);

      ApplyVideoControlMode;

      if not FDiscovering then begin
         PerformSetVideoInput (FVideoRegSave[_VideoInput].i);
      end;

      if assigned (F_AMTVTuner) then begin
         if FDiscovering then begin
            TVRetrieveState;
            F_AMTVTuner.get_TVFormat(FVideoRegSave[_ANVTVFormat].i);
         end
         else begin
            TVInitState;
         end;
      end;

      F_VideoDeviceSelectedPin := Pin;

      Result := True;
   finally
      if assigned (AnalogVideoPin) then AnalogVideoPin := nil;
      if assigned (VideoCrossbarBaseFilter) then VideoCrossbarBaseFilter := nil;
      LogB (not Result, LTRACE, e_trace_log, 'failed to retrieve common interfaces');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CreateDeviceGraph: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ creates the video device base part of the graph
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;

   WriteLog (nil, sBlue, 'creating device graph');

   if not CreateFilterGraph then Exit;

   if InitializationStatus <> ipInitialized then Exit;

   if not BindAndAddDevice (F_FilterGraph2, _VideoDevices, FCurrent.VideoDevice, '', F_VideoDevice, True, FpVideoDeviceInUse, not FDiscovering, FVideoRegSave[_VideoInputName].s) then Exit;

   //BindPpSaver (@FPpSaver_VideoDevice, F_VideoDevice);

   FVideoRegSave[_IsVfw].b := not TCapDeviceInfo(_VideoDevices.FDevices.Objects[FCurrent.VideoDevice]).WDM;

   FVideoRegSave[_IsVideoPortAvailable].b := ConnectVideoPort;
   WriteLogBool (FVideoRegSave[_IsVideoPortAvailable].b, sGrey, 'WDM video port');

   WriteLog (nil, sBlue, 'device graph created');
   Result := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetVideoFormatBmiInfoCB_FromExternalSource (VidGrab: Pointer; out pmt: PAM_MEDIA_TYPE; var CanDeleteMediaType: Boolean): HRESULT; stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(VidGrab) do begin
      if FDestroying then begin
      end
      else begin
      end;
   end;
   Result := E_FAIL;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetSampleDataCB_FromExternalSource (VidGrab: Pointer; Buffer: pByte; BufferSize: LongInt; out EndOfData: Boolean; var DataLength: LongInt): HRESULT; stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(VidGrab) do begin
      if FDestroying then begin
      end
      else if FExternalSourceFrameData.CanAccessFrame then begin
      end
      else begin
      end;
   end;
   Result := E_FAIL;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetVideoFormatBmiInfoCB_FromFileStream (VidGrab: Pointer; out cbBitmapInfo: dword; out pBmi: pBitmapInfo; out Buffer: pByte): HRESULT; stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   BitmapSize: LongInt;
   cbFileHeader: dword;
   pBm: pBitmapFileHeader;
begin
   with TVdgr(VidGrab) do begin
      with FVideoFromImages do begin
         if not assigned (BitmapsFileStream) then begin
            Result := E_FAIL;
         end
         else begin
            BitmapsFileStream.Seek (0, soFromBeginning);
            BitmapsFileStream.Read (BitmapsCount, sizeof (LongWord));

            BitmapsFileStream.Read (BitmapSize, sizeof (LongInt));
            Buffer := CoTaskMemAlloc (BitmapSize);
            BitmapsFileStream.Read (Buffer^, BitmapSize);
            cbFileHeader := sizeof (TBitmapFileHeader);
            pBm := pBitmapFileHeader (Buffer);

            cbBitmapInfo := pBm^.bfOffBits - cbFileHeader;
            pBmi := pBitmapInfo (dword (Buffer) + cbFileHeader);

            BitmapsFileStream.Seek (0, soFromBeginning);
            BitmapsFileStream.Read (BitmapsCount, sizeof (LongWord));

            Result := S_OK;
           end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetSampleDataCB_FromFileStream (VidGrab: Pointer; Buffer: pByte; BufferSize: LongInt; out EndOfData: Boolean; var DataLength: LongInt): HRESULT; stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   BitmapSize: LongInt;
   cbFileHeader: dword;
   pBm: pBitmapFileHeader;
   cbBitmapInfo: dword;
   pImage: pByte;
   TempBuffer: pByte;
begin
   with TVdgr(VidGrab) do begin
      with FVideoFromImages do begin
         if not assigned (BitmapsFileStream) then begin
            Result := E_FAIL;
         end
         else begin
            if BitmapsFileStream.Position >= BitmapsFileStream.Size then begin
               BitmapsFileStream.Seek (0, soFromBeginning);
               BitmapsFileStream.Read (BitmapsCount, sizeof (LongWord));
               if not FVideoFromImages_RepeatIndefinitely then begin
                  EndOfData := True;
               end
               else begin
                  FRaiseEndOfStream := True;
                  PostCommand (WMProcessNotifyEvent);
               end;
            end;

            BitmapsFileStream.Read (BitmapSize, sizeof (LongInt));
            TempBuffer := CoTaskMemAlloc (BitmapSize);
            BitmapsFileStream.Read (TempBuffer^, BitmapSize);
            cbFileHeader := sizeof (TBitmapFileHeader);
            pBm := pBitmapFileHeader (TempBuffer);
            cbBitmapInfo := pBm^.bfOffBits - cbFileHeader;
            pImage := pByte (dword (TempBuffer) + cbFileHeader + cbBitmapInfo);
            Windows.CopyMemory (Buffer, pImage, BufferSize);
            CoTaskMemFree (TempBuffer);
            Result := S_OK;
         end;
      end;
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetVideoFormatBmiInfoCB_FromMultiplexedMaster (VidGrab: Pointer; out pmt: PAM_MEDIA_TYPE; var CanDeleteMediaType: Boolean): HRESULT; stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(VidGrab) do begin
      if FDestroying then begin
         Result := E_FAIL;
      end
      else if not assigned (FSlaveMultiplexedData.pCxMediaType_OwnedByMaster) then begin
         Result := E_FAIL;
      end
      else begin
         pmt := FSlaveMultiplexedData.pCxMediaType_OwnedByMaster;
         CanDeleteMediaType := False;
         Result := S_OK;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetSampleDataCB_FromMultiplexedMaster (VidGrab: Pointer; Buffer: pByte; BufferSize: LongInt; out EndOfData: Boolean; var DataLength: LongInt): HRESULT; stdcall;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   NewFrameData: pByte;
begin
   with TVdgr(VidGrab) do begin
      if FDestroying then begin
         Result := E_FAIL;
      end
      else if FSlaveMultiplexedData.CanAccessLastFrame then begin
         FSlaveMultiplexedData.CanAccessLastFrame := False;
         NewFrameData := FSlaveMultiplexedData.LastFrameData;
         FSlaveMultiplexedData.LastFrameData := nil;
         FSlaveMultiplexedData.CanCreateLastFrame := True;
         Windows.CopyMemory (Buffer, NewFrameData, BufferSize);
         FreeMem (NewFrameData);
         Result := S_OK;
      end
      else begin
         Result := E_FAIL;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CheckCustomMPEGRecording (CheckAnyWay: Boolean) : String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   DoCheck: Boolean;
begin
   Result := '';
   DoCheck := CheckAnyWay;
   if not DoCheck then begin
      if (FGraphType = cs_Recording) then begin
         if FCurrent.CompressionMode = cm_CompressOnTheFly then begin
            DoCheck := True;
         end;
      end;
   end;
   if DoCheck then begin
      if (FVideoCompressor >= 0) and (FVideoCompressor <_VideoCompressors.FDevices.Count) then begin
         if TCapDeviceInfo (_VideoCompressors.FDevices.Objects[FVideoCompressor]).IsDummy then begin
            Result := GUIDToString (TCapDeviceInfo (_VideoCompressors.FDevices.Objects[FVideoCompressor]).DummyGUID);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CreateBaseGraph: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ creates the base part of the graph
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Continue: Boolean;
begin
      Result := false;
      WriteLog ('a', sBlue, 'creating base graph');

      try
         if InitializationStatus <> ipInitialized then Exit;
         FGraphState := gs_Building;

         if LogB (not FCurrentParamsInitialized, LERROR, e_set_filter_graph, 'current params not set') then Exit;

         FMPEGWriterFilter := CheckCustomMPEGRecording (False);

         Continue := True;
         if Continue then begin
            if FVideoSource = vs_VideoFileOrURL then begin
               Continue := False;
               if not CreateFilterGraph then Exit;
               if not Build_File_Rendering (FVideoSource_FileOrURL, False, F_VideoPreviewPin, F_AudioRenderPin) then Exit;
            end;
         end;
         if Continue then begin
            if FVideoSource = vs_VideoFromBitmaps then begin
               Continue := False;
               if not CreateFilterGraph then Exit;
               if not BindPushSource (F_VideoPreviewPin, nil, GetVideoFormatBmiInfoCB_FromBitmap, GetSampleDataCB_FromBitmap) then Exit;
            end;
         end;
         if Continue then begin
            if FVideoSource = vs_ExternalSource then begin
               Continue := False;
               if not CreateFilterGraph then Exit;
               if not BindPushSource (F_VideoPreviewPin, nil, GetVideoFormatBmiInfoCB_FromExternalSource, GetSampleDataCB_FromExternalSource) then Exit;
            end;
         end;
         if Continue then begin
            if FMultiplexedRole = mr_MultiplexedSlave then begin
               Continue := False;
               if not CreateFilterGraph then Exit;
               if not assigned (FSlaveMultiplexedData.pCxMediaType_OwnedByMaster) then Exit;
               if LogB (not assigned (FSlaveMultiplexedData.pCxMediaType_OwnedByMaster), LERROR, e_not_multiplexed_master, 'multiplexed master not running') then Exit;
               if not BindPushSource (F_VideoPreviewPin, nil, GetVideoFormatBmiInfoCB_FromMultiplexedMaster, GetSampleDataCB_FromMultiplexedMaster) then Exit;
               //BindAudioSection;
            end;
         end;
         if Continue then begin
           case FCurrent.VideoSource of

            vs_VideoFileOrURL: begin
               //if not CreateDeviceGraph then Exit;
               //if not BindNetworkStreamingUrl then Exit;
               BindAudioSection;
            end;

            vs_VideoCaptureDevice: begin
               if not CreateDeviceGraph then Exit;
               if not RetrieveVideoPins then Exit;
               BindAudioSection;
               if not FDiscovering then begin

                  if FStoreDeviceSettingsInRegistry then begin
                     RestoreVideoQualitySettingsFromRegistry;
                  end;

                  if FStoreDeviceSettingsInRegistry then begin
                     RestoreCameraControlSettingsFromRegistry;
                  end;
               end;
               LogB (false, LTRACE, e_trace_log, 't audio device');
               WriteLog (nil, sGrey, 'Subtypes:');
               WriteLog (nil, sGrey, FVideoSubtypes.Text);
               WriteLog (nil, sGrey, 'analog standards:');
               WriteLog (nil, sGrey, 'sizes');
               WriteLog (nil, sGrey, FVideoSizes.Text);

            end;

            vs_VideoFromImages: begin
               WriteLog (nil, sGrey, 'vs_VideoFromImages begin create graph');
               if FVideoFromImages.InUse then Exit;
               if not CreateFilterGraph then Exit;
               if not FileExists (FVideoFromImages_TemporaryFile) then Exit;
               FVideoFromImages.BitmapsFileStreamName := FVideoFromImages_TemporaryFile;
               FVideoFromImages.BitmapsFileStream := CreateOrOpenFileStream (FVideoFromImages.BitmapsFileStreamName, fmOpenRead);
               if not assigned (FVideoFromImages.BitmapsFileStream) then Exit;
               FVideoFromImages.BitmapsFileStream.Seek (0, soFromBeginning);
               FVideoFromImages.BitmapsFileStream.Read (FVideoFromImages.BitmapsCount, sizeof (LongWord));
               FVideoFromImages.InUse := True;
               if not BindPushSource (F_VideoPreviewPin, GetVideoFormatBmiInfoCB_FromFileStream, nil, GetSampleDataCB_FromFileStream) then Exit;
               BindAudioSection;
               WriteLog (nil, sGrey, 'vs_VideoFromImages end create graph');
            end;
           end
         end;

         WriteLog ('a', sBlue, 'base graph created');
         Result := true;
      finally
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AddFilter(pFilter: IBaseFilter; DeviceName: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ adds a filter to the graph, logs the result.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
   OleStr: pOleStr;
begin
   Result := False;
   Hr := E_FAIL;
   try
      if not assigned (F_GraphBuilder) then Exit;
      Hr := F_GraphBuilder.AddFilter (pFilter, OleS(DeviceName, OleStr));
      SysFreeString (OleStr);
   finally
      Result := LogH (Hr, LERROR, e_add_filter, 'rejected: ' + DeviceName);
   end;
end;

type
   pKSPROPERTY_TUNER_MODE_CAPS_S = ^KSPROPERTY_TUNER_MODE_CAPS_S;
   KSPROPERTY_TUNER_MODE_CAPS_S = record
      KSPROPERTY: LongInt;
      Mode: LongInt;
      StandardsSupported: LongInt;
      MinFrequency: LongInt;
      MaxFrequency: LongInt;
      TuningGranularity: LongInt;
      NumberOfInputs: LongInt;
      SettlingTime: LongInt;
      Strategy: LongInt;
   end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function RemoveAutoTuneChannel (Buffer: Pointer; NbChannels: Integer; TVChannel: Integer; var WriteBufferSize: Integer): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i, j: Integer;
   Done: Boolean;
   ChannelId: Integer;
   pBuffer, pBuffer2: pInteger;
begin
   pBuffer := Buffer;
   Result := False;
   i := 0;
   Done := False;
   while not Done do begin
      if i >= NbChannels then begin
         Done := True;
      end
      else begin
         ChannelId := pBuffer^;
         inc (pBuffer);
         inc (pBuffer);
         if ChannelId = TVChannel then begin
            pBuffer2 := pBuffer;
            dec (pBuffer, 2);
            for j := i to NbChannels - 2 do begin
               pBuffer^ := pBuffer2^;
               inc (pBuffer);
               inc (pBuffer2);
               pBuffer^ := pBuffer2^;
               inc (pBuffer);
               inc (pBuffer2);
            end;
            dec (WriteBufferSize, 8);
            Done := True;
            Result := True;
         end
         else begin
            inc (i);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function FindAutoTunedChannelFrequency (Buffer: Pointer; NbChannels: Integer; TVChannel: Integer): Integer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: Integer;
   Done: Boolean;
   ChannelId: Integer;
   ChannelFreq: Integer;
   pBuffer: pInteger;
begin
   pBuffer := Buffer;
   Result := -1;
   i := 0;
   Done := False;
   while not Done do begin
      if i >= NbChannels then begin
         Done := True;
      end
      else begin
         ChannelId := pBuffer^;
         inc (pBuffer);
         ChannelFreq := pBuffer^;
         inc (pBuffer);
         if ChannelId = TVChannel then begin
            Result := ChannelFreq;
            Done := True;
         end
         else begin
            inc (i);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ReadAutoTunedChannelFrequency (RegKey: TRegistry2; ChannelNumber: Integer): Integer;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Info: TRegDataInfo;
   Buffer: pointer;
   NbChannels: Integer;
begin
   Result := -1;
   if not assigned (RegKey) then Exit;
   if RegKey.GetDataInfo(AUTOTUNE_REGKEY, Info) then begin
      GetMem (Buffer, Info.DataSize);
      if RegKey.ReadBinaryDataFixedSize (AUTOTUNE_REGKEY, Buffer^, Info.DataSize) then begin
         NbChannels := Round (Info.DataSize / sizeof (Integer) / 2);
         Result := FindAutoTunedChannelFrequency (Buffer, NbChannels, ChannelNumber);
      end;
      FreeMem (Buffer);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.TVDoSetChannel (lChannel, lVideoSubChannel, lAudioSubChannel: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
   AMTUNER_MODE_TV = 1;
var
   SignalStrength: LongInt;
   AudioFrequency, VideoFrequency: LongInt;
   DefaultFrequency: LongInt;
   OverriddenFrequency: LongInt;
   RegKeyTuning, RegKeyOverride: TRegistry2;
   lIndex: LongInt;
   Current: LongInt;
   UsedTuningSpace: Integer;
   TuningSpace, OverrideSpace: Integer;
   TVFormat: Integer;
begin
      Result := False;

      if not FIsTunerInputSelected then Exit;

      if ListItemName (FVideoRegSave[_VideoInputs].s, FVideoRegSave[_VideoInput].i) <> 'Tuner' then Exit;

      if not assigned (F_AMTVTuner) then Exit;

      if FDestroying then Exit;

      if not FIsTVAutoTuneRunning then ChangeBusyStateAndCursor (true);


         DefaultFrequency := -1;
         OverriddenFrequency := -1;

         if not FIsTVAutoTuneRunning then begin

            DefaultFrequency := -1;
            OverriddenFrequency := -1;

            TuningSpace := FVideoRegSave[_TVCountryCode].i;
            OverrideSpace := OverriddenTuningSpace (FVideoRegSave[_TVCountryCode].i);
            UsedTuningSpace := TuningSpace;

            if OpenAutoTuneRegKey (TuningSpace, FVideoRegSave[_TVInputType].i, RegKeyTuning) then begin
               DefaultFrequency := ReadAutoTunedChannelFrequency (RegKeyTuning, lChannel);
               RegKeyTuning.Free;
            end;

            if FTVUseFrequencyOverrides then begin
               if OpenAutoTuneRegKey (OverrideSpace, FVideoRegSave[_TVInputType].i, RegKeyOverride) then begin
                  if RegKeyOverride.ValueExists (IntToStr (lChannel)) then begin
                     RegKeyOverride.ReadInteger (IntToStr (lChannel), OverriddenFrequency);
                     UsedTuningSpace := OverrideSpace;
                  end;
               end;
               RegKeyOverride.Free;
            end;

            if F_AMTVTuner.Get_ConnectInput (lIndex) = S_OK then begin
               F_AMTVTuner.Put_InputType (lIndex, FVideoRegSave[_TVInputType].i);
            end;
            if OverriddenFrequency = -1 then begin
               F_AMTVTuner.Put_TuningSpace (FVideoRegSave[_TVCountryCode].i);
               F_AMTVTuner.Put_CountryCode (FVideoRegSave[_TVCountryCode].i);
            end
            else begin
               F_AMTVTuner.Put_CountryCode (FVideoRegSave[_TVCountryCode].i);
               F_AMTVTuner.Put_TuningSpace (UsedTuningSpace);
               F_AMTVTuner.Put_CountryCode (FVideoRegSave[_TVCountryCode].i);
            end;

            if assigned (F_AMAnalogVideoDecoder) then begin
               if F_AMTVTuner.get_TVFormat(TVFormat) = S_OK then begin
                  if F_AMAnalogVideoDecoder.Get_TVFormat (Current) = S_OK then begin
                     if Current <> TVFormat then begin
                        F_AMAnalogVideoDecoder.Put_TVFormat (TVFormat);
                     end;
                  end;
               end;
            end;
            FTVFrequencyOverrideInUse := OverriddenFrequency <> -1;
         end;

         Result := F_AMTVTuner.Put_Channel (lChannel, lVideoSubChannel, lVideoSubChannel) = S_OK;

         FTVChannelInfo.Locked := False;
         if assigned (F_AMAnalogVideoDecoder) then begin
            if F_AMAnalogVideoDecoder.get_HorizontalLocked(SignalStrength) = S_OK then begin
               FTVChannelInfo.Locked := SignalStrength = 1;
            end;
         end
         else begin
            if F_AMTVTuner.SignalPresent (SignalStrength) = S_OK then begin
               FTVChannelInfo.Locked := SignalStrength <> AMTUNER_NOSIGNAL;
            end;
         end;

         AudioFrequency := 0;
         VideoFrequency := 0;

         if F_AMTVTuner.Get_AudioFrequency (AudioFrequency) <> S_OK then begin
            AudioFrequency := 0;
         end;
         if F_AMTVTuner.Get_VideoFrequency (VideoFrequency) <> S_OK then begin
            VideoFrequency := 0;
         end;

         if OverriddenFrequency <> -1 then begin
            Result := True;
         end
         else begin
            if VideoFrequency <> 0 then begin
               if DefaultFrequency = -1 then begin
                  DefaultFrequency := VideoFrequency;
               end;
            end;
         end;
         FTVChannelInfo.Channel := lChannel;
         FTVChannelInfo.DefaultVideoFrequency := DefaultFrequency;
         FTVChannelInfo.OverriddenVideoFrequency := OverriddenFrequency;
         FTVChannelInfo.TunerVideoFrequency := VideoFrequency;
         FTVChannelInfo.TunerAudioFrequency := AudioFrequency;

         if not FIsTVAutoTuneRunning then ChangeBusyStateAndCursor (False);
         PostEvent (@Intf.FOnTVChannelSelected);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessTVStartAutoScan;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   lIndex: integer;
   TVFormat: Integer;
   Current: Integer;
begin
   FTVScanCurrentCountryCode := FVideoRegSave[_TVCountryCode].i;
   FTVScanCurrentTunerInputType := FVideoRegSave[_TVInputType].i;

   if FGraphAccessAllowed then begin
         if assigned (F_AMTVTuner) then begin
            if Succeeded (F_AMTVTuner.Get_ConnectInput (lIndex)) then begin
               if Succeeded (F_AMTVTuner.Put_InputType (lIndex, FTVScanCurrentTunerInputType)) then begin
                  if Succeeded (F_AMTVTuner.Put_TuningSpace (FTVScanCurrentCountryCode)) then begin
                     if Succeeded (F_AMTVTuner.Put_CountryCode (FTVScanCurrentCountryCode)) then begin

                        if assigned (F_AMAnalogVideoDecoder) then begin
                           if F_AMTVTuner.get_TVFormat(TVFormat) = S_OK then begin
                              if F_AMAnalogVideoDecoder.Get_TVFormat (Current) = S_OK then begin
                                 if Current <> TVFormat then begin
                                    F_AMAnalogVideoDecoder.Put_TVFormat (TVFormat);
                                 end;
                              end;
                           end;
                        end;

                        if Succeeded (F_AMTVTuner.ChannelMinMax (FTVScanCurrentChannel, FTVScanMaxChannel)) then begin
                           FIsTVAutoTuneRunning := True;
                           if not assigned (FAutoTuningStepThread) then begin
                              FAutoTuningStepThread := TAutoTuningStepThread.Create ('tuning', True, FNotificationPriority, FNotificationMethod, Intf, DEFAULTAUTOTUNINGSLEEPTIME);
                           end;
                           FAutoTuningStepThread.DoResume;
                           PostEvent (@Intf.FOnTVChannelScanStarted);
                        end;
                     end;
                  end;
               end;
            end;
         end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessTVScanning;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   ScanningCompleted: Boolean;
begin
   if (not FGraphAccessAllowed) or (not assigned (F_AMTVTuner)) then begin
      FTVScanStopRequest := False;
      FIsTVAutoTuneRunning := False;
      Exit;
   end;
   FTVProcessingTVAutoScan := True;
   ScanningCompleted := FTVScanStopRequest;

   if not ScanningCompleted then begin
         if (not FIsTVAutoTuneRunning) or (not FGraphAccessAllowed) then Exit;
         TVDoSetChannel (FTVScanCurrentChannel, AMTUNER_SUBCHAN_DEFAULT, AMTUNER_SUBCHAN_DEFAULT);
         if (not FIsTVAutoTuneRunning) or (not FGraphAccessAllowed) then Exit;
   end;

   inc (FTVScanCurrentChannel);
   if FTVScanCurrentChannel > FTVScanMaxChannel then begin
      ScanningCompleted := True;
   end;

   if ScanningCompleted then begin
      F_AMTVTuner.StoreAutoTune;
      if (not FIsTVAutoTuneRunning) or (not FGraphAccessAllowed) then Exit;
      FIsTVAutoTuneRunning := False;
      FTVScanStopRequest := False;
      if CanInvokeEvent (TPObj(Intf.FOnTVChannelScanCompleted)) then Intf.FOnTVChannelScanCompleted (Intf);
   end;
   FTVProcessingTVAutoScan := False;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.LogTrees;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Filters: TStringList;
   pEnumFilters: iEnumFilters;
   cFetched: ULONG;
   pFilter: IBaseFilter;
   hr: HResult;
   FilterInfo: TFilterInfo;
begin
    if not Log_DoLogToFile then Exit;
    if not assigned (F_GraphBuilder) then Exit;

    Filters := TStringList.Create;

    WriteLog ('=', sGrey, 'video tree');
    LogTree (F_VideoDevice, 0, Filters);
    WriteLog ('=', sGrey, 'video tree end');

    WriteLog ('=', sGrey, 'audio tree');
    LogTree (F_AudioDevice, 0, Filters);
    WriteLog ('=', sGrey, 'audio tree end');

    WriteLog ('=', sBlue, 'UNC');
    hr := F_GraphBuilder.EnumFilters(pEnumFilters);
    if (hr = S_OK) and assigned (pEnumFilters) then begin
       pEnumFilters.Reset;
       while pEnumFilters.Next(1, pFilter, @cFetched) = S_OK do begin
          if assigned (pFilter) then begin
             if pFilter.QueryFilterInfo (FilterInfo) = S_OK then begin
                if Filters.IndexOf (FilterInfo.achName) = -1 then begin
                   WriteLog (nil, sGrey, FilterInfo.AchName);
                end;
                FilterInfo.pGraph := nil;
             end;
             pFilter:= nil;
          end;
       end;
       pEnumFilters:= nil;
    end;
    WriteLog ('=', sBlue, 'UNC end');

    Filters.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.SnapGraph (var OutPin: IPin): TSaveFilterState;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   State: TSaveFilterState;
   PinInfo: TPin_Info;
   FilterInfo: TFilterInfo;
begin
    State := TSaveFilterState.Create;
    Result := State;
    if not assigned (F_GraphBuilder) then Exit;
    State.OutPinFilter := '';
    State.OutPinName := '';
    if OutPin.QueryPinInfo (PinInfo) = S_OK then begin
       State.OutPinName := PinInfo.achName;
       if PinInfo.pFilter.QueryFilterInfo (FilterInfo) = S_OK then begin
          State.OutPinFilter := FilterInfo.achName;
          FilterInfo.pGraph := nil;
       end;
       PinInfo.pFilter := nil;
    end;
    LogTree (F_VideoDevice, 0, State);
    LogTree (F_AudioDevice, 0, State);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.RestoreGraph (State: TSaveFilterState; out OutPin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pEnumFilters: iEnumFilters;
   cFetched: ULONG;
   pFilter: IBaseFilter;
   hr: HResult;
   FilterInfo: TFilterInfo;
   DoReset: Boolean;
   DoRemove: Boolean;
   Done: Boolean;
begin
    Result := False;
    if not assigned (F_GraphBuilder) then Exit;
    if not assigned (State) then Exit;

    hr := F_GraphBuilder.EnumFilters(pEnumFilters);
    if (hr = S_OK) and assigned (pEnumFilters) then begin
       pEnumFilters.Reset;
       while pEnumFilters.Next(1, pFilter, @cFetched) = S_OK do begin
          DoRemove := False;
          DoReset := False;
          if assigned (pFilter) then begin
             if pFilter.QueryFilterInfo (FilterInfo) = S_OK then begin
                if State.IndexOf (FilterInfo.achName) = -1 then begin
                   DoRemove := True;
                end;
                FilterInfo.pGraph := nil;
             end;
             if DoRemove then begin
                DoReset := F_GraphBuilder.RemoveFilter (pFilter) = S_OK;
             end;
             pFilter:= nil;
          end;
          if DoReset then begin
             pEnumFilters.Reset;
          end;
       end;
       pEnumFilters:= nil;
    end;

    hr := F_GraphBuilder.EnumFilters(pEnumFilters);
    if (hr = S_OK) and assigned (pEnumFilters) then begin
       pEnumFilters.Reset;
       Done := False;
       while (not Done) and (pEnumFilters.Next(1, pFilter, @cFetched) = S_OK) do begin
          if assigned (pFilter) then begin
             if pFilter.QueryFilterInfo (FilterInfo) = S_OK then begin
                if FilterInfo.achName = State.OutPinFilter then begin
                   Result := RetrievePinByName (PINDIR_OUTPUT, pFilter, State.OutPinName, False, OutPin);
                   if not Result then begin
                      Result := F_CaptureGraphBuilder2.FindPin (pFilter, PINDIR_OUTPUT, nil, nil, true, 0, OutPin) = S_OK;
                   end;
                   if Result then begin
                      Done := True;
                   end;
                end;
                FilterInfo.pGraph := nil;
             end;
             pFilter := nil;
          end;
       end;
       pEnumFilters:= nil;
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AddTransform (var Filter: IBaseFilter; VideoRotation: Boolean; HalfSizeDeinterlacing: Boolean; CustomSubtype: Boolean; CustomSubtypepGUID: pGUID; CustomTransform: TCustomTransform; CustomCalculateMediaType: TCustomCalculateMediaType): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TransformConfig: TTransformConfig;
begin
   Result := False;
   TransformConfig := FTransformConfig; { only rotation or half size in the same time }
   TransformConfig.GrabberData := Self;
   if assigned (CustomSubtypepGUID) then begin
      TransformConfig.CustomSubtypeGUID := CustomSubtypepGUID^;
   end
   else begin
      TransformConfig.CustomSubtypeGUID := GUID_NULL;
   end;
   TransformConfig.CustomSubtype := CustomSubtype;
   TransformConfig.CustomTransform := CustomTransform;
   TransformConfig.CustomCalculateMediaType := CustomCalculateMediaType;

   if TransformConfig.CustomSubtype then begin
      TransformConfig.Enabled := False;
      TransformConfig.VideoHalfDeinterlacing := False;
      TransformConfig.VideoRotation := rt_0_deg;
   end;
   if VideoRotation then begin
      TransformConfig.VideoHalfDeinterlacing := False;
   end
   else begin
      TransformConfig.VideoRotation := rt_0_deg;
      TransformConfig.VideoRotation_90_or_270 := False;
   end;

   if LoadFilter (nil, 'v~f', @LoadArray, FGrabberHandlers[gh_Transform].Handle, 'CreateLocalTransformInstance', Filter, '') then begin
      if Succeeded (Filter.QueryInterface (ITransformConfig, F_TransformConfig)) then begin
         F_TransformConfig.put_TransformConfig (@TransformConfig);
      end;
      Result := AddFilter (Filter, 'TrnfFltr');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertTransform (var VideoOut: IPin; VideoRotation: Boolean; HalfSizeDeinterlacing: Boolean; CustomSubtype: Boolean; CustomSubtypepGUID: pGUID; CustomTransform: TCustomTransform; CustomCalculateMediaType: TCustomCalculateMediaType): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Filter: IBaseFilter;
begin
   Result := False;
   if not AddTransform (Filter, VideoRotation, HalfSizeDeinterlacing, CustomSubtype, CustomSubtypepGUID, CustomTransform, CustomCalculateMediaType) then Exit;
   Result := InsertExistingFilter (Filter, VideoOut);
   Filter := nil;
end;

type
   pFileInfo = ^TFileInfo;
   TFileInfo = record
      Name: string;
      Time: LongInt;
   end;

function FileInfoNameAsc (Item1, Item2: Pointer): Integer;
begin
   if pFileInfo(Item1)^.Name > pFileInfo(Item2)^.Name then Result := 1
   else if pFileInfo(Item1)^.Name < pFileInfo(Item2)^.Name then Result := -1
   else Result := 0;
end;

function FileInfoNameDesc (Item1, Item2: Pointer): Integer;
begin
   if pFileInfo(Item1)^.Name > pFileInfo(Item2)^.Name then Result := -1
   else if pFileInfo(Item1)^.Name < pFileInfo(Item2)^.Name then Result := 1
   else Result := 0;
end;

function FileInfoTimeAsc (Item1, Item2: Pointer): Integer;
begin
   if pFileInfo(Item1)^.Time > pFileInfo(Item2)^.Time then Result := 1
   else if pFileInfo(Item1)^.Time < pFileInfo(Item2)^.Time then Result := -1
   else Result := 0;
end;

function FileInfoTimeDesc (Item1, Item2: Pointer): Integer;
begin
   if pFileInfo(Item1)^.Time > pFileInfo(Item2)^.Time then Result := -1
   else if pFileInfo(Item1)^.Time < pFileInfo(Item2)^.Time then Result := 1
   else Result := 0;
end;

function TVdgr.CreateSetOfBitmaps: Boolean;
type
   TSearchedFile = (sf_none, sf_bmp, sf_jpg);
var
   i: Integer;
   BitmapStream: TMemoryStream;
   FileSize: LongInt;
   FinalDir: String;
   MoreFiles: LongInt;
   SearchFile: TSearchRec;
   SearchedFileType: TSearchedFile;
   FileTypeFound: TSearchedFile;
   pPoint: LongInt;
   Ext: String;
   FileList: TList;
   FileInfo: pFileInfo;
   FileName: String;
   ProgressInfo: TProgressInfo;
   FileStream: TFileStream;
   FrameCount: LongWord;
   Buffer: pByte;
   cbFileHeader: dword;
   pBmi: pBitmapInfo;
   FirstBmiHeader: TBitmapInfoHeader;
   FirstSample: Boolean;
   BitmapOk: Boolean;
   JPEGImage: TJPEGImage;
   BItmapImage: TBitmap;
begin
   Result := False;
   if FVideoFromImages.CreatingSetOfBitmaps then Exit;
   if FVideoFromImages.InUse and (FVideoFromImages.BitmapsFileStreamName = FVideoFromImages_TemporaryFile) then Exit;
   if LogB (FVideoFromImages.InUse and (FVideoFromImages.BitmapsFileStreamName = FVideoFromImages_TemporaryFile), LERROR, e_file_in_use, 'file already in use: ' + FVideoFromImages_TemporaryFile) then Exit;

   FileStream := CreateOrOpenFileStream (FVideoFromImages_TemporaryFile, fmCreate);
   if LogB (not assigned (FileStream), LERROR, e_failed_to_create_file, 'failed to create file: ' + FVideoFromImages_TemporaryFile) then Exit;
   FileStream.Seek (0, soFromBeginning);

   FVideoFromImages.CreatingSetOfBitmaps := True;
   Result := False;
   FileList := nil;
   try
      FinalDir := FVideoFromImages_SourceDirectory;
      if length(FinalDir) = 0 then begin
         FinalDir := '.';
      end;
      if FinalDir[length(FinalDir)] <> '\' then begin
         FinalDir := FinalDir + '\';
      end;
      ForceDirectories2 (FinalDir);
      if LogB (not DirectoryExists (FinalDir), LERROR, e_invalid_directory, 'invalid bitmaps source directory: "' + FVideoFromImages_SourceDirectory + '"') then Exit;

      if CanInvokeEvent (TPObj(Intf.FOnBitmapsLoadingProgress)) then begin
         ProgressInfo.Percent := -1;
         ProgressInfo.Position := 0;
         ProgressInfo.Duration := 0;
         ProgressInfo.Comment := 'loading bitmaps from ' + FinalDir;
         Intf.FOnBitmapsLoadingProgress (Intf, ProgressInfo);
      end;

      FileList := TList.Create;

      SearchedFileType := sf_None;
      MoreFiles := FindFirst (FinalDir + '*', faAnyFile, SearchFile);
      if MoreFiles = 0 then begin
         while MoreFiles = 0 do begin
            pPoint := FindPosLastChar ('.', SearchFile.Name);
            FileTypeFound := sf_None;
            if pPoint > 0 then begin
               Ext := UpperCase (Copy (SearchFile.Name, pPoint + 1, MAXINT));
               if (Ext = 'BMP') then begin
                  FileTypeFound := sf_bmp;
                  if SearchedFileType = sf_None then begin
                     SearchedFileType := sf_bmp;
                  end;
               end
               else if (Ext = 'JPG') or (Ext = 'JPEG') or (Ext = 'JPE') then begin
                  FileTypeFound := sf_jpg;
                  if SearchedFileType = sf_None then begin
                     SearchedFileType := sf_jpg;
                  end;
               end
               else begin
                  FileTypeFound := sf_none;
               end;
            end;
            if SearchedFileType <> sf_None then begin
               if FileTypeFound = SearchedFileType then begin
                  New (FileInfo);
                  FileInfo.Name := SearchFile.Name;
                  FileInfo.Time := SearchFile.Time;
                  FileList.Add (FileInfo);
               end;
            end;
            MoreFiles := FindNext (SearchFile);
         end;
         FindClose (SearchFile);
      end;

      if LogB (FileList.Count = 0, LERROR, e_file_not_found, 'sorry, there is no BMP or JPEG files in "' + FVideoFromImages_SourceDirectory + '"') then Exit;

      case FVideoFromImages_BitmapsSortedBy of
         fs_TimeAsc  : FileList.Sort (FileInfoNameAsc);
         fs_TimeDesc : FileList.Sort (FileInfoNameDesc);
         fs_NameAsc  : FileList.Sort (FileInfoTimeAsc);
         fs_NameDesc : FileList.Sort (FileInfoTimeDesc);
      end;

      FrameCount := 0;
      FirstSample := True;
      FileStream.Write (FrameCount, sizeof (LongWord)); { will be overwritten at the end with the real count }
      for i := 0 to FileList.Count - 1 do begin
         FileName := FinalDir + pFileInfo (FileList[i])^.Name;
         if FileExists (FileName) then begin
            BitmapStream := TMemoryStream.Create;
            if SearchedFileType = sf_Bmp then begin
               BitmapStream.LoadFromFile (FileName);
            end
            else if SearchedFileType = sf_Jpg then begin
               JPEGImage := TJPEGImage.Create;
               JPEGImage.LoadFromFile (FileName);
               BitmapImage := TBitmap.Create;
               BitmapImage.Assign (JPEGImage);
               JPEGImage.Free;
               BitmapImage.SaveToStream (BitmapStream);
               BitmapImage.Free;
            end;
            BitmapStream.Seek (0, soFromBeginning);
            FileSize := BitmapStream.Size;
            Buffer := BitmapStream.Memory;

            cbFileHeader := sizeof (TBitmapFileHeader);
            pBmi := pBitmapInfo (dword (Buffer) + cbFileHeader);
            if FirstSample then begin
               FirstSample := False;
               BitmapOk := True;
               CopyMemory (@FirstBmiHeader, @(pBmi^.bmiHeader), sizeof (TBitmapInfoHeader));
            end
            else begin
               BitmapOk := False;
            end;
            if not BitmapOk then begin
               BitmapOk := CompareMem (@FirstBmiHeader, @(pBmi^.bmiHeader), sizeof (TBitmapInfoHeader));
            end;
            if BitmapOk then begin
               FileStream.Write (FileSize, sizeof (LongInt));
               FileStream.CopyFrom (BitmapStream, BitmapStream.Size);
               inc (FrameCount);
               if CanInvokeEvent (TPObj(Intf.FOnBitmapsLoadingProgress)) then begin
                  ProgressInfo.Percent := Round ((i + 1) * 100 / FileList.Count);
                  ProgressInfo.Position := i;
                  ProgressInfo.Duration := 0;
                  ProgressInfo.Comment := 'loading ' + pFileInfo (FileList[i])^.Name;
                  Intf.FOnBitmapsLoadingProgress (Intf, ProgressInfo);
               end;
            end
            else begin
               if CanInvokeEvent (TPObj(Intf.FOnBitmapsLoadingProgress)) then begin
                  ProgressInfo.Percent := Round ((i + 1) * 100 / FileList.Count);
                  ProgressInfo.Position := -1;
                  ProgressInfo.Duration := 0;
                  ProgressInfo.Comment := 'SIZE/FORMAT MISMATCH: ' + pFileInfo (FileList[i])^.Name;
                  Intf.FOnBitmapsLoadingProgress (Intf, ProgressInfo);
               end;
            end;
            BitmapStream.Free;
         end;
      end;
      FileStream.Seek (0, soFromBeginning);
      FileStream.Write (FrameCount, sizeof (LongWord));
      Result := FrameCount > 0;

      if CanInvokeEvent (TPObj(Intf.FOnBitmapsLoadingProgress)) then begin
         ProgressInfo.Percent := -1;
         ProgressInfo.Position := FileList.Count - 1;
         ProgressInfo.Duration := 0;
         ProgressInfo.Comment := IntToStr (FrameCount) + ' bitmaps written to ' + FVideoFromImages_TemporaryFile;
         Intf.FOnBitmapsLoadingProgress (Intf, ProgressInfo);
      end;
   finally
      if assigned (FileList) then begin
         while FileList.Count > 0 do begin
            Dispose (FileList[0]);
            FileList.Delete (0);
         end;
         FileList.Free;
      end;
      if assigned (FileStream) then begin
         FileStream.Free;
      end;
      FVideoFromImages.CreatingSetOfBitmaps := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.BindPushSource (var VideoOut: IPin; GetVideoFormatBmiInfoCB: TGetVideoFormatBmiInfoCB; GetVideoFormatPMediaTypeCB: TGetVideoFormatPMediaTypeCB; GetSampleDataCB: TGetSampleDataCB): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   PushSource: IBaseFilter;
begin
   Result := False;
   FPushSourceConfig.Vdgr := Self;
   if FMultiplexedRole = mr_MultiplexedSlave then begin
      FPushSourceConfig.FrameRate := FCurrent.MultiplexedSlaveFrameRate / 100;
   end
   else
   begin
      FPushSourceConfig.FrameRate := FCurrent.FrameRate / 100;
   end;
   FPushSourceConfig.GetVideoFormatBmiInfoCB := GetVideoFormatBmiInfoCB;
   FPushSourceConfig.GetVideoFormatPMediaTypeCB := GetVideoFormatPMediaTypeCB;
   FPushSourceConfig.GetSampleDataCB := GetSampleDataCB;

   if LoadFilter (nil, 'v~f', @LoadArray, FGrabberHandlers[gh_PushSource].Handle, 'CreateLocalPushSourceInstance', PushSource, '') then begin
      if Succeeded (PushSource.QueryInterface (IPushSourceConfig, F_PushSourceConfig)) then begin
         F_PushSourceConfig.put_PushSourceConfig (@FPushSourceConfig);
      end;
      if AddFilter (PushSource, 'PushSrc') then begin
         Result := Succeeded (F_CaptureGraphBuilder2.FindPin (PushSource, PINDIR_OUTPUT, nil, nil, true, 0, VideoOut));
      end;
      PushSource := nil;
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.RenderAudioDevice: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
    Result := false;
    with FAudioRendering do begin
      try
         if not CreateInstance (@CLSID_CaptureGraphBuilder2, ICaptureGraphBuilder2, CaptureGraphBuilder2, 'Graph Builder') then Exit;
         if not CreateInstance (@CLSID_FilterGraph, IGraphBuilder, GraphBuilder, 'Filter Graph') then Exit;
         if Failed (CaptureGraphBuilder2.SetFiltergraph(GraphBuilder)) then Exit;
         if Failed (GraphBuilder.QueryInterface (IFilterGraph2, FilterGraph2)) then Exit;
         if not BindAndAddDevice (FilterGraph2, _AudioDevices, FCurrent.AudioDevice, '', AudioDevice, False, pBDummy, True, GetAudioInputName) then Exit;
         if Failed (CaptureGraphBuilder2.RenderStream (nil, @MEDIATYPE_Audio, AudioDevice, nil, nil)) then Exit;
         if Failed (FilterGraph2.QueryInterface (IMediaControl, MediaControl)) then Exit;
         MediaControl.Run;
         Result := True;
      finally
         if not Result then begin
            ClearAudioDeviceRendering (@FAudioRendering);
         end;
      end;
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.InstallClk;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   MediaFilter: IMediaFilter;
   CustomClk: IBaseFilter;
begin
      F_GraphBuilder.SetDefaultSyncSource;

      if F_GraphBuilder.QueryInterface (IMediaFilter, MediaFilter) = S_OK then begin
         if FGraphType <> cs_Playback then begin
            MediaFilter.GetSyncSource(F_ReferenceClock);
         end
         else begin
            if not FCurrent.PlayerAudioRendering then begin
               MediaFilter.SetSyncSource (nil);
               if FCurrent.VideoRenderer <> vr_None then begin
                  if LoadFilter (nil, 'v~f', @LoadArray, FGrabberHandlers[gh_CustClk].Handle, 'CreateLocalCustClckInstance', CustomClk, '') then begin
                     if CustomClk.QueryInterface (IReferenceClock, F_ReferenceClock) = S_OK then begin
                        if F_ReferenceClock.QueryInterface (ICustomClock, F_CustomClock) = S_OK then begin
                           F_CustomClock.SetClock (Round(BASECLOCKVALUE / FPlayerSpeedRatio));
                        end;
                        MediaFilter.SetSyncSource (F_ReferenceClock);
                     end;
                     CustomClk:= nil;
                  end;
               end;
            end;
         end;
         MediaFilter := nil;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TAutoTuningStepThread.Execute;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   while not Terminated do begin
      with TVdgr(FIntf._Vdgr) do begin
         if FDestroying then begin
            Terminate;
         end
         else if FIsTVAutoTuneRunning then begin
            if not FTVProcessingTVAutoScan then begin
               PostCommand (WMProcessContinueTVAutoScan);
            end;
         end
         else begin
            DoSuspend;
         end;
      end;
      Sleep (FSleepTime);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TAutoTuningStepThread.OnTimer (Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not FInTimer then begin
      FInTimer := True;
      with TVdgr(FIntf._Vdgr) do begin
         if FDestroying then begin
            TTimer(Sender).Enabled := False;
         end
         else if FIsTVAutoTuneRunning then begin
            if not FTVProcessingTVAutoScan then begin
               PostCommand (WMProcessContinueTVAutoScan);
            end;
         end
         else begin
            DoSuspend;
         end;
      end;
      FInTimer := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessOnReadyToStart (Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   TTimer (Sender).Enabled := False;
   Intf.FOnRecordingReadyToStart (Intf);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessPlayByStep (Initial: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Position: int64;
   CurrentTickCount: LongWord;
   TimeInterval_Ms: int64;
begin
   with FCurrentFrameData do begin
      if not assigned (F_MediaSeeking) then Exit;
      if Failed (F_MediaSeeking.GetCurrentPosition (Position)) then Exit;

      Position := Round (Position / PlayerFrameInterval) * PlayerFrameInterval;

      if Initial then begin
         if FFilterState <> state_Paused then begin
            ChangeGraphState (State_Paused, 'spbw');
         end;
         PlayerStepClockLastPosition := Position;
         if PlayerSeekBackwards then begin
            if Position <= FCurrentFrameData.PlayerFrameInterval then begin
               ProcessPlayerNewPosition (FPlayerDuration - PlayerFrameInterval);
               PlayerStepClockLastPosition := FFrameInfo_Current.PlayerNewPosition;
            end;
         end
         else begin
            if Position >= (FPlayerDuration  - PlayerFrameInterval) then begin
               ProcessPlayerNewPosition (0);
               PlayerStepClockLastPosition := FFrameInfo_Current.PlayerNewPosition;
            end;
         end;
         PlayerStepClockLastTickCount := GetTickCount;
      end
      else begin
         CurrentTickCount := GetTickCount;
         TimeInterval_Ms := CurrentTickCount - PlayerStepClockLastTickCount;
         PlayerStepClockLastTickCount := CurrentTickCount; // remember for the next round

         if FCurrentFrameData.PlayerFastSeek then begin
            inc (PlayerStepClockCalculatedNewPositionShift_100ns, Round (TimeInterval_Ms * PlayerFrameInterval * FPlayerFastSeekSpeedRatio / 40));
         end
         else begin
            inc (PlayerStepClockCalculatedNewPositionShift_100ns, Round (TimeInterval_Ms * PlayerFrameInterval * FPlayerSpeedRatio / 40));
         end;
         if PlayerEmulateSpeedRatio then begin { play with speed ratio <> 1 and cannot use speed ratio }
            if Position < FPlayerDuration then begin
               F_VideoFrameStep.Step (1, nil);
            end
            else begin
               FPlayerBackwardTimerEnabled := False;
               FRaiseEndOfStream := True;
               PostCommand (WMProcessNotifyEvent);
            end;
         end
         else begin
            if PlayerStepClockCalculatedNewPositionShift_100ns >= PlayerFrameInterval then begin
               if PlayerSeekBackwards then begin { play backwards }
                  Dec (PlayerStepClockLastPosition, PlayerStepClockCalculatedNewPositionShift_100ns);
                  if PlayerStepClockLastPosition > 0 then begin
                     ProcessPlayerNewPosition (PlayerStepClockLastPosition);
                  end
                  else begin
                     FPlayerBackwardTimerEnabled := False;
                     ProcessPlayerNewPosition (0);
                     PlayerStepClockLastPosition := 0;
                  end;
               end
               else begin { play forwards }
                  Inc (PlayerStepClockLastPosition, PlayerStepClockCalculatedNewPositionShift_100ns);
                  if PlayerStepClockLastPosition < FPlayerDuration then begin
                     ProcessPlayerNewPosition (PlayerStepClockLastPosition);
                  end
                  else begin
                     FPlayerBackwardTimerEnabled := False;
                     //ProcessPlayerNewPosition (FPlayerDuration);
                     FRaiseEndOfStream := True;
                     PostCommand (WMProcessNotifyEvent);
                  end;
               end;
               PlayerStepClockCalculatedNewPositionShift_100ns := 0;
            end;
         end;
      end;
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessStopGraph;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   PostInactive: Boolean;
   i: LongInt;
begin
   if not FGraphAccessAllowed then Exit;
   if FProcessingStopGraph then Exit;
   FProcessingStopGraph := True;
   //if not FDestroying then FlushMessages; ZZZZZ
   FGraphAccessAllowed := False;
   ChangeBusyStateAndCursor (true);
   PostInactive := True;

   if FMultiplexedRole = mr_MultiplexedMaster then begin
      if FGraphType in [cs_Preview, cs_Recording] then begin
         for i := MULTIPLEXEDSLAVE_MINBOUND to MULTIPLEXEDSLAVE_MAXBOUND do begin
             if assigned (FMultiplexedSlave[i].Vdgr) then begin
                FMultiplexedSlave[i].Vdgr.ProcessStopGraph;
             end;
         end;
      end;
   end;

   case FGraphType of
      cs_Preview: begin
         ClearGraph (True);
      end;
      cs_Recording: begin
         FRecordingResultNotifiedAfterReencoding := False;
         if FCurrent.RecordingMethod = rm_Stream then begin
            ClearGraph (True);
         end
         else begin
            FRecordingSuccessful := FRecordingStarted;
            ClearGraph (True);
            if FRecordingSuccessful then begin
               FGlobalRegSave[_LastRecordingFileName].s := FRealRecordingFileName;
               if FRecordingMethod = rm_AVI then begin
                  FRecordingResultNotifiedAfterReencoding := ReencodeCapturedFileIfRequired;
               end;
            end;
            if not FRecordingResultNotifiedAfterReencoding then begin
               PostEvent (@Intf.FOnRecordingCompleted);
            end;
         end;
      end;
      cs_Playback: begin
         ClearGraph (True);
         if assigned (FPlayerTrackBar) then begin
            FPlayerTrackBar.Position := 0;
         end;
      end;
      cs_Reencoding: begin
         ClearGraph (True);
         FReencodingProgressInfo.Position := FReencodingProgressInfo.Duration;
         FReencodingProgressInfo.Percent := 100;
         if FCopyingPreallocData then begin
            if FReencodeOrRecopyDataSucceeded then begin
               PostEvent (@Intf.FOnCopyPreallocDataProgress); // report 100%
            end;
         end
         else begin
            if FReencodeOrRecopyDataSucceeded then begin
               PostEvent (@Intf.FOnReencodingProgress); // report 100%
            end;
         end;
         if FCopyingPreallocData then begin
            PostEvent (@Intf.FOnCopyPreallocDataCompleted);
         end
         else begin
            PostEvent (@Intf.FOnReencodingCompleted);
         end;
         if FRecordingResultNotifiedAfterReencoding then begin
            FRecordingResultNotifiedAfterReencoding := False;
            PostEvent (@Intf.FOnRecordingCompleted);
         end;
      end
      else begin
         PostInactive := false;
      end;
   end;

   ChangeBusyStateAndCursor (false);
   if PostInactive then begin
      PostEvent (@Intf.FOnInactive);
   end;
   FProcessingStopGraph := False;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.PrepareAudioRendering;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FSpeakerControl then begin
      GetMixerVolume (FSavedVolume, FSavedBalance);
   end;

   ActivateAudioInputAndSetValues;

   if (FCurrent.AudioDeviceRendering) and (FGraphType = cs_Recording) then begin
      if not FRenderingAudio then begin
         if not FAudioRegSave[_AIsSoundCard].b then begin { otherwise the capture board used is the soundcard }
            RenderAudioDevice;
         end;
      end;
      UpdateSpeakersControl;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.AdjustVideoCompressionSettings;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   AMVideoCompression: IAMVideoCompression;
   Dummy1, Dummy2: LongInt;
   Capabilities: LongInt;
   CanKeyFrameRate: Boolean;
   CanPFramesPerKeyFrame: Boolean;
   CanQuality: Boolean;
   CanWindowSize: Boolean;
   DefaultKeyFrameRate: LongInt;
   DefaultPFramesPerKeyFrame: LongInt;
   DefaultQuality: Double;
begin
   if not (FGraphType in [cs_Recording, cs_Reencoding]) then Exit;
   if Failed (F_CaptureGraphBuilder2.FindInterface(nil, nil, nil, IAMVideoCompression, AMVideoCompression)) then Exit;
   DefaultKeyFrameRate:= 15;
   DefaultPFramesPerKeyFrame := 0;
   DefaultQuality := 1;
   if Succeeded (AMVideoCompression.GetInfo (nil, Dummy1, nil, Dummy2, DefaultKeyFrameRate, DefaultPFramesPerKeyFrame, DefaultQuality, Capabilities)) then begin

      CanQuality := (Capabilities and CompressionCaps_CanQuality) <> 0;
      CanKeyFrameRate := (Capabilities and CompressionCaps_CanKeyFrame) <> 0;
      CanPFramesPerKeyFrame := (Capabilities and CompressionCaps_CanBFrame) <> 0;
      CanWindowSize := (Capabilities and CompressionCaps_CanWindow) <> 0;

      if CanInvokeEvent (TPObj(Intf.FOnVideoCompressionSettings)) then begin
         Intf.FOnVideoCompressionSettings (Intf, CanKeyFrameRate, CanPFramesPerKeyFrame, CanQuality, CanWindowSize, DefaultKeyFrameRate, DefaultPFramesPerKeyFrame, DefaultQuality);
      end;

      if CanKeyFrameRate and (FVideoCompression_KeyFrameRate <> -1) then begin
         AMVideoCompression.put_KeyFrameRate (FVideoCompression_KeyFrameRate);
      end;

      if CanPFramesPerKeyFrame and (FVideoCompression_PFramesPerKeyFrame <> -1) then begin
         AMVideoCompression.put_PFramesPerKeyFrame (FVideoCompression_PFramesPerKeyFrame);
      end;

      if CanQuality and (FVideoCompression_Quality <> -1) then begin
         AMVideoCompression.put_Quality (FVideoCompression_Quality);
      end;

      if CanWindowSize and (FVideoCompression_WindowSize <> -1) then begin
         AMVideoCompression.put_WindowSize (FVideoCompression_WindowSize);
      end;
   end;
   AMVideoCompression := nil;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertSmartTeeBeforeFilter (FilterName: String; var ScPin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pOleS: pOleStr;
   Filter: IBaseFilter;
   FilterIn: IPin;
   OutToFilter: IPin;
   DummyPin: IPin;
begin
   Result := True;
   pOleS := stringToOleStr (FilterName);
   if Succeeded (F_GraphBuilder.FindFilterByName (pOleS, Filter)) then begin
      Result := False;
      if Succeeded (F_CaptureGraphBuilder2.FindPin (Filter, PINDIR_INPUT, nil, nil, False, 0, FilterIn)) then begin
         if Succeeded (FilterIn.ConnectedTo (OutToFilter)) then begin
            FilterIn.Disconnect;
            OutToFilter.Disconnect;
            if InsertSmartTee (@CLSID_SmartTee, SingleText('Smart Tee'), OutToFilter, OutToFilter, DummyPin) then begin
               if Succeeded (OutToFilter.Connect (FilterIn, nil)) then begin
                  ScPin := OutToFilter;
                  Result := True;
               end;
            end;
            OutToFilter := nil;
         end;
         FilterIn := nil;
      end;
      Filter := nil;
   end;
   SysFreeString (pOleS);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.FindScPins;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RecordingFilter: IBaseFilter;
begin
   InsertSmartTeeBeforeFilter ('VIDC', F_ScCapturePinVideo);
   if FCurrent.RecordingMethod = rm_AVI then begin
      if assigned (F_AVIFileMux) then begin
         RecordingFilter := F_AVIFileMux;
      end;
   end
   else if FCurrent.RecordingMethod = rm_ASF then begin
      if assigned (F_ASFFileMux) then begin
         RecordingFilter := F_ASFFileMux;
      end;
   end;
   if not assigned (RecordingFilter) then Exit;
   InsertSmartTeeBeforeFilter ('AUDC', F_ScCapturePinAudio);
   if not assigned (RecordingFilter) then Exit;
   if not assigned (F_ScCapturePinVideo) then begin
      FindConnectedPinsTypeAndSubtype (RecordingFilter, PINDIR_INPUT, @MEDIATYPE_Video, nil, F_ScCapturePinVideo);
   end;
   if not assigned (F_ScCapturePinAudio) then begin
      FindConnectedPinsTypeAndSubtype (RecordingFilter, PINDIR_INPUT, @MEDIATYPE_Audio, nil, F_ScCapturePinAudio);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CompleteGraphBuilding  (CanActivateThreads: Boolean; FileMuxSetMasterStream: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ gets the media event Handler and the media control interface of the current graph
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
   SubtypeGUID: String;
   SubtypeInfo: String;
begin
   Result := False;

   if FCurrent.HoldRecording then begin
      FindScPins;
   end;

   if FGraphType <> cs_Reencoding then begin
      PrepareAudioRendering;
      VideoStreamConfigGetRealFrameRate;
      AdjustVideoCompressionSettings;
      Hr := F_CaptureGraphBuilder2.FindInterface(nil, nil, F_VideoDevice, IAMDroppedFrames, F_AMDroppedFrames);
      LogH (Hr, LTRACE, e_trace_log, 'find dropped frames interface');
      GetWindowHandle (@FVideoRendererW);
      GetWindowHandle (@FVideoRendererW2);
      GetWindowHandle (@FOverlayRendererW);
   end;

   hr := F_GraphBuilder.QueryInterface (IMediaControl, F_MediaControl);
   if not LogH (Hr, LERROR, e_get_interface, 'get control interface') then Exit;

   if not assigned (F_MediaEventEx) then begin
      hr:= F_GraphBuilder.QueryInterface(IMediaEventEx, F_MediaEventEx);
      LogH (Hr, LERROR, e_get_interface, 'get Event ex interface');
   end;

   if assigned (F_MediaEventEx) then begin
      F_MediaEventEx.SetNotifyFlags (0);
      //if Intf.HasParent then begin
         F_MediaEventEx.SetNotifyWindow(Intf.Handle, WM_NOTIFYWINDOW, 1);
      //end;
      F_MediaEventEx.CancelDefaultHandling (EC_REPAINT);
   end;

   InstallClk;
   if FGraphType <> cs_Reencoding then begin
      ProcessOverlayColorKey;
      LogTrees;
      if F_GraphBuilder.QueryInterface (IVideoWindow, F_GraphVideoWindow) = S_OK then begin
         F_GraphVideoWindow.Put_AutoShow (False);
      end;
      SetNeedFrameOverlayDC;
      AssociateVideoWindows;
   end;

   FileMuxSettings (FileMuxSetMasterStream);

   SaveFrameGrabberMediaType;

   if CanActivateThreads then begin
      FCurrentFrameData.NewFrameNotNotifiedByFrameGrabber := not assigned (FGrabberHandlers[gh_SampleNotify].Grabber) and (FCurrent.FrameGrabber = fg_Disabled);
   end;

   if FGraphType = cs_Recording then begin
      LogB (FCurrent.FrameGrabber in [fg_BothStreams, fg_CaptureStream], LWARNING, w_frame_grabber_requires_CPU, 'The frame grabber requires CPU and can cause dropped frames or jerky preview. If you do not need graphics overlays or video processing in the video clip, disable it or set it on the preview stream only.');

      if GetCurrentSubtypeGUID (SubtypeGUID) then begin
         LogB (true, LINFO, i_recording_videosubtype, 'selected subtype: ' + ReturnFourCc (SubtypeGUID));
         LogB (true, LINFO, i_recording_videosubtype, 'recording subtype: ' + ReturnFourCc (GUIDToString (FRecordingSubtype)));
         if FCurrent.FrameGrabber in [fg_BothStreams, fg_CaptureStream] then begin
            SubtypeInfo := '(the subtype has been overridden because frame grabber is used on the recording stream, it must be set to "fg_Disabled" or "fg_PreviewStream" to record in the desired video subtype)';
            LogB (true, LINFO, i_recording_videosubtype, SubtypeInfo);
         end;
      end;
   end;
   Result := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.Allow (Options: TSetCurrentState; Level: LongInt; RequireLiveDevices: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns true or false according to the current action of the graph and the incompatible states.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Ok: Boolean;
begin
   Ok := true;
   if LogB ((IsLiveVideoSource and RequireLiveDevices and (cs_Preview in Options) or (cs_Recording in Options)) and (FVideoDevice = -1), Level, e_no_video_device_selected, 'no video device selected') then Ok := false;
   if LogB ((FGraphType = cs_Recording) and not (cs_Recording in Options), Level, e_stop_recording_first, 'first stop recording') then Ok := false;
   if LogB ((FGraphType = cs_Reencoding) and not (cs_Reencoding in Options), Level, e_reencoding, 'first stop reencoding') then Ok := false;
   if LogB ((FGraphType = cs_Playback) and not (cs_Playback in Options), Level, e_stop_player_first, 'first close player') then Ok := false;
   if LogB ((FGraphType = cs_Preview) and not (cs_Preview in Options), Level, e_stop_preview_first, 'first stop preview') then Ok := false;
   if LogB ((FGraphType = cs_Down) and (Options = [cs_Preview]), Level, e_start_preview_first, 'first start preview') then Ok := false;
   Result := Ok;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.LogB (Test: Boolean; Level: LongInt; LogType: TLogType; Msg: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ logs events
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: Hresult;
begin
   if Test then begin
      Hr := E_FAIL;
   end
   else begin
      Hr := S_OK;
   end;
   Result := not LogH (Hr, Level, LogType, Msg);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.LogH (Hr: Hresult; Level: LongInt; LogType: TLogType; Msg: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ logs events, same as above, but take a HRESULT as parameter instead of a Boolean
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Severity: string;
   LogColor: String;
begin
      Result := False;
      if not assigned (Intf) then Exit;
      if not FInitializedAtRuntime then Exit;

      if Succeeded (Hr) then begin
         Result := true;
      end
      else begin
         Result := false;
         case Level of
            LINFO: begin
               Severity:= 'INFO';
            end;
            LWARNING: begin
               Severity:= 'WARNING';
            end;
            LERROR: begin
              Severity:= 'ERROR';
            end;
            else begin
              Severity := 'ERROR';
            end;
         end;
      end;

      if Log_DoLogToFile then begin
         if Result or (Level = LINFO) then begin
            LogColor := sBlack;
         end
         else begin
            LogColor := sRed;
         end;
         WriteLog (nil, LogColor, inttostr (LongInt (LogType)) + ' ' + Severity + ': ' + Msg);
      end;
      if not Result then begin
         if Level in [LINFO, LWARNING, LERROR] then begin
            if CanInvokeEvent (TPObj(Intf.FOnLog)) then Intf.FOnLog (Intf, LogType, Severity, Msg);
         end;
      end;
end;

(*
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ClearStream(var Filter: IBaseFilter);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ Closes the stream in the downstream direction starting from Filter
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FilterPin, PinTo: IPin;
   Pins: IEnumPins;
   PinInfo: TPIN_INFO;
   hr: HRESULT;
   cFetched: ULONG;
begin
   if Filter = nil then Exit;
   Pins:= nil;
   Hr := Filter.EnumPins(Pins);
   if Hr <> S_OK then Exit;
   if Pins = nil then Exit;
   Pins.Reset;
   while hr = S_OK do begin
      hr:= Pins.Next(1, FilterPin, @cFetched);
      if (hr = S_OK) and assigned (FilterPin) then begin
         FilterPin.ConnectedTo(PinTo);
         if assigned (PinTo) then begin
            hr:= PinTo.QueryPinInfo(PinInfo);
            if hr = S_OK then begin
  	       if PinInfo.dir = PINDIR_INPUT then begin
	          F_GraphBuilder.Disconnect(PinTo);
	          F_GraphBuilder.Disconnect(FilterPin);
                  F_GraphBuilder.RemoveFilter(PinInfo.pFilter);
               end;
            end;
            PinInfo.pFilter:= nil;
            PinTo:= nil;
         end;
         FilterPin:= nil;
      end;
   end;
   Pins:= nil;
end;
*)

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AddFilterGetInput (ClsidFilter: pGUID; FilterName: string; out Filter: IBaseFilter; out FilterIn: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ adds the ClsidFilter filter named by FilterName to the graph, returns the Filter pointer and the in pin
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := false;
   if CreateInstance(ClsidFilter, IBaseFilter, Filter, FilterName) then begin
      if AddFilter (Filter, FilterName) then begin
         if F_CaptureGraphBuilder2.FindPin (Filter, PINDIR_INPUT, nil, nil, true, 0, FilterIn) = S_OK then begin
            WriteLog (nil, sGrey, 'AddFilterGetInput ok: ' + FilterName);
            Result := true;
         end
         else begin
            WriteLog (nil, sRed, 'ERROR: AddFilterGetInput cannot find input pin in filter ' + FilterName);
         end;
      end
      else begin
         WriteLog (nil, sRed, 'ERROR: AddFilterGetInput cannot add filter ' + FilterName);
      end;
   end
   else begin
      WriteLog (nil, sRed, 'ERROR: AddFilterGetInput cocreate instance failed on filter ' + FilterName);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AddFilterGetInput2Outputs (ClsidFilter: pGUID; FilterName: string; out Filter: IBaseFilter; out FilterIn: IPin; out FilterOut1, FilterOut2: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ adds the ClsidFilter filter named by FilterName to the graph, returns the Filter pointer, the in and out pins
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := false;
   Filter := nil;
   FilterIn := nil;
   FilterOut1 := nil;
   FilterOut2 := nil;
   if CreateInstance(ClsidFilter, IBaseFilter, Filter, FilterName) then begin
      if AddFilter (Filter, FilterName) then begin
         if F_CaptureGraphBuilder2.FindPin (Filter, PINDIR_INPUT, nil, nil, true, 0, FilterIn) = S_OK then begin
            if F_CaptureGraphBuilder2.FindPin (Filter, PINDIR_OUTPUT, nil, nil, true, 0, FilterOut1) = S_OK then begin
               if F_CaptureGraphBuilder2.FindPin (Filter, PINDIR_OUTPUT, nil, nil, true, 1, FilterOut2) = S_OK then begin
                  Result := true;
               end
               else begin
                  WriteLog (nil, sRed, 'ERROR: AddFilterGetInput2Outputs cannot find output pin #2 in filter ' + FilterName);
               end;
            end
            else begin
               WriteLog (nil, sRed, 'ERROR: AddFilterGetInput2Outputs cannot find output pin #1 in filter ' + FilterName);
            end;
         end
         else begin
            WriteLog (nil, sRed, 'ERROR: AddFilterGetInput2Outputs cannot find input pin in filter ' + FilterName);
         end;
      end
      else begin
         WriteLog (nil, sRed, 'ERROR: AddFilterGetInput2Outputs cocreate instance failed on filter ' + FilterName);
      end;
   end
   else begin
      WriteLog (nil, sRed, 'ERROR: AddFilterGetInput2Outputs cocreate instance failed on filter ' + FilterName);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetPin(pFilter: IBaseFilter; DirRequired :TPin_Direction; iNum: LongInt; out ppPin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ locate the pin in the required direction
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pEnum: IEnumPins;
   ulFound: ULONG;
   pPin: IPin;
   PinInfo: TPin_Info;
   Done: Boolean;
begin
   Result := false;
   ppPin := nil;
   if pFilter.EnumPins(pEnum) <> S_OK then Exit;

   Done := false;
   while not Done do begin
      if pEnum.Next(1, pPin, @ulFound) <> S_OK then begin
         Done := true;
      end
      else begin
         if assigned (pPin) then begin
            if pPin.QueryPinInfo (PinInfo) = S_OK then begin
               if PinInfo.Dir = DirRequired then begin
                  if iNum = 0 then begin
                     ppPin := pPin;
                     Result := true;
                     Done := true;
                  end
                  else begin
                     dec (iNum);
                  end;
               end;
            end;
            PinInfo.pFilter := nil;
         end;
         pPin := nil;
      end;
   end;
   pEnum := nil;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function CountFilterPins(pFilter: IBaseFilter; var pulInPins, pulOutPins: ULONG): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ returns the number of input and output pins of a filter
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pEnum: IEnumPins;
   ulFound: ULONG;
   pPin: IPin;
   PinInfo: TPin_Info;
begin
 Result := false;
 pulInPins := 0;
 pulOutPins := 0;
 try
   if not assigned (pFilter) then Exit;

   if pFilter.EnumPins(pEnum) <> S_OK then Exit;
   if pEnum = nil then Exit;

   pEnum.Reset;

   while pEnum.Next(1, pPin, @UlFound) = S_OK do begin
      if assigned (pPin) then begin
         if pPin.QueryPinInfo (PinInfo) = S_OK then begin
            if PinInfo.Dir = PINDIR_INPUT then begin
               inc (pulInPins);
            end
            else begin
              inc (pulOutPins);
            end;
         end;
         PinInfo.pFilter := nil;
         pPin := nil;
      end;
    end;
    Result := true;
  finally
    pFilter := nil;
    pEnum := nil;
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.FindRenderer(pMediaType: PGUID; out ppFilter: IBaseFilter; out ppInputPin: IPin; GetVideoSizes: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ locate the renderer corresponding to the pMediaType type
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pEnum: IEnumFilters;
   pFilter: IBaseFilter;
   pPin: IPin;
   ulFetched, ulInPins, ulOutPins: ULONG;
   bFound: Boolean;
   mt: TAM_MEDIA_TYPE;
   Dummy1: dword;
   Dummy2: Int64;
begin
   Result := false;
   bFound := false;
   try
      if not assigned (F_GraphBuilder) then Exit;
      if not assigned (pMediaType) then Exit;

      if F_GraphBuilder.EnumFilters(pEnum) <> S_OK then Exit;
      pEnum.Reset;

      while(not bFound) and (pEnum.Next(1, pFilter, @ulFetched) = S_OK) do begin
         CountFilterPins(pFilter, ulInPins, ulOutPins);
         if (ulInPins = 1) and (ulOutPins = 0) then begin
            if GetPin (pFilter, PINDIR_INPUT, 0, pPin) then begin
               ZeroMemory (@mt, sizeof (TAM_MEDIA_TYPE));
               if pPin.ConnectionMediaType (@mt) = S_OK then begin
                  if _IsEqualGUID (@mt.majortype, pMediaType) then begin
                     if GetVideoSizes and (_IsEqualGUID (pMediaType, @MediaType_Video)) then begin
                        ReturnFormatValues (@mt, dummy1, dummy2, FVideoSourceWidth, FVideoSourceHeight);
                     end;
                     bFound := true;
                     ppFIlter := pFilter;
                     ppInputPin := pPin;
                     Result := true;
                  end;
                  FreeMediaType(@mt);
               end;
            end;
         end;
         if not bFound then begin
            pFilter := nil;
            pPin := nil;
         end;
      end;
   finally
      if assigned (pEnum) then pEnum := nil;
      if assigned (pFilter) then pFilter := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.GetCurrentSubtypeGUID (var SubtypeGUID: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := (FVideoRegSave[_VideoSubtype].i >= 0) and (FVideoRegSave[_VideoSubtype].i < FVideoSubtypes.Count);
   if Result then begin
      SubTypeGUID := Trim (FVideoSubtypes[FVideoRegSave[_VideoSubtype].i]);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function IsDVFourCC (FourCC: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   lFourCC: String;
begin
   lFourCC := lowercase (FourCC);
   Result := (lFourCC = 'dvsd') or (lFourCC = 'dvhd') or (lFourCC = 'dvsl')
          or (lFourCC = 'dv25') or (lFourCC = 'dv50') or (lFourCC = 'dvh1')
          or (lFourCC = 'dvsc');
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.AddSubtypeInList (List: TstringList; pmt: PAM_MEDIA_TYPE);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   s: string;
   FourCC: string;
begin
   s := GuidTostring (pmt^.Subtype);
   FourCC := LowerCase (ReturnFourCC (s));
   WriteLog (nil, sGrey, 'seen: ' + FourCC + ' -> ' + s);
   if FourCC <> '' then begin
      if IsDVFourCC (FourCC) then begin
         FVideoRegSave[_IsDigitalVideoIn].b := true;
      end;
      if List.IndexOf (s) = -1 then begin
         List.Add (s);
         LogB (true, LINFO, i_discovering_device, 'video format: ' + FourCC);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.AddFormatInList (List: TStringList; x, y: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   s: string;
   i: LongInt;
begin
      if x > 999 then begin
         s := IntToStr (x) + 'x' + IntToStr (y);
      end
      else if x < 100 then begin
         s := '  ' + IntToStr (x) + 'x' + IntToStr (y);
      end
      else begin
         s := ' ' + IntToStr (x) + 'x' + IntToStr (y);
      end;
      i := List.IndexOf (s);
      if i = -1 then begin
         if List.Count = 0 then begin
            List.Add ('   ' + s);
         end;
         List.Add (s);
         LogB (true, LINFO, i_discovering_device, 'video size: ' + s);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ScanFormatBound (AcceptedList, RejectedList: TstringList; DevPin: iPin; pmt: PAM_MEDIA_TYPE; MWidth, MHeight, Min_W, Min_H, Max_W, Max_H: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   MidWidth, MidHeight: LongInt;

   procedure ReinitMid (MW, MH: LongInt);
   begin
      MidWidth := MW;
      MidHeight := MH;
      if MidHeight > MidWidth then begin
         MidHeight := MidHeight shr 1;
      end;
   end;

begin
   ReinitMid (MWidth, MHeight);
   while MidWidth >= Min_W do begin
         AddFormatInList (AcceptedList, MidWidth, MidHeight);
         MidWidth:= MidWidth shr 1;
         MidHeight:= MidHeight shr 1;
   end;

   ReinitMid (MWidth, MHeight);
   while MidHeight >= Min_H do begin
         AddFormatInList (AcceptedList, MidWidth, MidHeight);
         MidWidth:= MidWidth shr 1;
         MidHeight:= MidHeight shr 1;
   end;

   ReinitMid (MWidth, MHeight);
   while MidWidth <= Max_W do begin
         AddFormatInList (AcceptedList, MidWidth, MidHeight);
         MidWidth:= MidWidth shl 1;
         MidHeight:= MidHeight shl 1;
   end;

   ReinitMid (MWidth, MHeight);
   while MidHeight <= Max_H do begin
         AddFormatInList (AcceptedList, MidWidth, MidHeight);
         MidWidth:= MidWidth shl 1;
         MidHeight:= MidHeight shl 1;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ScanFormatBounds (AcceptedList, RejectedList: TstringList; DevPin: IPin; pmt: PAM_MEDIA_TYPE; Mid_W, Mid_H, Min_W, Min_H, Max_W, Max_H: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   ScanFormatBound (AcceptedList, RejectedList, DevPin, pmt, Mid_W, Mid_H, Min_W, Min_H, Max_W, Max_H);
   ScanFormatBound (AcceptedList, RejectedList, DevPin, pmt, Min_W, Min_H, Min_W, Min_H, Max_W, Max_H);
   ScanFormatBound (AcceptedList, RejectedList, DevPin, pmt, Max_W, Max_H, Min_W, Min_H, Max_W, Max_H);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure ReadVideoSizes (FVideoSizes: TStringList; RegKey: TRegistry2);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: Integer;
   Done: Boolean;
   Value: String;
begin
      { read Formats }
      FVideoSizes.Clear;
      i := 0;
      Done := false;
      while not Done do begin
         if RegKey.Readstring (Format ('FMT%.3u',[i]), Value) then begin
            if Value <> '' then begin
               FVideoSizes.Add (Value);
            end;
            inc (i);
         end
         else begin
            Done := true;
         end;
      end;

end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.LoadSettingsAndVideoStreamConfigCapabilitiesFromRegistry: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
   Done: Boolean;
   Value: string;
   RegKey: TRegistry2;
begin
   Result := False;

   if not IsLiveVideoSource then Exit;
   if FCurrent.VideoDevice = -1 then Exit;

   RegKey := TRegistry2.Create (False);
   if RegKey.OpenKey (DeviceRegKeyId (_VideoDevices, FCurrent.VideoDevice), true) then begin

      ReadVideoSizes (FVideoSizes, RegKey);

      { read Subtypes }
      FVideoSubtypes.Clear;
      i := 0;
      Done := false;
      while not Done do begin
         if RegKey.Readstring (Format ('SUB%.3u',[i]), Value) then begin
            if Value <> '' then begin
               FVideoSubtypes.Add (Value);
            end;
            inc (i);
         end
         else begin
            Done := true;
         end;
      end;

      Result := (FVideoSizes.Count > 0) and (FVideoSubtypes.Count > 0);
      if not Result then begin
         WriteLog (nil, sRed, 'ERROR when loading from registry: Formats or Subtypes empty');
      end;
   end;
   RegKey.Free;
 end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.AddDefaultFormats;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   iPref: LongInt;
   x, y: LongInt;
begin

         GoTop (FVideoSubtypes, GuidToString (MEDIASUBTYPE_Y422));
         GoTop (FVideoSubtypes, GuidToString (MEDIASUBTYPE_RGB565));
         GoTop (FVideoSubtypes, GuidToString (MEDIASUBTYPE_I420));
         GoTop (FVideoSubtypes, GuidToString (MEDIASUBTYPE_RGB32));
         GoTop (FVideoSubtypes, GuidToString (MEDIASUBTYPE_RGB24));
         GoTop (FVideoSubtypes, GuidToString (MEDIASUBTYPE_YUY2));
         GoTop (FVideoSubtypes, GuidToString (MEDIASUBTYPE_UYVY));
         GoTop (FVideoSubtypes, GuidToString (MEDIASUBTYPE_RGB555));

         if FVideoSubtypes.Count > 0 then begin
            FVideoSubtypes.Insert (0, FVideoSubtypes[0]);
         end;

         if IsDVSource then begin
            FVideoSizes.Clear;
            FVideoSizes.Add ('    half');
            FVideoSizes.Add ('   dc');
            FVideoSizes.Add ('  quarter');
            FVideoSizes.Add (' half');
            FVideoSizes.Add ('full');

//            FVideoSubtypes.Add (GuidToString (MEDIASUBTYPE_YUY2));
         end
         else begin
            if FVideoRegSave[_IsVfw].b then begin
               if FVideoSizes.Count > 1 then begin
                  iPref := FVideoSizes.IndexOf (' 352x288');
                  if iPref = -1 then begin
                     iPref := FVideoSizes.IndexOf (' 320x240');
                  end;
                  if iPref > 1 then begin
                     FVideoSizes.Add ('   ' + Trim (FVideoSizes[iPref]));
                  end;
               end;
            end
            else begin
               if FVideoSizes.Count > 0 then begin
                  if DecodeVideoSize (0, x, y) then begin
                     if (x > 400) or (y > 400) then begin
                        iPref := FVideoSizes.IndexOf (' 352x288');
                        if iPref = -1 then begin
                          iPref := FVideoSizes.IndexOf (' 320x240');
                        end;
                        if iPref > 1 then begin
                           FVideoSizes.Delete (0);
                           FVideoSizes.Add ('   ' + Trim (FVideoSizes[iPref - 1]));
                        end;
                     end;
                  end;
               end;
            end;
         end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure Tvdgr.AddSubtypesFromPin (var Pin: IPin);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   EnumMediaTypes: IEnumMediaTypes;
   pmt: PAM_MEDIA_TYPE;
begin
   if not assigned (Pin) then Exit;
   if Pin.EnumMediaTypes (EnumMediaTypes) = S_OK then begin
      if assigned (EnumMediaTypes) then begin
         ENumMediaTypes.Reset;
         while EnumMediaTypes.Next (1, pmt, nil) = S_OK do begin
            AddSubtypeInList (FVideoSubtypes, pmt);
            DeleteMediaType (pmt);
         end;
         EnumMediaTYpes := nil;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.WDM_DiscoverVideoFormats (var Pin: IPin);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   EnumMediaTypes: IEnumMediaTypes;
   pmt: PAM_MEDIA_TYPE;
   DummyMt: TAM_MEDIA_TYPE;
   piCount, piSize: LongInt;
   i: LongInt;
   Caps: TVideo_Stream_Config_Caps;
   CapAvail: Boolean;
   RejectedList: TstringList;
   dwBitRate: dword;
   biWidth, biHeight: LongInt;
   AvgTimePerFrame: int64;
begin

      if not assigned (F_AMVideoStreamConfig) then Exit;

      CapAvail := false;
      RejectedList := TstringList.Create;
      RejectedList.Duplicates := dupIgnore;

      if assigned (Pin) then begin
         WriteLog (nil, sGrey, 'searching number of capabilities');
         if F_AMVideoStreamConfig.GetNumberOfCapabilities (piCount, piSize) = S_OK then begin
            if piCount > 0 then begin
               CapAvail := true;
               WriteLog (nil, sGrey, 'number of capabilities ok');
            end
            else begin
               WriteLog (nil, sGrey, 'number of capabilities = 0');
            end;
         end
         else begin
            WriteLog (nil, sGrey, 'searching number of capabilities: no AMVideoStreamConfig');
         end;

         if CapAvail then begin
            WriteLog (nil, sGrey, 'CapAvail: looping capabilities ' + InttoStr (PiCount));
            for i := 0 to PiCount - 1 do begin
               pmt := @DummyMt;
               if F_AMVideoStreamConfig.GetStreamCaps (i, pmt, @Caps) = S_OK then begin
                  AddSubtypeInList (FVideoSubtypes, pmt);
                  if ReturnFormatValues (pmt, dwBitRate, AvgTimePerFrame, biWidth, biHeight) then begin
                        ScanFormatBounds (FVideoSizes,
                                    RejectedList,
                                    Pin,
                                    pmt,
                                    biWidth,
                                    biHeight,
                                    Caps.minoutputsize.cx,
                                    Caps.minoutputsize.cy,
                                    Caps.maxoutputsize.cx,
                                    Caps.maxoutputsize.cy);
                  end;
                  DeleteMediaType (pmt);
               end;
            end;
         end
         else begin
            WriteLog (nil, sGrey, 'No CapAvail: enumerating media types');
            if Pin.EnumMediaTypes (EnumMediaTypes) = S_OK then begin
               if assigned (EnumMediaTypes) then begin
                  ENumMediaTypes.Reset;
                  while EnumMediaTypes.Next (1, pmt, nil) = S_OK do begin

                     if ReturnFormatValues (pmt, dwBitRate, AvgTimePerFrame, biWidth, biHeight) then begin
                        AddSubtypeInList (FVideoSubtypes, pmt);
                        ScanFormatBounds (FVideoSizes,
                                    RejectedList,
                                    Pin,
                                    pmt,
                                    biWidth,
                                    biHeight,
                                    80,
                                    60,
                                    2048,
                                    1536);
                     end;
                     DeleteMediaType (pmt);
                  end;
                  EnumMediaTYpes := nil;
               end;
            end;
         end;

         if FVideoRegSave[_IsAnalogVideoDecoderAvail].b then begin
            AddFormatInList (FVideoSizes, 176, 144);
            AddFormatInList (FVideoSizes, 320, 240);
            AddFormatInList (FVideoSizes, 352, 240);
            AddFormatInList (FVideoSizes, 352, 288);
            AddFormatInList (FVideoSizes, 480, 288);
            AddFormatInList (FVideoSizes, 480, 480);
            AddFormatInList (FVideoSizes, 640, 480);
            AddFormatInList (FVideoSizes, 704, 480);
            AddFormatInList (FVideoSizes, 704, 574);
            AddFormatInList (FVideoSizes, 720, 480);
            AddFormatInList (FVideoSizes, 720, 576);
         end;

         AddDefaultFormats;

      end
      else begin
         WriteLog (nil, sRed, 'ERROR: NO OUPTUT PIN FOUND IN FORMAT DISCOVERING');
      end;
      WriteLog ('-', sPurple, 'END Discovering formats for ' + _VideoDevices.FDevices[FCurrent.VideoDevice]);
      RejectedList.Free;


end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.VFW_DiscoverVideoFormats (var Pin: IPin);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pmt: PAM_MEDIA_TYPE;
   DummyMt: TAM_MEDIA_TYPE;
   Hr: HResult;
   s: string;
   SaveX, SaveY: LongInt;

   procedure TestSize (x, y: LongInt);
   begin
      pVideoInfoHeader (pmt.pbFormat)^.bmiHeader.biWidth := x;
      pVideoInfoHeader (pmt.pbFormat)^.bmiHeader.biHeight := y;
      pVideoInfoHeader (pmt.pbFormat)^.bmiHeader.biSizeImage := BitmapSize (@pVideoInfoHeader (pmt.pbFormat)^.bmiHeader);
      //if Pin.QueryAccept (pmt) = S_OK then begin
      if F_AMVideoStreamConfig.SetFormat(pmt) = S_OK then begin
         if x > 999 then begin
            s := IntToStr (x) + 'x' + IntToStr (y);
         end
         else if x < 100 then begin
            s := '  ' + IntToStr (x) + 'x' + IntToStr (y);
         end
         else begin
            s := ' ' + IntToStr (x) + 'x' + IntToStr (y);
         end;
         if FVideoSizes.IndexOf (s) = -1 then begin
            FVideoSizes.Add (s);
            LogB (true, LINFO, i_discovering_device, 'video size: ' + s);
         end;
      end;
   end;

   procedure TestFormat (FourCC: string);
   begin
      VFWSubtypeValues (FourCC, pVideoInfoHeader (pmt.pbFormat)^.bmiheader.biCompression, pVideoInfoHeader (pmt.pbFormat)^.bmiheader.biBitCount);
      pVideoInfoHeader (pmt.pbFormat)^.bmiheader.biSizeImage := BitmapSize (@pVideoInfoHeader (pmt.pbFormat)^.bmiheader);
       //if Pin.QueryAccept (pmt) = S_OK then begin
      if F_AMVideoStreamConfig.SetFormat(pmt) = S_OK then begin
         if FVideoSubtypes.IndexOf (FourCC) = -1 then begin
            FVideoSubtypes.Add (FourCC);
            LogB (true, LINFO, i_discovering_device, 'video format: ' + FourCC);
         end;
      end;
   end;
begin
      if not assigned (Pin) then Exit;

      WriteLog ('-', sPurple, 'BEGIN Discovering vfw formats for ' + _VideoDevices.FDevices[FCurrent.VideoDevice]);
      FVideoSizes.Clear;
      FVideoSubtypes.Clear;

      pmt := @DummyMt;
      hr:= F_AMVideoStreamConfig.GetFormat(pmt);
      if LogH (Hr, LERROR, e_get_video_format, 'get Video format') then begin

         SaveX := pVideoInfoHeader (pmt.pbFormat)^.bmiHeader.biWidth;
         SaveY := abs(pVideoInfoHeader (pmt.pbFormat)^.bmiHeader.biHeight);

         TestSize (96, 72);
         TestSize (120, 90);
         TestSize (128, 96);
         TestSize (160, 120);
         TestSize (192, 144);
         TestSize (240, 180);
         TestSize (256, 192);
         TestSize (320, 240);
         TestSize (352, 288);
         TestSize (384, 288);
         TestSize (640, 480);
         TestSize (720, 576);
         TestSize (768, 576);

         pVideoInfoHeader (pmt.pbFormat)^.bmiHeader.biWidth := SaveX;
         pVideoInfoHeader (pmt.pbFormat)^.bmiHeader.biHeight := SaveY;

         TestFormat ('RLE4');
         TestFormat ('RLE8');
         TestFormat ('RGB4');
         TestFormat ('RGB8');
         TestFormat ('BITF16');
         TestFormat ('BITF24');
         TestFormat ('BITF32');
         TestFormat ('UYVY');
         TestFormat ('YUY2');
         TestFormat ('YUV9');
         TestFormat ('I420'); { YV12 }
         TestFormat ('IYUV');
         TestFormat ('YV12');
         TestFormat ('RGB555');
         TestFormat ('RGB565');
         TestFormat ('RGB24');
         TestFormat ('RGB32');

         DeleteMediaType(pmt);

         AddDefaultFormats;
      end
      else begin
         WriteLog (nil, sRed, 'ERROR: NO OUPTUT PIN FOUND IN FORMAT DISCOVERING');
      end;
      WriteLog ('-', sPurple, 'END Discovering formats for ' + _VideoDevices.FDevices[FCurrent.VideoDevice]);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ReturnCrossbarInput: LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   InputPin: LongInt;
begin
      Result := 0;
      if not assigned (F_AMVideoCrossbar) then Exit;
      if F_AMVideoCrossbar.get_IsRoutedTo (0, InputPin) = S_OK then begin
         Result := InputPin;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ReturnCrossbarInputs: string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   OutputPInBound, InputPInBound: LongInt;
   PhysicalType: LongInt;
   i: LongInt;
   DummyRelated: LongInt;
   List: TstringList;
   PinName: string;
   CurrentCount: LongInt;
   iList: LongInt;
   Done, Found: Boolean;

   function CountAlreadyInList (id: LongInt): LongInt;
   var
      cpt: LongInt;
      j: LongInt;
   begin
      cpt := 0;
      for j := 0 to List.Count - 1 do begin
         if List.Objects[j] = pointer (id) then begin
            inc (cpt);
         end;
      end;
      Result := cpt;
   end;

begin
      Result := '';
      Found := false;
      if not assigned (F_AMVideoCrossbar) then Exit;
      if F_AMVideoCrossbar.Get_PinCounts (OutputPInBound, InputPInBound) = S_OK then begin

         { search if any video out pin }
         Done := false;
         i := 0;
         while not Done do begin
            if i < OutputPInBound then begin
               if F_AMVideoCrossbar.get_CrossbarPinInfo (false, i, DummyRelated, PhysicalType) = S_OK then begin
                  if PhysicalType < PhysConn_Audio_Tuner then begin
                     Found := true;
                     Done := true;
                  end;
               end
            end;
            if not Found then begin
               inc (i);
               if i > OutputPInBound then begin
                  Done := true;
               end;
            end;
         end;
      end;

      if Found then begin
         if OutputPInBound > 0 then begin
            List := TstringList.Create;
            for i := 0 to InputPInBound - 1 do begin
               if F_AMVideoCrossbar.get_CrossbarPinInfo (true, i, DummyRelated, PhysicalType) = S_OK then begin
                  if PhysicalType < PhysConn_Audio_Tuner then begin
                     PinName := GetCrossbarstring (PhysicalType);
                     CurrentCount := CountAlreadyInList (PhysicalType);
                     if CurrentCount = 0 then begin
                        iList := List.Add (PinName);
                     end
                     else begin
                        iList := List.Add (PinName + ' ' + inttostr (CurrentCount));
                     end;
                     List.Objects[iList] := pointer (PhysicalType);
                  end;
               end;
            end;
            Result := List.Text;
            List.Free;
         end;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure CleanFormatList (List: TStringList; CoeffToDelete: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Done: Boolean;
   i: LongInt;
   x, y: LongInt;
   Delta: LongInt;
   MinBound: LongInt;
   MaxBound: LongInt;
   CurrentCoeff: LongInt;
   FirstLine: String;
begin
   Delta := Round ((CoeffToDelete * 5 / 100));
   MinBound := CoeffToDelete - Delta;
   MaxBound := CoeffToDelete + Delta;
   Done := False;
   i := 0;
   while not Done do begin
      if i >= List.Count then begin
         Done := True;
      end
      else begin
         if ExtractVideoSizeFromFormatCoded (List[i], x, y) then begin
            CurrentCoeff := Round ((x / y * 100));
            if (CurrentCoeff > MinBound) and (CurrentCoeff < MaxBound) then begin
                List.Delete (i);
            end
            else begin
               inc (i);
            end;
         end
         else begin
            inc (i);
         end;
      end;
   end;
   if List.Count > 0 then begin
      FirstLine := List[0];
      if Length(FirstLine) >= 2 then begin
         if FirstLine[2] <> ' ' then begin // the default size has been deleted
            List.Add (' ' + FirstLine); // sorted
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.DiscoverVideoDevice: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   DummyAvgTimePerFrame: LongInt;
   RegKey: TRegistry2;
   i: LongInt;
   CurrentTVFormat: LongInt;
   DummyAudio: IPin;
   AMVfwCaptureDialogs: IAMVfwCaptureDialogs;
begin
   LogB (true, LINFO, i_begin_discovering_device, 'one-time video device discovery:' + #13#10 + _VideoDevices.FDevices[FCurrent.VideoDevice] + #13#10 + 'please wait...');
   Result := false;
   FDiscovering := True;
   try

      FVideoRegSave[_VideoInput].i := 0;
      FVideoRegSave[_VideoInputs].s := '';
      FVideoSizes.Clear;
      FVideoSubtypes.Clear;
      FVideoRegSave[_ANVTVFormats].i := 0;

      ClearGraph (True);

      CurrentTVFormat := -1;

      ReinitCurrentParams (False);

      if not CreateBaseGraph then Exit;

      ReadStoredInterfaceValues;

      RetrieveDVSignalType (DummyAvgTimePerFrame);

      if F_CaptureGraphBuilder2.FindInterface(FVideoPinCategoryUsed, nil, F_VideoDevice, IAMVfwCaptureDialogs, AMVfwCaptureDialogs) = S_OK then begin
         FVideoRegSave[_VfwCaptureDialogFormat].b := AMVfwCaptureDialogs.HasDialog (VfwCaptureDialog_Format) = S_OK;
         FVideoRegSave[_VfwCaptureDialogSource].b := AMVfwCaptureDialogs.HasDialog (VfwCaptureDialog_Source) = S_OK;
         FVideoRegSave[_VfwCaptureDialogDisplay].b := AMVfwCaptureDialogs.HasDialog (VfwCaptureDialog_Display) = S_OK;
      end
      else begin
         FVideoRegSave[_VfwCaptureDialogFormat].b := false;
         FVideoRegSave[_VfwCaptureDialogSource].b := false;
         FVideoRegSave[_VfwCaptureDialogDisplay].b := false;
      end;

      if FVideoRegSave[_ANVTVFormats].i = 0 then begin
         if assigned (F_AMAnalogVideoDecoder) then begin
             F_AMAnalogVideoDecoder.get_AvailableTVFormats(FVideoRegSave[_ANVTVFormats].i);
             F_AMAnalogVideoDecoder.Get_TVFormat (CurrentTVFormat);
         end
         else if assigned (F_AMTVTuner) then begin
            F_AMTVTuner.get_AvailableTVFormats (FVideoRegSave[_ANVTVFormats].i);
            F_AMTVTuner.Get_TVFormat (CurrentTVFormat);
         end;
      end;

      FVideoSizes.Clear;
      FVideoSubtypes.Clear;

      if isMPEGSource then begin
           FVideoSubtypes.Add (' ' + GuidToString (MEDIASUBTYPE_MPEG2_VIDEO));
            FVideoSubtypes.Add (GuidToString (MEDIASUBTYPE_MPEG2_VIDEO));
            FVideoSizes.Clear;
            FVideoSizes.Add (' 360x240');
            FVideoSizes.Add (' 320x240');
            FVideoSizes.Add (' 352x240');
            FVideoSizes.Add (' 352x288');
            FVideoSizes.Add (' 360x240');
            FVideoSizes.Add (' 640x480');
            FVideoSizes.Add (' 704x480');
            FVideoSizes.Add (' 720x480');
            FVideoSizes.Add (' 720x576');
      end
      else begin
         if FVideoRegSave[_IsVfw].b then begin
            VFW_DiscoverVideoFormats (F_VideoDeviceSelectedPin);
         end
         else begin
            WDM_DiscoverVideoFormats (F_VideoDeviceSelectedPin);
            if IsDVSource then begin
               if InsertFilterInline (@CLSID_DVVideoCodec, SingleText ('DV Codec'), @MEDIATYPE_Video, F_VideoDeviceSelectedPin) then begin
                  AddSubtypesFromPin (F_VideoDeviceSelectedPin);
               end;
            end;
         end;
      end;

      RegKey := TRegistry2.Create (False);

      if RegKey.OpenKey (DeviceRegKeyId (_VideoDevices, FCurrent.VideoDevice), true) then begin
         for i := 0 to FVideoSizes.Count - 1 do begin
             RegKey.WriteString (Format ('FMT%.3u',[i]), FVideoSizes[i]);
         end;
         for i := 0 to FVideoSubtypes.Count - 1 do begin
             RegKey.WriteString (Format ('SUB%.3u',[i]), FVideoSubtypes[i]);
         end;
      end;
      RegKey.Free;

      if CurrentTVFormat <> -1 then begin { restore the previous value, if any }
         FVideoRegSave[_ANVTVFormat].i := CurrentTVFormat;
         if assigned (F_AMAnalogVideoDecoder) then begin
             F_AMAnalogVideoDecoder.Put_TVFormat (CurrentTVFormat);
         end;
      end;

      WriteLogBool (IsDVSource, sBlue, 'Digital video in');

      Result := true;
      WriteLog ('~', sPurple, 'END Discovering ' + _VideoDevices.FDevices[FCurrent.VideoDevice]);
    finally
       if assigned (AMVfwCaptureDialogs) then AMVfwCaptureDialogs:= nil;
       if assigned (Dummyaudio) then DummyAudio:= nil;
       ClearGraph (True);
       LogB (true, LINFO, i_end_discovering_device, 'end of device discovery');
       FDiscovering := False;
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.DiscoverAudioDevice: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   PinTest: IPin;
   AudioCrossbarBaseFilter: IBaseFilter;
   BDummy: pBoolean;
begin
  WriteLog ('~', sPurple, 'BEGIN Discovering ' + _AudioDevices.FDevices[FCurrent.AudioDevice]);
  LogB (true, LINFO, i_begin_discovering_device, 'one-time audio device discovery:' + #13#10 + _AudioDevices.FDevices[FCurrent.AudioDevice] + #13#10 + 'please wait...');
  Result := false;
    try
      ClearGraph (True);

      if InitializationStatus <> ipInitialized then Exit;

      ReinitCurrentParams (False);

      if not CreateFilterGraph then Exit;

      if not BindAndAddDevice (F_FilterGraph2, _AudioDevices, FCurrent.AudioDevice, '', F_AudioDevice, False, BDummy, False, '') then Exit;

      FAudioRegSave[_AIsSoundCard].b := AudioInputsCount >= 5;

      FAudioRegSave[_AIsAudioCrossbarAvail].b := F_CaptureGraphBuilder2.FindInterface(@PIN_CATEGORY_CAPTURE, nil, F_AudioDevice, IAMCrossbar, F_AMAudioCrossbar) = S_OK;
      WriteLogBool (FAudioRegSave[_AIsAudioCrossbarAvail].b, sBlue, 'audio crossbar available on audio device');

      FAudioRegSave[_AudioInputs].s := GetPinNames (PINDIR_INPUT, F_AudioDevice);

      FAudioRegSave[_AudioInput].i := 0;
      WriteLog ('Audio pin list', sGrey, FAudioRegSave[_AudioInputs].s);

      Result := true;
      WriteLog ('~', sPurple, 'END Discovering ' + _AudioDevices.FDevices[FCurrent.AudioDevice]);
    finally
       if assigned (PinTest) then PinTest := nil;
       if assigned (AudioCrossbarBaseFilter) then AudioCrossbarBaseFilter := nil;
       LogB (true, LINFO, i_end_discovering_device, 'end of device discovery');
       ClearGraph (True);
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.VideoStreamConfigGetRealFrameRate;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video frame rate of the capture filter
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   AvgTimePerFrame: LongInt;
begin
   if not assigned (F_AMVideoStreamConfig) then Exit;

   FRealFrameRate := 0;
   if RetrieveDVSignalType (AvgTimePerFrame) then begin
      FRealFrameRate := Round (1000000000 / AvgTimePerframe);
   end
   else begin
      VideoStreamConfigGetFrameRate (FRealFrameRate);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.VideoStreamConfigGetFrameRate (var FrameRateFound: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video frame rate of the capture filter
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
   pmt: PAM_MEDIA_TYPE;
begin
   Result := False;

   if not assigned (F_AMVideoStreamConfig) then Exit;

   hr:= F_AMVideoStreamConfig.GetFormat(pmt);
   if not LogH (Hr, LERROR, e_get_video_format, 'get Video format') then Exit;

   Result := True;
   case ReturnFormatType (pmt) of
      ft_VideoInfo: FrameRateFound := Round (1000000000 / pVideoInfoHeader(pmt^.pbFormat)^.AvgTimePerFrame);
      ft_VideoInfo2: FrameRateFound := Round (1000000000 / pVideoInfoHeader2(pmt^.pbFormat)^.AvgTimePerFrame);
      ft_Mpeg1Video: FrameRateFound := Round (1000000000 / pMpeg1VideoInfo(pmt^.pbFormat)^.hdr.AvgTimePerFrame);
      ft_Mpeg2Video: FrameRateFound := Round (1000000000 / pMpeg2VideoInfo(pmt^.pbFormat)^.hdr.AvgTimePerFrame);
   else
      Result := False;
   end;
   DeleteMediaType(pmt);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.VideoStreamConfigGetFormat;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video size of the capture filter
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
   pmt: PAM_MEDIA_TYPE;
   x, y, xList, yList: LongInt;
   Subtypestring: string;
   i: LongInt;
   Done: Boolean;
   Dummy1: dword;
   Dummy2: int64;
begin
      if not assigned (F_AMVideoStreamConfig) then Exit;
      x := 0;
      y := 0;
      Subtypestring := '';
      hr:= F_AMVideoStreamConfig.GetFormat(pmt);
      if LogH (Hr, LERROR, e_get_video_format, 'get Video format') then begin

         if ReturnFormatValues (pmt, dummy1, dummy2, x, y) then begin
            Subtypestring := GUIDTostring (pmt^.Subtype);
         end;
         if (Subtypestring <> '') and (x <> 0) and (y <> 0) then begin
            i := FVideoSubtypes.IndexOf (Subtypestring);
            if i <> -1 then begin
               FVideoRegSave[_VideoSubtype].i := i;
            end;

            i := 0;
            Done := false;
            while not Done do begin
               if i >= FVideoSizes.Count then begin
                  Done := true;
               end
               else begin
                  if DecodeVideoSize (i, xList, yList) then begin
                     if (xList = x) and (yList = y) then begin
                        Done := true;
                        FVideoRegSave[_VideoSize].i := i;
                     end;
                  end;
                  inc (i);
               end;
            end;
         end;
         DeleteMediaType(pmt);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
type
   pListInfo = ^TListInfo;
   TListInfo = record
      FormatEval: LongInt;
      FormatIndex: LongInt;
      DifRatio: Double;
      Width: LongInt;
   end;

function SearchNearestVideoSizeSortSize (Item1, Item2: Pointer): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if pListInfo(Item1)^.FormatEval = pListInfo(Item2)^.FormatEval then begin
      Result := 0;
   end
   else
   if pListInfo(Item1)^.FormatEval > pListInfo(Item2)^.FormatEval then begin
      Result := 1;
   end
   else begin
      Result := -1;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.SearchNearestVideoSize (RequestedW, RequestedH: LongInt): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TList;
   ListInfo: pListInfo;
   i: LongInt;
   xFormat, yFormat: LongInt;
   xDif, yDif: LongInt;
begin
   Result := FVideoRegSave[_VideoSize].i;
   if FVideoSizes.Count < 2 then Exit; { do not use the default format }

   List := TList.Create;

   for i := 1 to FVideoSizes.Count - 1 do begin
      if DecodeVideoSize (i, xFormat, yFormat) then begin
         New (ListInfo);
         xDif := abs (xFormat - RequestedW);
         yDif := abs (yFormat - RequestedH);
         ListInfo.FormatIndex := i;
         ListInfo.FormatEval := (xDif * xDif) + (yDif * yDif);
         List.Add (ListInfo);
      end;
   end;

   List.Sort (SearchNearestVideoSizeSortSize);

   Result := pListInfo(List[0])^.FormatIndex;

   while List.Count > 0 do begin
      Dispose (List[0]);
      List.Delete (0);
   end;
   List.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function SearchNearestVideoSizeUsingRatioSortSize (Item1, Item2: Pointer): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if pListInfo(Item1)^.FormatEval = pListInfo(Item2)^.FormatEval then begin
      Result := 0;
   end
   else
   if pListInfo(Item1)^.FormatEval > pListInfo(Item2)^.FormatEval then begin
      Result := 1;
   end
   else begin
      Result := -1;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function SearchNearestVideoSizeUsingRatioSortRatio (Item1, Item2: Pointer): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if pListInfo(Item1)^.DifRatio = pListInfo(Item2)^.DifRatio then begin
      Result := 0;
   end
   else
   if pListInfo(Item1)^.DifRatio > pListInfo(Item2)^.DifRatio then begin
      Result := 1;
   end
   else begin
      Result := -1;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.SearchNearestVideoSizeUsingRatio (RequestedW, RequestedH: LongInt): LongInt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TList;
   ListInfo: pListInfo;
   i: LongInt;
   xFormat, yFormat: LongInt;
   xDif, yDif: LongInt;
   Done: Boolean;
   PrefMore20, PrefLess20: LongInt;
   NotFound: Boolean;
begin
   Result := FVideoRegSave[_VideoSize].i;
   if FVideoSizes.Count < 2 then Exit; { do not use the default format }

   List := TList.Create;

   PrefMore20 := RequestedW + Round (RequestedW * 20 / 100);
   PrefLess20 := RequestedW - Round (RequestedW * 20 / 100);

   for i := 1 to FVideoSizes.Count - 1 do begin
      if DecodeVideoSize (i, xFormat, yFormat) then begin
         new (ListInfo);
         xDif := abs (xFormat - RequestedW);
         yDif := abs (yFormat - RequestedH);
         ListInfo.FormatIndex := i;
         ListInfo.FormatEval := (xDif * xDif) + (yDif * yDif);
         ListInfo.DifRatio := abs ((RequestedW / RequestedH) - (xFormat / yFormat));
         ListInfo.Width := xFormat;
         List.Add (ListInfo);
      end;
   end;

   List.Sort (SearchNearestVideoSizeUsingRatioSortSize);

   NotFound := False;

   { remove if <20% or > 20% }
   Done := False;
   i := 0;
   while not Done do begin
      if List.Count < 2 then begin
         Done := True;
         NotFound := True;
      end
      else if i >= List.Count then begin
         Done := True;
      end
      else begin
         if (pListInfo(List[i])^.Width > PrefMore20) or (pListInfo(List[i])^.Width < PrefLess20) then begin
            Dispose (List[i]);
            List.Delete(i);
         end
         else begin
            inc (i);
         end;
      end;
   end;

   if NotFound then begin
      Result := SearchNearestVideoSize (RequestedW, RequestedH);
   end
   else begin
      List.Sort (SearchNearestVideoSizeUsingRatioSortRatio);
      Result := pListInfo(List[0])^.FormatIndex;
   end;

   while List.Count > 0 do begin
      Dispose (List[0]);
      List.Delete (0);
   end;
   List.Free;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.WDM_SetFormatFromStreamCaps (var Pin: IPin; var AMStreamConfig: IAMStreamConfig; SearchedSubtype: pGUID; SearchedWidth, SearchedHeight: LongInt): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pmt: PAM_MEDIA_TYPE;
   DummyMt: TAM_MEDIA_TYPE;
   piCount, piSize: LongInt;
   i: LongInt;
   Caps: TVideo_Stream_Config_Caps;
   CapAvail: Boolean;
   dwBitRate: dword;
   biWidth, biHeight: LongInt;
   AvgTimePerFrame: int64;
   Done: Boolean;
   Hr: HResult;
   FormatType: TFormatType;
   FrameRateSet: Boolean;
begin
      Result := False;
      if not assigned (AMStreamConfig) then Exit;

      if assigned (Pin) then begin

         CapAvail := False;

         WriteLog (nil, sGrey, 'searching number of capabilities');
         if AMStreamConfig.GetNumberOfCapabilities (piCount, piSize) = S_OK then begin
            if piCount > 0 then begin
               CapAvail := true;
               WriteLog (nil, sGrey, 'number of capabilities ok');
            end
            else begin
               WriteLog (nil, sGrey, 'number of capabilities = 0');
            end;
         end
         else begin
            WriteLog (nil, sGrey, 'searching number of capabilities: no AMVideoStreamConfig');
         end;

         if CapAvail then begin
            WriteLog (nil, sGrey, 'CapAvail: looping capabilities ' + InttoStr (PiCount));
            Done := False;
            i := 0;
            while not Done do begin
               if i >= PiCount then begin
                  Done := True;
               end
               else begin
                  pmt := @DummyMt;
                  if AMStreamConfig.GetStreamCaps (i, pmt, @Caps) = S_OK then begin
                     if ReturnFormatValues (pmt, dwBitRate, AvgTimePerFrame, biWidth, biHeight) then begin
                        if IsEqualGUID (pmt^.Subtype, SearchedSubtype^) then begin
                           if (biWidth = SearchedWidth) and (biHeight = SearchedHeight) then begin

                              FormatType := ReturnFormatType (pmt);

                              FrameRateSet := VideoStreamConfigSetPmtFrameRate (FormatType, pmt);
                              LogB (not FrameRateSet, LTRACE, e_set_format, 'failed to set frame rate');

                              Hr := AMStreamConfig.SetFormat (pmt);

                              LogH (Hr, LTRACE, e_set_format, 'failed to set video format');
                              if Succeeded (Hr) then begin
                                 if not (IsEqualGUID (pmt^.formattype, Format_VideoInfo) or IsEqualGUID (pmt^.formattype, Format_DvInfo)) then begin
                                    FVideoRegSave[_IsMpegStream].b := True;
                                 end;

                                 Done := True;
                                 Result := True;
                              end;
                           end;
                        end;
                     end;
                     DeleteMediaType (pmt);
                  end;
                  inc (i);
               end;
            end;
            if not Result then begin // let's try to set a frame rate
               if AMStreamConfig.GetStreamCaps (0, pmt, @Caps) = S_OK then begin
                  FormatType := ReturnFormatType (pmt);
                  FrameRateSet := VideoStreamConfigSetPmtFrameRate (FormatType, pmt);
                  LogB (not FrameRateSet, LTRACE, e_set_format, 'failed to set frame rate');
                  DeleteMediaType (pmt);
               end;
            end;
         end;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.DecodeVideoSubtype (var Subtype: TGUID): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   List: TStringList;
   Done: Boolean;
   i: LongInt;
   Line: String;
begin
   Result := False;

   if FVideoSubtypes.Count = 0 then Exit;

   if FCurrent.VideoSubtypeIndex >= FVideoSubtypes.Count then begin
      FCurrent.VideoSubtypeIndex := 0;
   end;

   if FCurrent.VideoSubtypeIndex = 0 then begin // default
      if FCurrent.FrameGrabber <> fg_Disabled then begin // we need a RGB format
         List := TStringList.Create;
         List.Text := Intf.GetVideoSubtypes;
         Done := False;
         i := 0;
         while not Done do begin
            if i >= List.Count then begin
               Done := True;
            end
            else begin
               Line := Trim (UpperCase (List[i]));
               if (pos ('RGB', line) > 0) and (Line <> 'RGB') then begin // 'RGB' fails on Plextor ConvertX
                  Subtype := StrToGuid (FVideoSubtypes[i]);
                  Result := True;
                  Done := True;
               end;
               inc (i);
            end;
         end;
         List.Free;
      end;
   end;
   if not Result then begin
      Subtype := StrToGuid (FVideoSubtypes[FCurrent.VideoSubtypeIndex]);
      Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.GetPMTFromSubtype_MustBeFreed (var Pin: IPin; RequiredFormatType: pGUID): PAM_MEDIA_TYPE;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video size of the capture filter }
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Subtype: TGUID;
   EnumMediaTypes: IEnumMediaTypes;
   pmt: PAM_MEDIA_TYPE;
   Done: Boolean;
begin
   Result := nil;
   if not assigned (Pin) then Exit;
   if DecodeVideoSubtype (Subtype) then begin
      if Pin.EnumMediaTypes (EnumMediaTypes) = S_OK then begin
         if assigned (EnumMediaTypes) then begin
            ENumMediaTypes.Reset;
            Done := False;
            while not Done do begin
               if EnumMediaTypes.Next (1, pmt, nil) <> S_OK then begin
                  Done := True;
               end
               else begin
                  if IsEqualGUID (pmt^.Subtype, Subtype) then begin
                     if not assigned (RequiredFormatType) then begin
                        Result := pmt;
                        Done := True;
                     end
                     else begin
                        if IsEqualGuid (pmt^.formattype, RequiredFormatType^) then begin
                           Result := pmt;
                           Done := True;
                        end;
                     end;
                  end
                  else begin
                     DeleteMediaType (pmt);
                  end;
               end;
            end;
            EnumMediaTYpes := nil;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function GetFirstMediaType  (var Pin: IPin): PAM_MEDIA_TYPE;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video size of the capture filter }
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   EnumMediaTypes: IEnumMediaTypes;
begin
   Result := nil;
   if not assigned (Pin) then Exit;
   if Pin.EnumMediaTypes (EnumMediaTypes) = S_OK then begin
      if assigned (EnumMediaTypes) then begin
         ENumMediaTypes.Reset;
         EnumMediaTypes.Next (1, Result, nil);
         EnumMediaTYpes := nil;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.VideoStreamConfigSetFormat (var Pin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video size of the capture filter }
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   x, y: LongInt;
   Subtype: TGUID;
begin
      Result := False;

      if FVideoRegSave[_IsVfw].b then Exit;

      WriteLog (nil, sBlue, 'video stream config 1');

      if FVideoSizes.Count = 0 then Exit; { oops! no formats? }

      if not assigned (F_AMVideoStreamConfig) then Exit;
      Result := False;
      try

         if FVideoRegSave[_VideoSize].i >= FVideoSizes.Count then begin
            FVideoRegSave[_VideoSize].i := 0;
            LogB (true, LERROR, e_index_out_of_range, 'VideoSize index out of range, default size used');
            Exit;
         end;

         if not DecodeVideoSizeUsingDefault (-1, x, y) then Exit;

         if DecodeVideoSubtype (Subtype) then begin
            Result := WDM_SetFormatFromStreamCaps (Pin, F_AMVideoStreamConfig, @Subtype, x, y);
         end;
      finally
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.VideoStreamConfigSetFormat2: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video size of the capture filter }
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
   CurrentMT: PAM_MEDIA_TYPE;
   FormatType: TFormatType;
   x, y: LongInt;
   Subtype: TGUID;
   pbmi: pBitmapInfoHeader;
   FourCC: string;
begin
      Result := False;

      if FVideoSizes.Count = 0 then Exit; { oops! no formats? }

      if not assigned (F_AMVideoStreamConfig) then Exit;

      WriteLog (nil, sBlue, 'video stream config 2');

      Result := False;
      CurrentMT := nil;
      try

         if FVideoRegSave[_VideoSize].i >= FVideoSizes.Count then begin
            FVideoRegSave[_VideoSize].i := 0;
            LogB (true, LERROR, e_index_out_of_range, 'VideoSize index out of range, default size used');
            Exit;
         end;

         if not DecodeVideoSizeUsingDefault (-1, x, y) then Exit;

         hr:= F_AMVideoStreamConfig.GetFormat(CurrentMT);

         if not LogH (Hr, LERROR, e_get_video_format, 'get Video format') then Exit;

         FormatType := ReturnFormatType (CurrentMT);
         if FormatType = ft_Unknown then Exit;

         if DecodeVideoSubtype (Subtype) then begin
            if not FVideoRegSave[_IsVfw].b then begin
               CopyGUID (@CurrentMT.Subtype, @Subtype);
            end;
            FourCC := FourCCToString (GuidToFourCC (Subtype));
         end
         else begin
            FourCC := '';
         end;

         VideoStreamConfigSetPmtFrameRate (FormatType, CurrentMT);

         pbmi := nil;

         case FormatType of
            ft_VideoInfo: begin
               SetRectEmpty (@pVideoInfoHeader (CurrentMT.pbFormat).rcSource);
               SetRectEmpty (@pVideoInfoHeader (CurrentMT.pbFormat).rcTarget);
               pbmi := @pVideoInfoHeader (CurrentMT.pbFormat).bmiHeader;
            end;
            ft_VideoInfo2: begin
               SetRectEmpty (@pVideoInfoHeader (CurrentMT.pbFormat).rcSource);
               SetRectEmpty (@pVideoInfoHeader (CurrentMT.pbFormat).rcTarget);
               pbmi := @pVideoInfoHeader (CurrentMT.pbFormat).bmiHeader;
            end;
            ft_Mpeg2Video: begin
               SetRectEmpty (@pMpeg2VideoInfo (CurrentMT.pbFormat).hdr.rcSource);
               SetRectEmpty (@pMpeg2VideoInfo (CurrentMT.pbFormat).hdr.rcTarget);
               pbmi := @pMpeg2VideoInfo (CurrentMT.pbFormat).hdr.bmiHeader;
            end;
            ft_Mpeg1Video: begin
               SetRectEmpty (@pMpeg1VideoInfo (CurrentMT.pbFormat).hdr.rcSource);
               SetRectEmpty (@pMpeg1VideoInfo (CurrentMT.pbFormat).hdr.rcTarget);
               pbmi := @pMpeg1VideoInfo (CurrentMT.pbFormat).hdr.bmiHeader;
            end;
            ft_DvInfo: begin
               CopyGUID (@CurrentMT.Subtype, @Subtype); { only the Subtype changed, CurrentMT used }
               Result := F_AMVideoStreamConfig.SetFormat(CurrentMT) = S_OK;
            end;
         end;

         if assigned (pbmi) then begin
            with pbmi^ do begin
               biWidth := x;
               biHeight := y;
               if FVideoRegSave[_IsVfw].b then begin { otherwise problems with some WDM devices }
                  biSize := sizeof(TBITMAPINFOHEADER);
                  biXPelsPerMeter := 0;
                  biYPelsPerMeter := 0;
                  VFWSubtypeValues (FourCC, biCompression, biBitCount);
                  biPlanes := 1;
                  biSizeImage := BitmapSize (pbmi);
               end;
               Result := F_AMVideoStreamConfig.SetFormat(CurrentMT) = S_OK;
            end;
         end
         else begin
            Result := True;
         end;

      finally
         if assigned (CurrentMT) then begin
              DeleteMediaType (CurrentMT);
         end;
         LogB (not Result, LTRACE, e_set_format, 'set video format 2');
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.VideoStreamConfigSetPmtFrameRate (FormatType: TFormatType; pmt: PAM_MEDIA_TYPE): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := True;
   if FCurrent.FrameRate <= 0 then begin
      FCurrent.FrameRate := 1500;
   end;
   case FormatType of
      ft_VideoInfo : pVideoInfoHeader(pmt^.pbFormat)^.AvgTimePerFrame := Round (1000000000 / FCurrent.FrameRate);
      ft_VideoInfo2: pVideoInfoHeader2(pmt^.pbFormat)^.AvgTimePerFrame := Round (1000000000 / FCurrent.FrameRate);
      ft_Mpeg2Video: pMpeg2VideoInfo(pmt^.pbFormat)^.hdr.AvgTimePerFrame := Round (1000000000 / FCurrent.FrameRate);
      ft_Mpeg1Video: pMpeg1VideoInfo(pmt^.pbFormat)^.hdr.AvgTimePerFrame := Round (1000000000 / FCurrent.FrameRate);
   else
      Result := False;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.VideoStreamConfigSetFrameRate: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video frame rate of the capture filter
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FormatType: TFormatType;
   pmt: PAM_MEDIA_TYPE;
   Hr: Hresult;
begin
      Result := False;
      if not assigned (F_AMVideoStreamConfig) then Exit;
      if IsDVSource then Exit;
      if FCurrent.FrameRate < 0 then begin
         FCurrent.FrameRate := 1500;
      end;
      if FCurrent.FrameRate = 0 then Exit;

      Hr := F_AMVideoStreamConfig.GetFormat(pmt);
      if LogH (Hr, LERROR, e_get_video_format, 'get Video format') then begin
         if assigned (pmt^.pbFormat) then  begin
            FormatType := ReturnFormatType (pmt);
            if FormatType <> ft_Unknown then begin
               if VideoStreamConfigSetPmtFrameRate (FormatType, pmt) then begin
                  Result := F_AMVideoStreamConfig.SetFormat(pmt) = S_OK;
               end;
            end;
         end;
         DeleteMediaType(pmt);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function ProceedDVToNonDVFormat (Subtype: pGUID; var VideoOut: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   mt: TAM_MEDIA_TYPE;
begin
   Result := False;

   if not assigned (VideoOut) then Exit;

   Result := IsEqualGUID (Subtype^, MEDIASUBTYPE_YUY2);

   if Result then begin

      ZeroMemory (@mt, sizeof (TAM_MEDIA_TYPE));
      CopyGUID (@mt.MajorType, @MEDIATYPE_Video);
      CopyGUID (@mt.Subtype, Subtype);
      Result := Succeeded (VideoOut.QueryAccept (@mt));
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.VideoStreamConfigSetDVFormat;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the video size of the capture filter
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
   Ok: Boolean;
   CurrentMT: PAM_MEDIA_TYPE;
   x, y: LongInt;
   Subtype: TGUID;
   SubtypeOk: Boolean;
begin
      if not assigned (F_AMVideoStreamConfig) then Exit;
      if not IsDVSource then Exit;

      Ok := true;
      CurrentMT := nil;
      try

         if FVideoSizes.Count = 0 then Exit; { oops! no formats? }

         if FVideoRegSave[_VideoSize].i >= FVideoSizes.Count then begin
            FVideoRegSave[_VideoSize].i := 0;
            LogB (true, LERROR, e_index_out_of_range, 'VideoSize index out of range, default size used');
            Exit;
         end;

         if not DecodeVideoSize (-1, x, y) then Exit;

         SubtypeOk := FVideoRegSave[_VideoSubtype].i < FVideoSubtypes.Count;
         if SubtypeOk then begin
            Subtype := StrToGuid (FVideoSubtypes[FVideoRegSave[_VideoSubtype].i]);
            //if ProceedDVToNonDVFormat (@Subtype, VideoOut) then Exit;
         end;

         hr:= F_AMVideoStreamConfig.GetFormat(CurrentMT);

         if not LogH (Hr, LERROR, e_get_video_format, 'get Video format') then Exit;

         if ReturnFormatType (CurrentMT) = ft_DvInfo then begin

            if SubtypeOk then begin
               CopyGUID (@CurrentMT.Subtype, @Subtype);
            end;

            Ok := F_AMVideoStreamConfig.SetFormat(CurrentMT) = S_OK;
         end;

      finally
         if assigned (CurrentMT) then begin
              DeleteMediaType (CurrentMT);
         end;
         LogB (not Ok, LERROR, e_set_format, 'set video format');
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.AudioStreamConfigSetFormat (var Pin: IPin);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the audio format of the capture filter }
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   hr: HResult;
   pmt: PAM_MEDIA_TYPE;
   wfx: pWaveFormatEx;
   AMAudioStreamConfig: IAMStreamConfig;
begin
      if FAudioFormat = af_default then Exit;
      pmt := nil;
      try
         if not assigned (Pin) then Exit;
         if Failed (Pin.QueryInterface (IAMStreamConfig, AMAudioStreamConfig)) then Exit;

         hr := AMAudioStreamConfig.GetFormat(pmt);
         if not LogH (Hr, LERROR, e_get_audio_format, 'get audio format') then Exit;
         if not _IsEqualGUID (@pmt.formattype, @FORMAT_WaveFormatEx) then Exit;
         wfx := pmt.pbFormat;
         if wfx = nil then Exit;
         if LogB (wfx.wFormatTag <> WAVE_FORMAT_PCM, LWARNING, w_set_audio_format, 'audio format applies only to PCM') then Exit;
         GetWaveFormatFromIndex (LongInt (FAudioFormat), wfx);
         hr := AMAudioStreamConfig.SetFormat(pmt);
         LogH (Hr, LWARNING, w_set_audio_format, 'set audio format');
      finally
         if assigned (pmt) then begin
            DeleteMediaType (pmt);
         end;
         if assigned (AMAudioStreamConfig) then AMAudioStreamConfig := nil;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.DynamicallyCreated;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
    if not FDynamicallyCreatedDone then begin
       FDynamicallyCreatedDone := True;
       Intf.Caption := '';
       if FCurrent.VideoDevice <> FVideoDevice then begin
          ApplySetAudioDevice;
          ApplySetVideoDevice;
       end;
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CurrentStoragePath: String;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   StoragePath_Current: String;
begin
   StoragePath_Current := FStoragePath;
   if length(StoragePath_Current) > 0 then begin
      if StoragePath_Current[Length(StoragePath_Current)]  <> '\' then begin
         StoragePath_Current := StoragePath_Current + '\';
      end;
   end;
   if FStoragePath_DoUpdate then begin
      FStoragePath_DoUpdate := False;
      ForceDirectories2 (StoragePath_Current);
      _SyncManager.RefreshAutoFileSequentialCount (StoragePath_Current, FAutoFilePrefix, CurrentCaptureFileExt);
   end;
   Result := StoragePath_Current;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.NewCaptureFileDuringRecording;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   SavedGraphState: TFilter_State;
   OleStr: pOleStr;
   RecordingFilter: IFileSinkFilter;
begin
   InsertSmartTeeBeforeFilter ('VIDC', F_ScCapturePinVideo);
   if FCurrent.RecordingMethod = rm_AVI then begin
      if assigned (F_AVIFileMux) then begin
         RecordingFilter := F_AVIFileSink;
      end;
   end
   else if FCurrent.RecordingMethod = rm_ASF then begin
      if assigned (F_ASFFileMux) then begin
         RecordingFilter := F_ASFFileSink;
      end;
   end;
   if not assigned (RecordingFilter) then Exit;
   if FGraphType <> cs_Recording then Exit;
   if LogB (FCurrent.PreallocCapFileEnabled, LERROR, e_failed_to_create_file, 'creating a new AVI file during recording not allowed when using a preallocated file') then Exit;
   if LogB (FCurrent.CompressionMode = cm_CompressAfterRecording, LERROR, e_failed_to_create_file, 'creating a new AVI file during Recording not allowed when reencoding after recording') then Exit;
   SavedGraphState := FFilterState;
   ChangeGraphState (State_Stopped, 'ncfdac');
   FRecordingSuccessful := True;
   PostEvent (@Intf.FOnRecordingCompleted);
   PrepareRecordingFile (FOutputFileName);
   RecordingFilter.SetFileName (OleS(FOutputFileName, OleStr), nil);
   SysFreeString (OleStr);
   ReinitFrameInfos;
   ChangeGraphState (SavedGraphState, 'ncfdac2');
   PostEvent (@Intf.FOnRecordingStarted);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CheckAndOrCreatePreallocatedFile (CaptureGraphBuilder2: ICaptureGraphBuilder2; PreallocFileName: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
   BufferSize = $100000;
var
   FileHandle: LongInt;
   GlobalSize64: int64;
   GlobalSizeMB: LongInt;
   MustCreateOrResize: Boolean;
   Done: Boolean;
   Buffer: pByte;
   OldPercent: LongInt;
   ProgressInfo: TProgressInfo;
   FailureMessage: String;
   BlockCount: LongInt;
   iBlock: LongInt;
begin
   FPreallocatedFileCancelCreation := False;

   if PreallocFileName <> '' then begin
      FUsedPreallocFileName := PreallocFileName;
   end
   else begin
      FUsedPreallocFileName := CurrentStoragePath + Intf.Name + FPREALLOCATEDEXTENSION;
   end;

   GlobalSize64 := RetrieveFileSize (FUsedPreallocFileName);
   if GlobalSize64 = -1 then begin // not found
      MustCreateOrResize := True;
   end
   else begin
      GlobalSizeMB := GlobalSize64 shr 20;
      MustCreateOrResize := GlobalSizeMB < FPreallocCapFileSizeInMB;
      if not MustCreateOrResize then begin
         LogB (true, LINFO, i_preallocated_file_size_large_enough, 'prealloc. cap. file "' + FUsedPreallocFileName + '" large enough');
      end;
   end;
   if MustCreateOrResize then begin
      LogB (true, LINFO, i_preallocated_file_size_changed, 'resizing prealloc. cap. file "' + FUsedPreallocFileName + '"...');
      DeleteFile (FUsedPreallocFileName);
      FailureMessage := 'failed to create preallocated file ';
      Result := False;
      FileHandle := FileCreate (FUsedPreallocFileName);
      if FileHandle <> -1 then begin
         OldPercent := -1;
         //NewFileSz := FPreallocCapFileSizeInMB * 1024 * 1024;
         ProgressInfo.Duration := FPreallocCapFileSizeInMB;
         ProgressInfo.Position := 0;
         ProgressInfo.Comment := '';
         ProgressInfo.Percent := 0;
         Done := False;
         GetMem (Buffer, BufferSize);
         ZeroMemory (Buffer, BufferSize);
         iBlock := 0;
         BlockCount := FPreallocCapFileSizeInMB;
         while not Done do begin
            if iBlock > BlockCount then begin
               Done := True;
               Result := True;
            end
            else begin
               if FPreallocatedFileCancelCreation then begin
                  FPreallocatedFileCancelCreation := False;
                  FailureMessage := 'preallocated file creation cancelled: ';
                  Done := True;
               end
               else if FileWrite (FileHandle, Buffer^, BufferSize) <> BufferSize then begin
                  Done := True; // disk full
               end
               else begin
                  inc (iBlock);
                  if CanInvokeEvent (TPObj(Intf.FOnCreatePreallocFileProgress)) then begin
                     ProgressInfo.Position := iBlock;
                     ProgressInfo.Percent := Round (iBlock * 100 / FPreallocCapFileSizeInMB);
                     if ProgressInfo.Percent > 100 then begin
                        ProgressInfo.Percent := 100;
                     end;
                     if OldPercent <> ProgressInfo.Percent then begin
                        OldPercent := ProgressInfo.Percent;
                        Intf.FOnCreatePreallocFileProgress (Intf, ProgressInfo);
                     end;
                  end;
                  FlushMessages;
               end;
            end;
         end;
         if Result then begin
            if CanInvokeEvent (TPObj(Intf.FOnCreatePreallocFileProgress)) then begin
               if OldPercent < 100 then begin
                  ProgressInfo.Position := ProgressInfo.Duration;
                  ProgressInfo.Percent := 100;
                  Intf.FOnCreatePreallocFileProgress (Intf, ProgressInfo);
               end;
            end;
         end;
         FreeMem (Buffer);
         FileClose (FileHandle);
      end;
      FPreallocatedFileSuccessfullyCreated := Result;
      PostEvent (@Intf.FOnCreatePreallocFileCompleted);
      LogB (not Result, LERROR, e_failed_to_allocate_recording_file, FailureMessage + ' "' + FUsedPreallocFileName + '"');
   end
   else begin
      Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.PrepareRecordingFile (var RecordingFile: String): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;
   RecordingFile := '';
   if assigned (_SyncManager) then begin

         if FCurrent.PreallocCapFileEnabled then begin
            if (FCurrent.RecordingMethod <> rm_AVI) or IsMpegSource then begin
               LogB (True, LWARNING, i_preallocated_file_not_suitable, 'the preallocated recording file is not compatible with ASF or MPEG2 recording');
               FCurrent.PreallocCapFileEnabled := False;
            end
            else begin
               if IsLiveVideoSource then begin
                  LogB (GetStorageType (FTemporaryRecordingFileName) = st_Network, LWARNING, w_storage_path_on_network, 'PreallocCapFile= ' + FTemporaryRecordingFileName + #13#10 + 'Network drives or slow drives may produce high rate of dropped frames');
               end;
               LogB (GetStorageType (FTemporaryRecordingFileName) = st_ReadOnly, LERROR, e_storage_path_read_only, 'PreallocCapFile= ' + CurrentStoragePath + #13#10 + 'preallocated recording file set on read-only drive');
            end;
         end;

         FRealRecordingFileName := '';

         if (FCurrent.PreallocCapFileEnabled and (FCurrent.RecordingMethod = rm_AVI)) or (FCurrent.CompressionMode = cm_CompressAfterRecording) then begin
            if FPreallocCapFileName <> '' then begin
               FTemporaryRecordingFileName := FPreallocCapFileName;
            end
            else begin
               FTemporaryRecordingFileName := CurrentStoragePath + Intf.Name + FPREALLOCATEDEXTENSION;
            end;
            if not FCurrent.PreallocCapFileCopiedAfterRecording then begin
               FRealRecordingFileName := FTemporaryRecordingFileName;
            end;
         end
         else begin
            case FCurrent.CompressionMode of
               cm_CompressOnTheFly: begin
                  FTemporaryRecordingFileName:= FRealRecordingFileName;
               end;
               cm_CompressAfterRecording: begin
                  FTemporaryRecordingFileName := CurrentStoragePath + Intf.Name + '.tmp';
               end;
               cm_NoCompression: begin
                  FTemporaryRecordingFileName:= FRealRecordingFileName; { changed in RunGraph if FPreallocatedFileSize <> 0 }
               end;
            end;
         end;

         if FRealRecordingFileName = '' then begin // otherwise it has been set as FTemporaryRecordingFileName when FPreallocCapFileCopiedAfterRecording is disabled
            if (FRecordingFileName = '') or (FRecordingFileName = 'RENEW') then begin
               FRealRecordingFileName := AutoGenerateFileName (afn_Custom, CurrentCaptureFileExt, FRecordingAutoFileSequentialCountIndex);
            end
            else begin
               FRealRecordingFileName := FRecordingFileName;
            end;
         end;

         if FTemporaryRecordingFileName = '' then begin
            FTemporaryRecordingFileName := FRealRecordingFileName;
         end;

         FSaveSequentialFileCount := _SyncManager.GetAutoFileSequentialCount (FRecordingAutoFileSequentialCountIndex);

         if not CheckFreeDiskSpace (FRealRecordingFileName) then begin
            PostEvent (@Intf.FOnDiskFull);
            LogB (False, LERROR, e_disk_full, 'disk full!');
            Exit;
         end;

         if IsLiveVideoSource then begin
            LogB (GetStorageType (CurrentStoragePath) = st_Network, LWARNING, w_storage_path_on_network, 'StoragePath= ' + CurrentStoragePath + #13#10 + 'Network drives or slow drives may produce high rate of dropped frames');
         end;
         LogB (GetStorageType (CurrentStoragePath) = st_ReadOnly, LERROR, e_storage_path_read_only, 'StoragePath= ' + CurrentStoragePath + #13#10 + 'storage set on read-only drive');

         if FCurrent.CompressionMode = cm_CompressAfterRecording then begin
            FMustReencodeRecordedFile:= true;
         end;

         if FMustReencodeRecordedFile or FCurrent.PreallocCapFileEnabled then begin
            if not CheckAndOrCreatePreallocatedFile (F_CaptureGraphBuilder2, FTemporaryRecordingFileName) then Exit;
         end;

         RecordingFile := FTemporaryRecordingFileName;
         Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.SetGraphStateBuilt;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if IsSynchronized then begin
      FGraphState := gs_WaitForSync;
   end
   else begin
      FGraphState := gs_CanActivate;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.PlayerNetworkStreaming: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := LogB (FCurrent.Networkstreaming <> ns_Disabled, LERROR, e_not_allowed_during_network_streaming, 'not allowed during network streaming');
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.RestartGraph (NewState: TCurrentState): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ restarts the graph if its current state <> cs_Down }
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
   procedure WriteLogDevice (Index: LongInt; var Devices: TDevices);
   begin
      if Index < Devices.Count then begin
         WriteLog (nil, sBlue, 'current ' + Devices.FDeviceClassName + ': ' + Devices.FDevices[Index]);
      end
      else begin
         WriteLog (nil, sRed, 'no ' + Devices.FDeviceClassName + ' available.');
      end;
   end;
begin
   Result := false;
   if not assigned (_SyncManager) then Exit;
   if not (NewState in  [cs_Preview, cs_Recording]) then Exit;
   if not FInitializedAtRuntime then Exit;
   if IsLiveVideoSource and (FVideoDevice >= _VideoDevices.Count) then Exit;
   if InitializationStatus <> ipInitialized then Exit;
   if IsLiveVideoSource then begin
      if LogB (_VideoDevices.FDevices.Count = 0, LERROR, e_no_video_input_device, 'no video capture device') then Exit;
   end;
   if FRestartingGraph then Exit;

   try
      FRestartingGraph := True;
      WriteLog ('#', sPurple, 'BEGIN RestartGraph ' + inttostr (LongInt (NewState)));

      ProcessStopGraph;

      LinkSlaves;

      if IsLiveVideoSource then begin
      //if FCurrent.VideoSource = vs_VideoCaptureDevice then begin
         if FCurrent.VideoDevice <> FVideoDevice then begin
            if not ApplySetVideoDevice then Exit;
         end;

         if FCurrent.AudioDevice <> FAudioDevice then begin
            ApplySetAudioDevice; // do not exit upon failure (if there is no audio device)
         end;
         if not FVideoRegSave[_DeviceDiscovered].b then Exit;
      end;

      if CanInvokeEvent (TPObj(Intf.FOnReinitializing)) then Intf.FOnReinitializing (Intf);

      ChangeBusyStateAndCursor (true);

      { SWITCH CURRENT STATE }
      FGraphType := NewState;

      ApplyNotificationSleepTime;

      if FGraphType <> cs_Preview then begin
         FLastPreviewFailed := False;
      end;

      if not ReinitCurrentParams (False) then Exit;


      if LogB ((FCurrent.RecordingCanPause) and (FCurrent.RecordingMethod = rm_ASF), LWARNING, w_can_pause_and_ASF_incompatible, 'RecordingCanPause not allowed during ASF recording') then begin
         FCurrent.RecordingCanPause := False;
      end;

      if Log_DoLogToFile then begin
         if IsLiveVideoSource then begin
         //if FCurrent.VideoSource = vs_VideoCaptureDevice then begin
            WriteLogDevice (FCurrent.VideoDevice, _VideoDevices);
            WriteLogDevice (FCurrent.AudioDevice, _AudioDevices);
            WriteLogDevice (FVideoCompressor, _VideoCompressors);
            WriteLogDevice (FAudioCompressor, _AudioCompressors);
            WriteLogBool (FCurrent.AudioRecording, sGrey, 'capture audio');
            WriteLogBool (FCurrent.AudioDeviceRendering, sGrey, 'render audio');
            WriteLogBool (FColorKeyEnabled, sGrey, 'transparency');
            WriteLogBool (FDVReduceFrameRate, sGrey, 'DV reduce frame rate');
            WriteLogBool (FCurrent.CompressionMode = cm_CompressOnTheFly, sGrey, 'Compress on the fly');
            WriteLogBool (FCurrent.CompressionMode = cm_CompressAfterRecording, sGrey, 'Compress after recording');
         end;
      end;

      FSaveSequentialFileCount := -1;

      if not CreateBaseGraph then Exit;

   //   if not InsertASFFilter then Exit;

      FGraphType := NewState; { because switched back to cs_down by ClearGraph upon failure of CreateBaseGraph; }

      Result := True;

      case FGraphType of

         cs_Recording: begin
            if not PrepareRecordingFile (FOutputFileName) then Exit;
            if isMPEGSource and NativeRecording then begin
               Result := Build_RawCapture;
               if Result and PreviewStreamRequired then begin
                  Result := Build_Preview;
               end;
            end
            else begin
               if not AddFileWriterFilter then Exit;
               if IsDVSource then begin
                  if NativeRecording then begin
                     Result := Build_Capture_DVMode1;
                     if Result and PreviewStreamRequired then begin
                        Result := Build_Preview;
                     end;
                  end
                  else begin
                     Result := Build_Capture_And_Preview;
                  end
               end
               else begin
                  Result := Build_Capture_And_Preview;
               end;
            end;
         end;

         cs_Preview: begin
            if FCurrent.NetworkStreaming <> ns_Disabled then begin
               if not PrepareRecordingFile (FOutputFileName) then Exit;
               if not AddFileWriterFilter then Exit;
            end;
            if PreviewStreamRequired then begin
               if IsDVSource then begin
                  Result := Build_NotNativeDVPreview;
               end
               else begin
                  Result := Build_Preview;
               end;
            end;
         end;
      end;

      if FCurrent.NetworkStreaming <> ns_Disabled then begin
         if assigned (F_ASFFileMux) then begin
            F_CaptureGraphBuilder2.RenderStream (nil, @MEDIATYPE_Video, F_VideoCapturePin, nil, F_ASFFileMux);
         end;
         if assigned (F_ASFFileMux) then begin
//            F_CaptureGraphBuilder2.RenderStream (nil, @MEDIATYPE_Audio, F_VideoCapturePin, nil, F_ASFFileMux);
         end;
      end;

      LogB (not Result, LTRACE, e_failed, 'build graph failed');
      if not Result then Exit;

      InsertAudioDeviceRendering;

      Result := CompleteGraphBuilding (True, FCurrent.AudioRecording);

      if not Result then Exit;

      LogTrees;

      WriteLog (nil, sPurple, 'Preview BUILDOWN END');

      FCurrentFrameData.InitialFrameTime := -1;

      SetGraphStateBuilt;

      if FMultiplexedRole = mr_MultiplexedSlave then begin
         ShowDisplays;
      end;

      if FMultiplexedRole = mr_MultiplexedMaster then begin
         if FGraphType in [cs_Preview, cs_Recording] then begin
            for i := MULTIPLEXEDSLAVE_MINBOUND to MULTIPLEXEDSLAVE_MAXBOUND do begin
                if assigned (FMultiplexedSlave[i].Vdgr) then begin
                   FMultiplexedSlave[i].Vdgr.FMotionDetector.FReset := True;
                   FMultiplexedSlave[i].Vdgr.RestartGraph (FGraphType);
                end;
             end;
         end;
      end;

      Result := True;
   finally
      WriteLog ('#', sPurple, 'END RestartGraph');
      if not Result then begin
         ClearGraph (True);
         if NewState = cs_Preview then begin
            FLastPreviewFailed:= True;
            LogB (True, LERROR, e_failed_to_start_preview, 'failed to start preview');
         end
         else if NewState = cs_Recording then begin
            FRecordingStarted := False;
            LogB (true, LERROR, e_failed_to_start_recording, 'failed to start Recording');
            if FCurrent.CompressionMode = cm_CompressOnTheFly then begin
               LogB (true, LWARNING, e_compressor_possibly_not_suited, 'compressor possibly not suited');
            end;
         end;

         if (FVideoRegSave[_VideoSubtype].i >= 0) and (FVideoRegSave[_VideoSubtype].i < FVideoSubtypes.Count) then begin
            if lowercase (ReturnFourCC (FVideoSubtypes[FVideoRegSave[_VideoSubtype].i])) = 'divx' then begin
               LogB (true, LWARNING, w_divx_codec_not_installed, 'perhaps the DIVX codec is required but not installed on this platform.');
            end;
         end;

         FGraphType := cs_Down;
         //if CanInvokeEvent (TPObj(Intf.FOnInactive)) then Intf.FOnInactive (Intf);
      end;
      ChangeBusyStateAndCursor (false);
      FRestartingGraph := false;
      if FGraphState = gs_CanActivate then begin
         FGraphState := gs_Activating;
         ActivateGraph;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ActivateGraph: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      Result := False;

      writelog (nil, sGrey, 'begin activate graph');

      case FGraphType of

         cs_Preview: begin
            FGetTimeFromClock := True;
            Result := ChangeGraphState (State_Running, 'bprev');
         end;

         cs_Recording: begin
            FGetTimeFromClock := True;
            if (FCurrent.VideoSource <> vs_VideoCaptureDevice) or ((FCurrent.VideoSource = vs_VideoCaptureDevice) and FCurrent.RecordingOnMotion_Enabled or (not FCurrent.HoldRecording)) then begin
               RecordingStartedPostProcessing;
               Result := ChangeGraphState (state_Running, 'bldcapnor');
               if FCurrent.RecordingOnMotion_Enabled then begin
                  FCurrentFrameData.RecordingOnMotionNextTickCountTime := GetTickCount - 1000;
               end;
            end
            else begin
               ControlPinByEnabled (F_ScCapturePinVideo, 'video', false);
               ControlPinByEnabled (F_ScCapturePinAudio, 'audio', false);
               Result := ChangeGraphState (state_Running, 'bldcapnor2');
               if CanInvokeEvent (TPObj(Intf.FOnRecordingReadyToStart)) then begin
                  ShowDisplays;
                  if not assigned (FTimerActivateReadyToStart) then begin
                     FTimerActivateReadyToStart := TTimer.Create (Intf);
                  end;
                  FTimerActivateReadyToStart.OnTimer := ProcessOnReadyToStart;
                  FTimerActivateReadyToStart.Enabled := False;
                  FTimerActivateReadyToStart.Interval := 1;
                  FTimerActivateReadyToStart.Enabled := True;
               end;
            end;
         end;
         cs_Playback: begin
            if IsPlayerStreaming then begin
               ChangeGraphState (State_Paused, 'bldpla1a');
               if FAutoStartPlayer then begin
                  Result := ChangeGraphState (State_Running, 'bldpla1b');
               end;
            end
            else if FAutoStartPlayer then begin
               if FCurrentFrameData.PlayerEmulateSpeedRatioTickCountInterval = 0 then begin
                  if FPlayerFailedToInsertFrameGrabber then begin
                     ShowDisplays;
                     ChangeGraphState (State_Paused, 'bldpla2a');
                     Sleep(200);
                  end;
                  Result := ChangeGraphState (State_Running, 'bldpla2b');
               end
               else begin
                  RunEmulatedPlayback;
                  Result := True;
               end;
            end
            else begin
               ChangeGraphState (state_Running, 'ppg');
               ChangeGraphState (state_Paused, 'ppg');
               ShowDisplays;
               DoPausePlayer (True);
               FPlayerCanRefreshPosition := True;
               Result := True;
            end;
            (*while FPlayerBufferingData and FGraphAccessAllowed do begin
               FlushMessages;
               Sleep (1);
            end;*)
         end;

      end;

      writelog (nil, sGrey, 'end activate graph');

      if Result then begin
         if not FPlayerFailedToInsertFrameGrabber then begin // otherwise done above
            ShowDisplays;
         end;
         FGraphState := gs_Active;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertNullRenderer (var VideoOut: IPin; RetrieveVideoFormat: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Filter: IBaseFilter;
   FilterIn: IPin;
begin
   Result := False;
   try
      if not CreateInstance(@CLSID_NullRenderer, IBaseFilter, Filter, 'Null Renderer') then Exit;
      if not AddFilter (Filter, 'Null Renderer') then Exit;
      if F_CaptureGraphBuilder2.FindPin (Filter, PINDIR_INPUT, nil, nil, true, 0, FilterIn) <> S_OK then Exit;
      if not Connect (VideoOut, FilterIn) then Exit;
      if RetrieveVideoFormat then begin
         RetrieveVideoFormatInfo (FilterIn);
      end;
   finally
      if assigned (VideoOut) then VideoOut := nil;
      if assigned (Filter) then Filter := nil;
      if assigned (FilterIn) then FilterIn := nil;
      Result := True;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.BuildNonVisibleVideoGraph: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   SaveAudioDeviceRendering: Boolean;
begin
      Result := false;
      if FCurrent.VideoDevice = -1 then Exit;
      SaveAudioDeviceRendering := FCurrent.AudioDeviceRendering;
      FCurrent.AudioDeviceRendering := true;
      ReinitCurrentParams (False);
      if CreateBaseGraph then begin
         if TCapDeviceInfo(_VideoDevices.FDevices.Objects[FCurrent.VideoDevice]).WDM then begin
            if InsertVideoRenderer (F_VideoPreviewPin) then begin
               if CompleteGraphBuilding (False, False) then begin
                  Result := ChangeGraphState (state_Running, 'bnvvg');
               end;
            end;
         end
         else begin
            Result := true;
         end;
      end;
      FCurrent.AudioDeviceRendering := SaveAudioDeviceRendering;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.InsertOverlayMixer (var OutputPin: IPin);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Ok: Boolean;

   InPin: IPin;
   OutPin: IPin;
   OverlayMixer: IBaseFilter;
   InitOutputPin: IPin;
begin
   if not Assigned (OutputPin) then Exit;
   if assigned (F_Overlay) then Exit;
   Ok := false;

   try
      InitOutputPin := OutputPin;
      if not CreateInstance(@CLSID_OverlayMixer, IBaseFilter, OverlayMixer, SingleText('ov mix')) then Exit;
      if not AddFilter (OverlayMixer, SingleText ('ov mix')) then Exit;
      if F_CaptureGraphBuilder2.FindPin (OverlayMixer, PINDIR_INPUT, nil, nil, True, 0, InPin) <> S_OK then Exit;
      if F_CaptureGraphBuilder2.FindPin (OverlayMixer, PINDIR_OUTPUT, nil, nil, True, 0, OutPin) <> S_OK then Exit;
      if not Connect (OutputPin, InPin) then Exit;
      if InPin.QueryInterface (IOverlay, F_Overlay) <> S_OK then Exit;
      OutputPin := nil;
      OutputPin := OutPin;
      Ok := assigned (OutPin);
   finally
      if not Ok then begin
         LogB (true, LERROR, e_window_transparency_failed, 'window transparency failed, try FrameGrabber = fg_Disabled or FrameGrabber = fg_CaptureStream');
         if assigned (OverlayMixer) then begin
            F_GraphBuilder.RemoveFilter (OverlayMixer);
         end;
      end;
      if assigned (InPin) then InPin := nil;
      if assigned (OutPin) then OutPin := nil;
      if assigned (OverlayMixer) then OverlayMixer := nil;
      if assigned (InitOutputPin) then InitOutputPin := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ConnectVideoPort: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Dummy: Boolean;
   mt: TAM_MEDIA_TYPE;

   OverlayFilter: IBaseFilter;
   RendererIn: IPin;
   OverlayIn: IPin;
   VideoOut: IPin;
begin
   Result := false;

   if not assigned (F_VideoDevice) then Exit;
   try
      if not FindPinByTypeAndSubtype (F_VideoDevice, PINDIR_OUTPUT, @MEDIATYPE_Video, @MEDIASUBTYPE_VPVideo, VideoOut) then Exit;
      VideoOut := nil;
      if Failed (F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, @PIN_CATEGORY_VideoPort, nil, true, 0, VideoOut)) then Exit;
      if not InsertFilterInline (@CLSID_OverlayMixer, SingleText('ovy mix'), nil, VideoOut) then Exit;
      if not AddRendererFilterGetPin (SingleText('renderer'), @FOverlayRendererW, RendererIn, False, Dummy) then Exit;
      if not Connect (VideoOut, RendererIn) then Exit;
      FOverlayRendererW.IsOverlay := True;
      if RendererIn.ConnectionMediaType (@mt) = S_OK then begin
         case ReturnFormatType (@mt) of
            ft_VideoInfo: begin
               FVideoPortWidth  := pVideoInfoHeader (mt.pbFormat)^.bmiHeader.biWidth;
               FVideoPortHeight := pVideoInfoHeader (mt.pbFormat)^.bmiHeader.biHeight;
            end;
            ft_VideoInfo2: begin
               FVideoPortWidth  := pVideoInfoHeader (mt.pbFormat)^.bmiHeader.biWidth;
               FVideoPortHeight := pVideoInfoHeader (mt.pbFormat)^.bmiHeader.biHeight;
            end;
         end;
         FreeMediaType (@mt);
      end;
      Result := true;
   finally
      if not Result then begin
         if assigned (FOverlayRendererW.RenderFilter) then F_GraphBuilder.RemoveFilter (FOverlayRendererW.RenderFilter);
         FOverlayRendererW.RenderFilter := nil;
         DeleteDownStream (F_GraphBuilder, VideoOut, True);
      end;
      if assigned (VideoOut) then VideoOut := nil;
      if assigned (RendererIn) then RendererIn:= nil;
      if assigned (OverlayFilter) then OverlayFilter := nil;
      if assigned (OverlayIn) then OverlayIn:= nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ProcessCrossbars;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   PinTest: IPin;
   VideoCrossbarBaseFilter: IBaseFilter;
begin
 try
   if not assigned (F_AMVideoCrossbar) then Exit;

   WriteLog (nil, sBlue, 'begin process crossbars');

   RestoreCrossbarState (F_AMVideoCrossbar, FVideoRegSave[_AMVideoCrossbar].s);

   WriteLog (nil, sGrey, 'process crossbars process auto connect');

   if FAutoConnectRelatedPins then begin
      if assigned (FCrossbarAutoRouter) then begin
         FCrossbarAutoRouter.SetCurrentInputFromCrossbar (F_AMVideoCrossbar);
      end
      else begin
         RouteAudioRelatedPin; { will work only if no audio crossbar }
      end;
   end;

   FCrossbar[LongInt(cs_VideoCrossbar)].ReadCrossbar (F_AMVideoCrossbar);
   FCrossbar[LongInt(cs_AudioCrossbar)].ReadCrossbar (F_AMAudioCrossbar);

 finally
    if assigned (PinTest) then PinTest := nil;
    if assigned (VideoCrossbarBaseFilter) then VideoCrossbarBaseFilter:= nil;
    WriteLog (nil, sBlue, 'end process crossbars');
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertVideoDisplay (var VideoOut: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TempPin: IPin;
begin
      TempPin := VideoOut;
      if FColorKeyEnabled then begin
         WriteLog (nil, sGrey, 'ck enabled');
         if F_CaptureGraphBuilder2.FindInterface (nil, nil, F_VideoDevice, IOverlay, F_Overlay) <> S_OK then begin
            WriteLog (nil, sGrey, 'ck: insert ov');
            InsertOverlayMixer (TempPin);
         end;
      end;
      Result := InsertVideoRenderer (TempPin);
      if Result then begin
         TempPin := nil;
         VideoOut := nil;
      end
      else begin
         VideoOut := TempPin;
         TempPin := nil;
      end;
      LogB (not Result, LTRACE, e_failed, 'insert video display');
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RetrieveVideoControlCaps (var Pin: IPin);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   VideoControlCaps: LongInt;
begin
   if not assigned (F_AMVideoControl) then Exit;
   if not assigned (Pin) then Exit;
   if F_AMVideoControl.GetCaps (Pin, VideoControlCaps) = S_OK then begin
      FVideoRegSave[_VideoControlCaps].i := VideoControlCaps;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ApplyVideoControlMode;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not FVideoRegSave[_IsVideoControlAvail].b then Exit;
   if FVideoRegSave[_VideoControlCaps].i = 0 then Exit;
   if not assigned (F_VideoPreviewPin) then Exit;
   if not assigned (F_AMVideoControl) then Exit;
//   F_AMVideoControl.SetMode (F_VideoPreviewPin, FVideoRegSave[_VideoControlMode].i);
   //modify by Terry at 2010-06-04
   if FVideoRegSave[_VideoControlMode].i = 0 then
     F_AMVideoControl.SetMode (F_VideoPreviewPin, VideoControlFlag_Trigger )
   else
     F_AMVideoControl.SetMode (F_VideoPreviewPin, FVideoRegSave[_VideoControlMode].i);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ShowDisplays;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   ShowRenderer: Boolean;
   ShowRenderer2: Boolean;
   ShowOverlay: Boolean;

   procedure PerformRendererVisibility (Renderer: pRenderer; Show: Boolean);
   begin
      with Renderer^ do begin
         if assigned (Display) then begin
            if Display.Visible <> Show then begin
               Display.Visible := Show;
               if Show then begin
                  if assigned (FassociatedWindow) then begin
                     if not IsWindowEmbedded (FAssociatedWindow) then begin
                        Display.SetBounds (CurrentDisplayBounds.Left, CurrentDisplayBounds.Top, CurrentDisplayBounds.Right, CurrentDisplayBounds.Bottom);
                     end;
                  end;
               end;
            end;
         end;
      end;
   end;
begin
   if not FInitializedAtRuntime then Exit;

   ShowRenderer:= false;
   ShowRenderer2:= false;
   ShowOverlay:= false;

   if assigned (FVideoRendererW.FAssociatedWindow)   then ShowRenderer  := FVideoRendererW.DisplayInUse    and FVideoRendererW.FAssociatedWindow.FBool[vwActive];
   if assigned (FVideoRendererW2.FAssociatedWindow)  then ShowRenderer2 := FVideoRendererW2.DisplayInUse   and FVideoRendererW2.FAssociatedWindow.FBool[vwActive];
   if assigned (FOverlayRendererW.FAssociatedWindow) then ShowOverlay   :=  FOverlayRendererW.DisplayInUse and FOverlayRendererW.FAssociatedWindow.FBool[vwActive];

   //FlushMessages; // DNRM ZZZZZ

   PerformRendererVisibility (@FVideoRendererW, ShowRenderer);
   PerformRendererVisibility (@FVideoRendererW2, ShowRenderer2);
   PerformRendererVisibility (@FOverlayRendererW, ShowOverlay);

   //FlushMessages; // DNRM ZZZZZ

   FindVideoWindow (@FVideoRendererW);
   FindVideoWindow (@FVideoRendererW2);
   FindVideoWindow (@FOverlayRendererW);

   ResizeVideoWindows (True);
   //FlushMessages; ZZZZZ
   //Sleep (50);    ZZZZZ
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.InsertAudioDeviceRendering;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   InfTee: IBaseFilter;
begin
   try
      if not assigned (F_AudioRenderPin) then Exit;

      InsertThirdPartyFilters (tpf_AudioSource, F_AudioRenderPin);
      InsertThirdPartyFilters (tpf_AudioRender, F_AudioRenderPin);

      if not InsertFilterInlineGetFilter (@CLSID_InfTee, SingleText('ATee'), InfTee, nil, F_AudioRenderPin) then Exit;

      if FCurrent.AudioDeviceRendering then begin
         LogB (FGraphType = cs_Recording, LWARNING, w_player_audio_should_be_disabled, 'AUDIO RENDERING DURING Recording CAN INCREASE DROPPED FRAMES AND CAUSE AUDIO SYNC PROBLEMS');
         FRenderingAudio := InsertAudioRenderer (F_AudioRenderPin, 'Audio Renderer');
         if not FRenderingAudio then begin
            InsertNullRenderer (F_AudioRenderPin, False);
         end
         else begin
            F_CaptureGraphBuilder2.FindPin (InfTee, PINDIR_OUTPUT, nil, nil, true, 0, F_AudioRenderPin);
         end;
      end;

      //if FGraphType = cs_Preview then begin
         if assigned (F_ASFFileMux) then begin
            F_CaptureGraphBuilder2.RenderStream(nil, @MEDIATYPE_Audio, F_AudioRenderPin, nil, F_ASFFileMux);
         end;
      // end;
   finally
      if assigned (InfTee) then InfTee := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.Build_Preview: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ builds the downstream part of the preview graph
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
   testFltr: TGUID = '{8B498501-1218-11cf-ADC4-00A0D100041B}';
var
   VideoOut: IPin;
   InfTee: IBaseFilter;
   InfTeeAud: IBaseFilter;
begin
      WriteLog (nil, sBlue, 'BEGIN build preview');
      Result := false;
      try
         if LogB (not assigned (F_VideoPreviewPin), LTRACE, e_pin_not_found, 'preview pin not assigned') then Exit;
         if LogB (F_VideoPreviewPin.QueryInterface (IPin, VideoOut) <> S_OK, LTRACE, e_pin_not_found, 'cannot query preview pin') then Exit;

         InsertThirdPartyFilters (tpf_VideoSource, VideoOut);

         if FTransformConfig.VideoHalfDeinterlacing then begin
            InsertTransform (VideoOut, False, True, False, nil, nil, nil);
         end;
         if FTransformConfig.VideoRotation <> rt_0_deg then begin
            InsertTransform (VideoOut, True, False, False, nil, nil, nil);
         end;

         case FCurrent.FrameGrabber of
            fg_PreviewStream, fg_BothStreams: begin
               if not InsertGrabberFilter (VideoOut, gf_RGB, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_RGB], nil) then Exit;
            end;
            fg_CaptureStream: begin
               if not InsertGrabberFilterDerived (nil, VideoOut, gf_RGB, @FGrabberHandlers[gh_RGB]) then Exit;
            end;
         end;

         InsertThirdPartyFilters (tpf_VideoPreview, VideoOut);

         if assigned (F_ASFFileMux) then begin
            if not InsertSmartTee (@CLSID_SmartTee, SingleText('Smart Tee'), VideoOut, F_VideoCapturePin, VideoOut) then Exit;
         end;
         InsertGrabberFilter (VideoOut, gf_Dummy, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleDummy], nil);

         if not InsertVideoDisplay (VideoOut) then Exit;

         WriteLog (nil, sBlue, 'END build preview');
         Result := True;
      finally
         if assigned (VideoOut) then VideoOut := nil;
         if assigned (InfTee) then InfTee := nil;
         if assigned (InfTeeAud) then InfTeeAud := nil;
         WriteLog (nil, sBlue, 'building preview ended');
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.Build_NotNativeDVPreview: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ builds the downstream part of the preview graph
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   VideoOut: IPin;
   DVSplitter: IBaseFilter;
   DVDecoder: IBaseFilter;
begin
      WriteLog (nil, sBlue, 'BEGIN build not native DV preview');
      Result := false;
      try
         if not assigned (F_VideoPreviewPin) then Exit;
         if F_VideoPreviewPin.QueryInterface (IPin, VideoOut) <> S_OK then Exit;

         if FCurrent.FrameGrabber = fg_CaptureStream then begin
            if not InsertGrabberFilterDerived (@CLSID_DVVideoCodec, VideoOut, gf_RGB, @FGrabberHandlers[gh_RGB]) then Exit;
         end;

         if (FCurrent.FrameGrabber in [fg_CaptureStream, fg_Disabled]) and (FVideoRegSave[_VideoSize].i = 4) then begin
            // will use VMR for deinterlacing
         end
         else begin
            if not InsertFilterInlineGetFilter (@CLSID_DVVideoCodec, SingleText ('DV Codec'), DVDecoder, @MEDIATYPE_Video, VideoOut) then Exit;
            ChangeDVResolution (DVDecoder);
            VideoStreamConfigSetDVFormat;
         end;

         InsertThirdPartyFilters (tpf_VideoSource, VideoOut);

         if FTransformConfig.VideoHalfDeinterlacing then begin
            InsertTransform (VideoOut, False, True, False, nil, nil, nil);
         end;
         if FTransformConfig.VideoRotation <> rt_0_deg then begin
            InsertTransform (VideoOut, True, False, False, nil, nil, nil);
         end;

         if FCurrent.FrameGrabber in [fg_PreviewStream, fg_BothStreams] then begin
            if not InsertGrabberFilter (VideoOut, gf_RGB, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_RGB], nil) then Exit;
         end;

         InsertThirdPartyFilters (tpf_VideoPreview, VideoOut);

         //if assigned (F_ASFFileMux) then begin
            if not InsertSmartTee (@CLSID_SmartTee, SingleText('Smart Tee'), VideoOut, F_VideoCapturePin, VideoOut) then Exit;
            InsertGrabberFilter (VideoOut, gf_Dummy, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleDummy], nil);
         //end;

         if not InsertVideoDisplay (VideoOut) then Exit;

         WriteLog (nil, sBlue, 'END build not native DV preview');
         Result := True;
      finally
         if assigned (VideoOut) then VideoOut := nil;
         if assigned (DVSplitter) then DVSplitter := nil;
         if assigned (DVDecoder) then DVDecoder := nil;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.Build_RawCapture: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ builds the downstream part of the capture graph
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RwIn: IPin;
   FileSink: IFileSinkFilter;
   OleStr: pOleStr;
begin
   try
      WriteLog (nil, sBlue, 'BEGIN build raw recording');
      Result := False;
      if FOutputFileName = '' then Exit;

      if not assigned (F_VideoCapturePin) then begin
         if assigned (F_VideoPreviewPin) then begin
            if NativeRecordingSplitterRequired then begin
               if not InsertSmartTee (@CLSID_SmartTee, SingleText('RecTee'), F_VideoPreviewPin, F_VideoCapturePin, F_VideoPreviewPin) then Exit;
            end;
         end;
      end;

      if FCurrent.RecordingCanPause then begin
         if not InsertGrabberFilter (F_VideoCapturePin, gf_LockAndShift, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_LockingVideo], nil) then Exit;
      end;

      if not LoadFilter (nil, 'v~f', @LoadArray, FGrabberHandlers[gh_RwCap].Handle, 'CreateLocalCFrwInstance', FGrabberHandlers[gh_RwCap].Grabber, SingleText('RwCapFilter')) then Exit;
      if not AddFilter (FGrabberHandlers[gh_RwCap].Grabber, SingleText('FGrabberHandlers[gh_RwCap].Grabber')) then Exit;
      if FGrabberHandlers[gh_RwCap].Grabber.QueryInterface (IFileSinkFilter, FileSink) <> S_OK then Exit;
      if FileSink.SetFileName (OleS(FOutputFileName, OleStr), nil) <> S_OK then Exit;
      if F_CaptureGraphBuilder2.FindPin (FGrabberHandlers[gh_RwCap].Grabber, PINDIR_INPUT, nil, nil, true, 0, RwIn) <> S_OK then Exit;
      if not Connect (F_VideoCapturePin, RwIn) then Exit;
      WriteLog (nil, sBlue, 'END build raw recording');
      Result := True;
   finally
      if assigned (Olestr) then SysFreeString (OleStr);
      if assigned (RwIn) then RwIn := nil;
      if assigned (FileSink) then FileSink := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.Build_Capture_And_Preview: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ builds the downstream part of the capture graph
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   VideoPreviewOut: IPin;
   VideoCaptureOut: IPin;
   DVDecoder: IBaseFilter;
   AudioTee: IBaseFilter;
   CapturingAudio: Boolean;
   TeeIn: IPin;
   DummyPin: IPin;
   InfTee: IBaseFilter;
   UsePmt: PAM_MEDIA_TYPE;
   sGUID: String;
   FrameGrabberInserted: Boolean;
   NeedGrabberFilter: Boolean;
begin
      WriteLog (nil, sBlue, 'BEGIN build capture and preview');
      Result := false;
      FRecordingStarted := false;
      CapturingAudio := False;
      UsePmt := nil;
      FrameGrabberInserted := False;

      try
         if LogB (not assigned (F_VideoPreviewPin), LTRACE, e_pin_not_found, 'Capture pin not assigned') then Exit;
         if LogB (F_VideoPreviewPin.QueryInterface (IPin, VideoCaptureOut) <> S_OK, LTRACE, e_pin_not_found, 'cannot query Capture pin') then Exit;

         InsertThirdPartyFilters (tpf_VideoSource, VideoCaptureOut);

         if FTransformConfig.VideoHalfDeinterlacing then begin
            InsertTransform (VideoCaptureOut, False, True, False, nil, nil, nil);
         end;
         if FTransformConfig.VideoRotation <> rt_0_deg then begin
            InsertTransform (VideoCaptureOut, True, False, False, nil, nil, nil);
         end;

         if (FCurrent.FrameGrabber in [fg_CaptureStream, fg_BothStreams]) and (not FCurrent.RecordingInNativeFormat) then begin
            if IsDVSource then begin
               if not InsertFilterInlineGetFilter (@CLSID_DVVideoCodec, 'DV Codec', DVDecoder, @MEDIATYPE_Video, VideoCaptureOut) then Exit;
               ChangeDVResolution (DVDecoder);
            end;
            if not InsertGrabberFilter (VideoCaptureOut, gf_RGB, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_RGB], nil) then Exit;
            FrameGrabberInserted := True;
         end;

         if not InsertSmartTee (@CLSID_SmartTee, SingleText('Smart Tee'), VideoCaptureOut, VideoCaptureOut, VideoPreviewOut) then Exit;

         if not FrameGrabberInserted and IsDVSource then begin
            if GetCurrentSubtypeGUID (sGUID) then begin
               if not IsDVFourCC (ReturnFourCC(sGUID)) then begin
                  if not InsertFilterInlineGetFilter (@CLSID_DVVideoCodec, 'DV Codec rec', DVDecoder, @MEDIATYPE_Video, VideoCaptureOut) then Exit;
                  ChangeDVResolution (DVDecoder);
                  UsePmt := GetPMTFromSubtype_MustBeFreed (VideoCaptureOut, @Format_VideoInfo);
               end;
            end;

            if not InsertFilterInlineGetFilter (@CLSID_DVVideoCodec, 'DV Codec pre', DVDecoder, @MEDIATYPE_Video, VideoPreviewOut) then Exit;
            ChangeDVResolution (DVDecoder);
         end;

         if not CanControlPin (VideoCaptureOut) then begin
            if not InsertSmartTee (@CLSID_SmartTee, SingleText('Smart Tee 2'), VideoCaptureOut, VideoCaptureOut, DummyPin) then Exit;
            F_ScCapturePinVideo := VideoCaptureOut;
         end;

         InsertThirdPartyFilters (tpf_VideoPreview, VideoPreviewOut);
         InsertThirdPartyFilters (tpf_VideoCapture, VideoCaptureOut);

         NeedGrabberFilter := (FCurrent.FrameGrabber = fg_PreviewStream) or ((FCurrent.FrameGrabber = fg_BothStreams) and FCurrent.RecordingInNativeFormat);


         if NeedGrabberFilter then begin
            if not InsertGrabberFilter (VideoPreviewOut, gf_RGB, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_RGB], nil) then Exit;
         end;

         ///////////////////////// display ///////////////////////////////
         if not InsertVideoDisplay (VideoPreviewOut) then Exit;

         if (FCurrent.RecordingMethod = rm_AVI) and (assigned (F_ASFFileMux)) then begin
            if not InsertFilterInlineGetFilter (@CLSID_InfTee, SingleText('Str Inf Tee'), InfTee, @MEDIATYPE_Video, VideoCaptureOut) then Exit;
            if not ConnectIn (True, VideoCaptureOut, F_ASFFileMux, @MEDIATYPE_Video) then Exit;
            if Failed (F_CaptureGraphBuilder2.FindPin (InfTee, PINDIR_OUTPUT, nil, nil, true, 0, VideoCaptureOut)) then Exit;
            InfTee := nil;
         end;

         if CanCompressVideo then begin
            WriteLog (nil, sGrey, 'inserting video compressor');
            if FCurrent.RecordingCanPause then begin
               if not InsertGrabberFilter (VideoCaptureOut, gf_ClearFrame, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_ClearVideo], nil) then Exit;
            end;
            if not BindAndAddCompressor (F_FilterGraph2, _VideoCompressors, FVideoCompressor, 'VIDC', F_VideoCompressor, True) then Exit;
            if not InsertExistingFilter (F_VideoCompressor, VideoCaptureOut) then begin
               LogB (true, LERROR, e_video_compressor_not_suitable, 'video compressor ' + Intf.VideoCompressorName + ' not suitable');
               Exit;
            end;
            RestoreFilterState (F_VideoCompressor, DeviceRegKeyId (_VideoCompressors, FVideoCompressor));

            if FSampleCapture_Video = sc_AfterCompression then begin
               if not InsertGrabberFilter (VideoCaptureOut, gf_Sample, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleVideo], nil) then Exit;
            end;
         end;

         if (FGraphType = cs_Recording) and FCurrent.RecordingCanPause then begin
            if not InsertGrabberFilter (VideoCaptureOut, gf_LockAndShift, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_LockingVideo], nil) then Exit;
         end;
         if FGraphType = cs_Recording then begin
            if FCurrent.RecordingMethod = rm_AVI then begin
               if assigned (VideoCaptureOut) then begin
                  if not ConnectInAndControl (False, VideoCaptureOut, F_AVIFileMux, @MEDIATYPE_Video, F_ScCapturePinVideo, UsePmt) then Exit;
               end;
            end
            else if FCurrent.RecordingMethod = rm_ASF then begin
               if not ConnectInAndControl (True, VideoCaptureOut, F_ASFFileMux, @MEDIATYPE_Video, F_ScCapturePinVideo, nil) then Exit;
            end;
         end
         else begin
            InsertNullRenderer (VideoCaptureOut, false);
         end;

         if assigned (F_AudioRenderPin) then begin

            if FSampleCapture_Audio = sc_Native then begin
               InsertGrabberFilter (F_AudioRenderPin, gf_Sample, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleAudio], nil);
            end;

            InsertThirdPartyFilters (tpf_AudioSource, F_AudioRenderPin);

            if FCurrent.AudioRecording and FCurrent.AudioDeviceRendering then begin
               if not AddFilterGetInput (@CLSID_InfTee, SingleText('Audio Tee'), AudioTee, TeeIn) then Exit;
               if F_AudioRenderPin.Connect (TeeIn, nil) <> S_OK then Exit;
               F_AudioRenderPin := nil;
               TeeIn := nil;
               F_CaptureGraphBuilder2.FindPin (AudioTee, PINDIR_OUTPUT, nil, nil, true, 0, F_AudioRenderPin);
            end;

            if FCurrent.AudioRecording then begin
               InsertThirdPartyFilters (tpf_AudioRecording, F_AudioRenderPin);

               if (FCurrent.RecordingMethod = rm_AVI) and (assigned (F_ASFFileMux)) then begin
                  if not InsertFilterInlineGetFilter (@CLSID_InfTee, SingleText('Str Aud Inf Tee'), InfTee, @MEDIATYPE_Audio, F_AudioRenderPin) then Exit;
                  if not ConnectIn (True, F_AudioRenderPin, F_ASFFileMux, @MEDIATYPE_Audio) then Exit;
                  if Failed (F_CaptureGraphBuilder2.FindPin (InfTee, PINDIR_OUTPUT, nil, nil, true, 0, F_AudioRenderPin)) then Exit;
                  InfTee := nil;
               end;

               if CanCompressAudio then begin
                  WriteLog (nil, sGrey, 'inserting audio compressor');
                  if FCurrent.RecordingCanPause then begin
                     if not InsertGrabberFilter (F_AudioRenderPin, gf_ClearFrame, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_ClearAudio], nil) then Exit;
                  end;
                  if not BindAndAddCompressor (F_FilterGraph2, _AudioCompressors, FAudioCompressor, 'AUDC', F_AudioCompressor, True) then Exit;
                  if not InsertExistingFilter (F_AudioCompressor, F_AudioRenderPin) then begin
                     LogB (true, LERROR, e_audio_compressor_not_suitable, 'audio compressor ' + Intf.AudioCompressorName + ' not suitable');
                     Exit;
                  end;

                  if FSampleCapture_Audio = sc_AfterCompression then begin
                     if not InsertGrabberFilter (F_AudioRenderPin, gf_Sample, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleAudio], nil) then Exit;
                  end;
               end;

               if not IsDVSource then begin
                  FUseMasterStream := ms_AudioMaster;
               end;
            end;

            if (FGraphType = cs_Recording) and FCurrent.RecordingCanPause then begin
               if not InsertGrabberFilter (F_AudioRenderPin, gf_LockAndShift, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_LockingAudio], nil) then Exit;
            end;

            if (FGraphType = cs_Recording) and FCurrent.AudioRecording then begin
               if FCurrent.RecordingMethod = rm_AVI then begin
                  if not ConnectInAndControl (False, F_AudioRenderPin, F_AVIFileMux, @MEDIATYPE_Audio, F_ScCapturePinAudio, nil) then Exit;
              end
                else if FCurrent.RecordingMethod = rm_ASF then begin
                  if not ConnectInAndControl (True, F_AudioRenderPin, F_ASFFileMux, @MEDIATYPE_Audio, F_ScCapturePinAudio, nil) then Exit;
               end;
               CapturingAudio := True;
            end;

            if assigned (AudioTee) and FCurrent.AudioDeviceRendering then begin
               if assigned (F_AudioRenderPin) then F_AudioRenderPin := nil;
               F_CaptureGraphBuilder2.FindPin (AudioTee, PINDIR_OUTPUT, nil, nil, true, 0, F_AudioRenderPin);
            end;
         end;

         WriteLog (nil, sBlue, 'END build capture and preview');
         Result := True;
      finally
         if not CapturingAudio then begin
            FUseMasterStream := ms_NoMaster;
         end;
         if assigned (VideoPreviewOut) then VideoPreviewOut := nil;
         if assigned (VideoCaptureOut) then VideoCaptureOut := nil;
         if assigned (DVDecoder) then DVDecoder := nil;
         if assigned (AudioTee) then AudioTee := nil;
         if assigned (TeeIn) then TeeIn := nil;
         if assigned (DummyPin) then DummyPin := nil;
         if assigned (InfTee) then InfTee := nil;
         if assigned (UsePmt) then DeleteMediaType (UsePmt);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.Build_Capture_DVMode1: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ builds the downstream part of the capture graph
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;

   WriteLog (nil, sBlue, 'BEGIN build capture DV mode 1');
   if FCurrent.RecordingCanPause then begin
      if not InsertGrabberFilter (F_VideoCapturePin, gf_LockAndShift, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_LockingVideo], nil) then Exit;
   end;

   if FRecordingMethod = rm_AVI then begin
      if not ConnectInAndControl (False, F_VideoCapturePin, F_AVIFileMux, @MEDIATYPE_Interleaved, F_ScCapturePinVideo, nil) then begin
         WriteLog (nil, sRed, 'ERROR: video connection to file mux failed');
         Exit;
      end;
   end
   else begin
      if not ConnectInAndControl (True, F_VideoCapturePin, F_ASFFileMux, @MEDIATYPE_Interleaved, F_ScCapturePinVideo, nil) then begin
         WriteLog (nil, sRed, 'ERROR: video connection to file mux failed');
         Exit;
      end;
   end;

   FUseMasterStream := ms_NoMaster;
   WriteLog (nil, sBlue, 'END build capture DV mode 1');

   Result := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RecordingStartedPostProcessing;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   WriteLog (nil, sBlue, 'BEGIN recording started post processing');
   FRecordingStarted := true;
   FFrameInfo_Grabber.CurrentFrameNumber := 1;
   FFrameInfo_Grabber.CurrentFrameTime := 0;
   FFrameInfo_Current.CurrentFrameNumber := 1;
   FFrameInfo_Current.CurrentFrameTime := 0;
   FCurrentFrameData.InitialFrameTime := -1;
   FCurrentFrameData.InitialFrameTime := -1;
   PostEvent (@Intf.FOnRecordingStarted);
   WriteLog (nil, sBlue, 'END recording started post processing');
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ReencodeCapturedFileIfRequired: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ reencodes the captured file, if the option is enabled
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   ReencodingSettings: TReencodingSettings;
begin
      Result := False;

      InitReencodingSettings (@ReencodingSettings);
      ReencodingSettings.SourceVideoClip := FTemporaryRecordingFileName;
      ReencodingSettings.NewVideoClip := FRealRecordingFileName;
      ReencodingSettings.IncludeVideoStream := True;
      ReencodingSettings.IncludeAudioStream := FCurrent.AudioRecording;
      ReencodingSettings.UseFrameGrabber := False;
      ReencodingSettings.UseVideoCompressor := False;
      ReencodingSettings.UseAudioCompressor := False;
      ReencodingSettings.Method := FCurrent.RecordingMethod;
      ReencodingSettings.StartTime := -1;
      ReencodingSettings.StopTime := -1;
      ReencodingSettings.Method := FCurrent.RecordingMethod;
      ReencodingSettings.StartTime := -1;
      ReencodingSettings.StopTime := -1;

      if FCurrent.PreallocCapFileEnabled and (not FMustReencodeRecordedFile) and FCurrent.PreallocCapFileCopiedAfterRecording then begin // copy preallocated
         PostEvent (@Intf.FOnCopyPreallocDataStarted);

         ReencodingSettings.UseVideoCompressor := False;
         ReencodingSettings.UseAudioCompressor := False;
         Result := ReencodeOrRecopyFile (@ReencodingSettings, True, False);
      end
      else if FMustReencodeRecordedFile then begin // preallocated capture + reencoding

         PostEvent (@Intf.FOnReencodingStarted);

         ReencodingSettings.UseVideoCompressor := FCurrent.CompressionType in [ct_Video, ct_AudioVideo];
         ReencodingSettings.UseAudioCompressor := FCurrent.CompressionType in [ct_Audio, ct_AudioVideo];
         Result := ReencodeOrRecopyFile (@ReencodingSettings, False, False);
      end;
      FMustReencodeRecordedFile:= false;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ReduceDVFrameRate (var DVSplitter: IBaseFilter);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ reduce the DV frame rate of the DV stream (reject half of the frames)
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   SplitterConf: IDVSplitter;
begin
      if DVSplitter.QueryInterface (IDVSplitter, SplitterConf) = S_OK then begin
         if FDVReduceFrameRate then begin
            SplitterConf.DiscardAlternateVideoFrames (1);
         end
         else begin
            SplitterConf.DiscardAlternateVideoFrames (0);
         end;
         SplitterConf := nil;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CanCompressVideo: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ indicates if video compression is required
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      Result := false;
         if (((FCurrent.CompressionMode = cm_CompressOnTheFly) and (FGraphType = cs_Recording))
            or ((FCurrent.CompressionMode = cm_CompressOnTheFly) and (FGraphType = cs_Preview))
            or (FGraphType = cs_Reencoding))


            and ((FCurrent.CompressionType = ct_Video) or (FCurrent.CompressionType = ct_AudioVideo)) then begin
               if FMPEGWriterFilter = '' then begin
                  if FCurrent.RecordingMethod = rm_AVI then begin
                     Result := true;
                  end;
               end;
         end;

end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CanCompressAudio: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ indicates if audio compression is required
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      Result := false;
      if (((FCurrent.CompressionMode = cm_CompressOnTheFly) and (FGraphType = cs_Recording))
       or ((FCurrent.CompressionMode = cm_CompressOnTheFly) and (FGraphType = cs_Preview))
       or (FGraphType = cs_Reencoding))

         and ((FCurrent.CompressionType = ct_Audio) or (FCurrent.CompressionType = ct_AudioVideo)) then begin

               if FMPEGWriterFilter = '' then begin
                  if FCurrent.RecordingMethod = rm_AVI then begin
                     Result := true;
                  end;
               end;

      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function AudioDeviceRegKeyId (Index: LongInt): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      Result := '';
      if Index < 0 then Exit;
      if Index >= _AudioDevices.FDevices.Count then Exit;
      Result := CheckRegKeyId + 'Devices\' + TCapDeviceInfo(_AudioDevices.FDevices.Objects[Index]).RegistryStringId;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function CompressorRegKeyId (Index: LongInt): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      Result := '';
      if Index < 0 then Exit;
      if Index >= _VideoCompressors.FDevices.Count then Exit;
      Result := CheckRegKeyId + 'Codecs\' + TCapDeviceInfo(_VideoCompressors.FDevices.Objects[Index]).RegistryStringId;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ThirdPartyFilterRegKeyId (GUID: TGUID): string;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := CheckRegKeyId + 'ThirdPartyFilters\' + GUIDTostring (GUID);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.Connect (var OutPin, InPin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ connects 2 pins, returns true if connected
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   OutPinInfo: TPin_Info;
   OutFilterIn: IPin;
   PrevFilterOut: IPin;
begin
   Result := False;
   try
      if LogB (not assigned (OutPin), LTRACE, e_not_assigned, 'connect: OutPin not assigned') then Exit;
      if LogB (not assigned (InPin), LTRACE, e_not_assigned, 'connect: In not assigned') then Exit;
      Result := F_GraphBuilder.ConnectDirect (OutPin, InPin, nil) = S_OK;
      if not Result then begin
         InPin.Disconnect;
         OutPin.Disconnect;
         Result := F_GraphBuilder.Connect (OutPin, InPin) = S_OK;
      end;
      if not Result then begin
         InPin.Disconnect;
         OutPin.Disconnect;
         if OutPin.QueryPinInfo (OutPinInfo) = S_OK then begin
            if F_CaptureGraphBuilder2.FindPin (OutPinInfo.pFilter, PINDIR_INPUT, nil, nil, false, 0, OutFilterIn) = S_OK then begin
               if OutFilterIn.ConnectedTo (PrevFilterOut) = S_OK then begin
                  PrevFilterOut.Disconnect;
                  OutFilterIn.Disconnect;
                  if F_GraphBuilder.Connect (PrevFilterOut, OutFilterIn) = S_OK then begin
                     Result := F_GraphBuilder.Connect (OutPin, InPin) = S_OK;
                  end;
                  PrevFilterOut := nil;
               end;
               OutFilterIn := nil;
            end;
            OutPinInfo.pFilter := nil;
         end;
      end;
   finally
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ConnectIn (IsASF: Boolean; var OutPin: IPin; ToFilter: IBaseFilter; MajorType: pGUID): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ connects 2 pins, returns true if connected
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   InPin: IPin;
begin
   Result := false;
   if IsASF then begin
      if not FindPinByTypeAndSubtype (ToFilter, PINDIR_INPUT, MajorType, nil, InPin) then Exit;
   end
   else
   begin
      if F_CaptureGraphBuilder2.FindPin (ToFilter, PINDIR_INPUT, nil, nil, true, 0, InPin) <> S_OK then Exit;
   end;

   Result := Connect (OutPin, InPin);
   InPin := nil;
   if Result then begin
      OutPin := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ConnectInAndControl (IsASF: Boolean; var OutPin: IPin; ToFilter: IBaseFilter; MajorType: pGUID; var ControlledPin: IPin; UsePmt: PAM_MEDIA_TYPE): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ connects 2 pins, returns true if connected
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   DummyPin: IPin;
   ControlledPinIsOutPin: Boolean;
   StreamControl: IAMStreamControl;
   CxMediaType: TAM_MEDIA_TYPE;
begin
   Result := false;
   ControlledPinIsOutPin := False;
   if assigned (ControlledPin) then ControlledPin := nil;
   if IsASF then begin
      if not FindPinByTypeAndSubtype (ToFilter, PINDIR_INPUT, MajorType, nil, ControlledPin) then Exit;
   end
   else
   begin
      if F_CaptureGraphBuilder2.FindPin (ToFilter, PINDIR_INPUT, nil, nil, true, 0, ControlledPin) <> S_OK then Exit;
   end;

   if Succeeded (ControlledPin.QueryInterface (IAMStreamControl, StreamControl)) then begin
      StreamControl := nil;
   end
   else begin
      if not InsertSmartTee (@CLSID_SmartTee, SingleText('control'), OutPin, OutPin, DummyPin) then Exit;
      DummyPin := nil;
      ControlledPinIsOutPin := True;
   end;

   Result := False;
   if assigned (UsePmt) then begin
      Result := Succeeded (OutPin.Connect (ControlledPin, UsePmt));
   end;

   if not Result then begin
      Result := Connect (OutPin, ControlledPin);
   end;

   if Result then begin
      if Succeeded (OutPin.ConnectionMediaType (@CxMediaType)) then begin
         if IsEqualGUID (CxMediaType.majortype, MEDIATYPE_Video) or IsEqualGUID (CxMediaType.majortype, MEDIATYPE_Interleaved) then begin
            CopyGUID (@FRecordingSubtype, @CxMediaType.Subtype);
            FreeMediaType (@CxMediaType);
         end;
      end;
   end;

   if ControlledPinIsOutPin then begin
      ControlledPin := OutPin;
   end;
   if assigned (OutPin) then OutPin := nil;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertFilterInline (CLSID:pGUID; FilterName: string; RequiredOutputMediaType: pGUID; var OutputPin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Filter: IBaseFilter;
begin
   Result := InsertFilterInLineGetFilter (CLSID, FilterName, Filter, RequiredOutputMediaType, OutputPin);
   if assigned (Filter) then Filter := nil;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertFilterInlineGetFilter (CLSID:pGUID; FilterName: string; var BaseFilter: IBaseFilter; RequiredOutputMediaType: pGUID; var OutputPin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   InPin: IPin;
   OutPin: IPin;
begin
   Result := false;
   try
      if not Assigned (OutputPin) then Exit;
      if not AddFilterGetInput (CLSID, FilterName, BaseFilter, InPin) then Exit;
      if not Connect (OutputPin, InPin) then begin
         F_GraphBuilder.RemoveFilter(BaseFilter);
         BaseFilter := nil;
         WriteLog (nil, sRed, 'ERROR: InsertFilterInline cannot connect ' + FilterName);
         Exit;
      end;
      if F_CaptureGraphBuilder2.FindPin (BaseFilter, PINDIR_OUTPUT, nil, RequiredOutputMediaType, true, 0, OutPin) <> S_OK then begin
         OutputPin.Disconnect;
         InPin.Disconnect;
         F_GraphBuilder.RemoveFilter(BaseFilter);
         BaseFilter := nil;
         WriteLog (nil, sRed, 'ERROR: InsertFilterInline: out pin not found in ' + FilterName);
         Exit;
      end;
      OutputPin := OutPin;
      Result := assigned (OutputPin);
   finally
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertSmartTee (CLSID: pGUID; FilterName: string; var OutputPin: IPin; var CaptureOut, PreviewOut: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   InPin: IPin;
   TempPin: IPin;
   BaseFilter: IBaseFilter;
begin
   Result := false;
   try
      if not Assigned (OutputPin) then Exit;
      TempPin := OutputPin;
      OutputPin := nil;
      if not AddFilterGetInput2Outputs (CLSID, FilterName, BaseFilter, InPin, CaptureOut, PreviewOut) then Exit;
      if not Connect (TempPin, InPin) then begin
         F_GraphBuilder.RemoveFilter(BaseFilter);
         BaseFilter := nil;
         WriteLog (nil, sRed, 'ERROR: InsertFilter2 cannot connect ' + FilterName);
         Exit;
      end;
      Result := true;
   finally
      if assigned (TempPin) then TempPin := nil;
      if assigned (InPin) then InPin := nil;
      if assigned (BaseFilter) then BaseFilter := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AddRendererFilterGetPin (FilterName: string; Renderer: pRenderer; out FilterIn: IPin; CanUseVMR: Boolean; var VMRUsed: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := AddRendererFilter (FilterName, Renderer, CanUseVMR, VMRUsed);
   if Result then begin
      Result := F_CaptureGraphBuilder2.FindPin (Renderer.RenderFilter, PINDIR_INPUT, nil, nil, true, 0, FilterIn) = S_OK;
      if not Result then begin
         WriteLog (nil, sRed, 'ERROR: AddFilterGetInput cannot find input pin in filter ' + FilterName);
      end;
   end;
   if not Result then begin
      if assigned (FilterIn) then FilterIn := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AddRendererFilter (FilterName: string; Renderer: pRenderer; CanUseVMR: Boolean; var VMRUsed: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ adds the ClsidFilter filter named by FilterName to the graph, returns the Filter pointer and the in pin
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Ok: Boolean;
   DirectDrawVideo: IDirectDrawVideo;
begin
   Result := false;
   VMRUsed := False;
   with Renderer^ do begin
      WriteLog (nil, sBlue, 'ADR begin');
      RenderFilter := nil;
      Ok := False;
      if DisplayInUse then begin
         ClearWindow (Renderer);
      end;
      if FColorKeyEnabled or (FCurrent.VideoRenderer = vr_StandardRenderer) then begin
         CanUseVMR := False;
      end;
      if CanUseVMR then begin
         WriteLog (nil, sGrey, 'cr VMR');
         if (FCurrent.VideoRenderer = vr_VMR9) then begin
            Ok := CreateInstance(@CLSID_VMR9, IBaseFilter, RenderFilter, FilterName);
         end;
         if (FCurrent.VideoRenderer = vr_VMR7) then begin
            Ok := CreateInstance(@CLSID_VMR7, IBaseFilter, RenderFilter, FilterName);
         end;
         if not Ok then begin { one vmr is not available, retry VMR7 }
            Ok := CreateInstance(@CLSID_VMR7, IBaseFilter, RenderFilter, FilterName);
         end;
         if not Ok then begin { one vmr is not available, retry VMR9 }
            Ok := CreateInstance(@CLSID_VMR9, IBaseFilter, RenderFilter, FilterName);
         end;
      end;

      if not Ok then begin
         RenderFilter := nil;
         WriteLog (nil, sGrey, 'ADR cr normal');
         Ok := CreateInstance(@CLSID_VideoRenderer, IBaseFilter, RenderFilter, FilterName);
         if Ok then begin
            if RenderFilter.QueryInterface (IDirectDrawVideo, DirectDrawVideo) = S_OK then begin
               DirectDrawVideo.SetSwitches (AMDDS_RGBOFF);
               DirectDrawVideo := nil;
            end;
         end;
      end;

      if Ok then begin
         WriteLog (nil, sGrey, 'ADR add filt');
         if AddFilter (RenderFilter, FilterName) then begin
            WriteLog (nil, sGrey, 'ADR find input ok: ' + FilterName);
            DisplayInUse := True;
            Result := true;
         end
         else begin
            WriteLog (nil, sRed, 'ERROR: AddFilterGetInput cannot add filter ' + FilterName);
         end;
      end
      else begin
         WriteLog (nil, sRed, 'ERROR: AddFilterGetInput cocreate instance failed on filter ' + FilterName);
      end;
      WriteLog (nil, sBlue, 'ADR end');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RetrieveVideoFormatInfo (var InPin: IPin);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   mt: TAM_MEDIA_TYPE;
   Dummy1: dword;
   Dummy2: Int64;
   w, h: LongInt;
   Ok: Boolean;
begin
   Ok := False;
   if isMPEGSource and (FGraphType <> cs_Playback) then begin
      Ok := DecodeVideoSize (-1, w, h);
      if Ok then begin
         FVideoSourceWidth := w;
         FVideoSourceHeight := h;
      end;
   end;
   if not Ok then begin
      if assigned (InPin) then begin
         ZeroMemory (@mt, sizeof (TAM_MEDIA_TYPE));
         if InPin.ConnectionMediaType(@mt) = S_OK then begin
            if FDiscovering then begin { otherwise we can get wrong values if the format has been converted by a filter }
               if _IsEqualGUID (@mt.FormatType, @Format_VideoInfo2) then begin
                  FVideoRegSave[_IsVideoInterlaced].b := (pVideoInfoHeader2 (mt.pbFormat)^.dwInterlaceFlags and AMINTERLACE_IsInterlaced) <> 0;
               end;
            end;
            ReturnFormatValues (@mt, dummy1, dummy2, FVideoSourceWidth, FVideoSourceHeight);
            FreeMediaType (@mt);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TJxdVideoGrabber.SetPlayerSpeedRatio (Value: Double);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ sets the clip's frame rate
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   with TVdgr(_Vdgr) do begin
      if Value <= 0 then Exit;
      if Value = FPlayerSpeedRatio then Exit;
      FPlayerSpeedRatio := Value;

      //LogB ((FPlayerSpeedRatio <> 1) and (((FGraphType <> cs_Playback) and FPlayerAudioRendering) or ((FGraphType = cs_Playback) and FCurrent.PlayerAudioRendering)), LWARNING, w_player_audio_should_be_disabled, 'disable PlayerAudioRendering if the clip freezes when speed ratio < 1');

      if FFilterState = State_Running then begin
         ChangeGraphState (State_Paused, 'spsr1');
         ChangeGraphState (State_Running, 'spsr2');
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ApplyPlayerSpeedRatio (Value: Double);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if assigned (F_MediaSeeking) then begin
         if not FCurrent.PlayerAudioRendering then begin
            if assigned (F_CustomClock) then begin
               F_CustomClock.SetClock (Round(BASECLOCKVALUE / Value));
               FCurrentFrameData.PlayerFrameInterval := Round (FPlayerDuration / FPlayerFrameCount);
            end;
         end
         else begin
            F_MediaSeeking.SetRate (Value);
            FCurrentFrameData.PlayerFrameInterval := Round (FPlayerDuration / FPlayerFrameCount);
         end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.QueryPlayerMediaSeeking: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
      SeekCaps: DWord;
      Hr: HResult;
      CannotChangePlayerSpeedRatio: Boolean;
begin
      Result := False;

      Hr := F_GraphBuilder.QueryInterface (IVideoFrameStep, F_VideoFrameStep);
      LogH (Hr, LERROR, e_get_interface, 'video frame step');

      Hr:= F_GraphBuilder.QueryInterface (IMediaSeeking, F_MediaSeeking);
      if not LogH (Hr, LERROR, e_get_interface, 'find Media seeking') then Exit;
      if not assigned (F_MediaSeeking) then Exit;

      Result := True;

      CannotChangePlayerSpeedRatio := False;

      if FCurrent.PlayerAudioRendering then begin
         CannotChangePlayerSpeedRatio := F_MediaSeeking.SetRate (FPlayerSpeedRatio) <> S_OK;
         LogB (CannotChangePlayerSpeedRatio, LWARNING, e_failed_to_set_player_speed_ratio_with_audio, 'cannot set player speed ratio, you should enable PlayerSpeedRatioWithoutAudio.');
      end;

      if F_MediaSeeking.GetCapabilities(SeekCaps) = S_OK then begin
         if SeekCaps <> 0 then begin
            FPlayerCanSeek := (SeekCaps and AM_SEEKING_CanSeekAbsolute) <> 0;
         end
         else begin
            FPlayerCanSeek := True;
         end;
      end;

      if F_MediaSeeking.IsFormatSupported (TIME_FORMAT_FRAME) = S_OK then begin
         F_MediaSeeking.SetTimeFormat (TIME_FORMAT_FRAME);
         F_MediaSeeking.GetDuration (FPlayerFrameCount);
      end;

      F_MediaSeeking.SetTimeFormat (TIME_FORMAT_MEDIA_TIME);
      if Failed (F_MediaSeeking.GetDuration (FPlayerDuration)) then begin
      end;

      if FPlayerFrameCount = 0 then begin { asumme 24 fps }
         FCurrentFrameData.PlayerFrameInterval := 416666;
         FPlayerFrameCount := Round (FPlayerDuration / FCurrentFrameData.PlayerFrameInterval);
      end;

      if CannotChangePlayerSpeedRatio then begin
         FCurrentFrameData.PlayerEmulateSpeedRatioTickCountInterval := Round (FCurrentFrameData.PlayerFrameInterval / 10000 / FPlayerSpeedRatio);
      end
      else begin
         FCurrentFrameData.PlayerEmulateSpeedRatioTickCountInterval := 0;
      end;

      ApplyPlayerSpeedRatio (1);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertVideoRenderer (var OutputPin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   State: TSaveFilterState;
begin
   State := SnapGraph (OutputPin);
   Result := InstallDisplay (OutputPin, True);
   if not Result then begin
      ClearWindow (@FVideoRendererW);
      ClearWindow (@FVideoRendererW2);
      ClearWindow (@FOverlayRendererW);

      if RestoreGraph (State, OutputPin) then begin
         WriteLog (nil, sRed, 'GRAPH RESTORED...');
         Result := InstallDisplay (OutputPin, False);
      end;
   end;
   State.Free;
   LogB (not Result, LTRACE, e_failed, 'insert video renderer');
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.UpdateSpeakersControl;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FSpeakerControl and (FGraphType in [cs_Preview, cs_Recording, cs_Playback]) then begin
      if FMuteAudioRendering then begin
         SetMixerVolume (0, 0);
      end
      else begin
         if CanAssociateAudioAndVideoDevices then begin
            SetMixerVolume (FVideoRegSave[_SpeakerVolumeAssociated].i, FVideoRegSave[_SpeakerBalanceAssociated].i);
         end
         else begin
            SetMixerVolume (FAudioRegSave[_SpeakerVolume].i, FAudioRegSave[_SpeakerBalance].i);
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertAudioRenderer (var OutputPin: IPin; FilterName: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   InPin: IPin;
   Filter: IBaseFilter;
begin
   Result := false;
   try
      if not assigned (OutputPin) then Exit;
      if not AddFilterGetInput (@CLSID_AudioRender, FilterName, Filter, InPin) then Exit;
      if not Connect (OutputPin, InPin) then begin
         F_GraphBuilder.RemoveFilter (Filter);
         Filter := nil;
         Exit;
      end;
      OutputPin := nil;
      Result := true;
   finally
      if assigned (InPin) then InPin := nil;
      if assigned (Filter) then Filter := nil;
   end;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertFilter (CLSID: pGUID; var OutputPin: IPin; FilterName: string; var BaseFilter: IBaseFilter): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   InPin: IPin;
begin
   Result := false;
   try
      if not Assigned (OutputPin) then Exit;
      BaseFilter := nil;
      if not AddFilterGetInput (CLSID, FilterName, BaseFilter, InPin) then Exit;
      if not Connect (OutputPin, InPin) then begin
         F_GraphBuilder.RemoveFilter (BaseFilter);
         BaseFilter := nil;
         WriteLog (nil, sRed, 'ERROR: InsertFilter cannot connect ' + FilterName);
         Exit;
      end;
      OutputPin := nil;
      Result := true;
   finally
      if assigned (InPin) then InPin := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertExistingFilter (var Filter: IBaseFilter; var OutputPin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   InPin: IPin;
   OutPin: IPin;

   function FilterName: string;
   var
      FilterInfo: TFilterInfo;
   begin
      if assigned (Filter) then begin
         if Filter.QueryFilterInfo (FilterInfo) = S_OK then begin
            Result := FilterInfo.achName;
            FilterInfo.pGraph := nil;
         end;
      end;
   end;
begin
   Result := false;
   try
      if not Assigned (OutputPin) then Exit;
      if F_CaptureGraphBuilder2.FindPin (Filter, PINDIR_INPUT, nil, nil, true, 0, InPin) <> S_OK then begin
         WriteLog (nil, sRed, 'ERROR: InsertExistingFilter cannot find input pin  on ' + FilterName);
         Exit;
      end;
      if F_CaptureGraphBuilder2.FindPin (Filter, PINDIR_OUTPUT, nil, nil, true, 0, OutPin) <> S_OK then begin
         WriteLog (nil, sRed, 'ERROR: InsertExistingFilter cannot find output pin on ' + FilterName);
         Exit;
      end;
      if not Connect (OutputPin, InPin) then Exit;

      WriteLog (nil, sGrey, 'InsertExistingFilter inserted  ' + FilterName);
      OutputPin := nil;
      OutputPin := OutPin;
      Result := assigned (OutputPin);
   finally
      if assigned (InPin) then InPin := nil;
      if assigned (OutPin) then OutPin := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.DoReencoding (ReencodingSettings: pReencodingSettings): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ prepares to reencoding a file
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      Result := False;
      if not Allow ([cs_Down, cs_Preview], LERROR, False) then Exit;
      if CanInvokeEvent (TPObj(Intf.FOnReencodingStarted)) then Intf.FOnReencodingStarted (Intf, ReencodingSettings^.SourceVideoClip, ReencodingSettings^.NewVideoClip);
      ChangeBusyStateAndCursor (True);

      ClearGraph (True);

      Result := ReencodeOrRecopyFile (ReencodingSettings, False, True);

      ChangeBusyStateAndCursor (False);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.QueryReencodingMediaSeeking: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
begin
   Result := False;

   Hr:= F_GraphBuilder.QueryInterface (IMediaSeeking, F_MediaSeeking);
   if not LogH (Hr, LERROR, e_get_interface, 'find Media seeking') then Exit;
   if not assigned (F_MediaSeeking) then Exit;

   F_MediaSeeking.SetTimeFormat (TIME_FORMAT_MEDIA_TIME);

   F_MediaSeeking.GetDuration (FReencodingProgressInfo.Duration);

   Result := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ApplyReencodingPositions (ReencodingSettings: pReencodingSettings): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TimeStart, TimeStop: int64;
begin
   TimeStart := ReencodingSettings^.StartTime;
   TimeStop := ReencodingSettings^.StopTime;

   Result := False;

   FReencodingProgressEndTime := FReencodingProgressInfo.Duration;

   if (TimeStart = -1) and (TimeStop = -1) then begin
      Result := True;
   end
   else begin
      if TimeStart = -1 then begin
         TimeStart := 0;
      end;
      if TimeStop = -1 then begin
         TimeStop := high(int64);
      end;

      if (TimeStart < 0) or (TimeStop < 0) then begin
         LogB (true, LERROR, e_reencoding, 'start time and stop time must have positive values');
      end
      else if TimeStart > TimeStop then begin
         LogB (true, LERROR, e_reencoding, 'stop time must be higher than start time');
      end
      else if (TimeStart > FReencodingProgressInfo.Duration) then begin
         LogB (true, LERROR, e_reencoding, 'start time exceeds duration (' + IntToStr (FReencodingProgressInfo.Duration) + ')');
      end
      else begin
         Result := True;
         LogB ((TimeStop > FReencodingProgressInfo.Duration) and (ReencodingSettings^.StopTime <> -1), LWARNING, e_reencoding, 'stop time exceeds duration  (' + IntToStr (FReencodingProgressInfo.Duration) + ')');
      end;

      if Result then begin

         if TimeStop <  FReencodingProgressInfo.Duration then begin
            FReencodingProgressEndTime := TimeStop;
         end;

         if ReencodingSettings^.Method = rm_ASF then begin
            if not assigned (F_ScCapturePinVideo) then begin
               FindConnectedPinsTypeAndSubtype (F_ASFFileMux, PINDIR_INPUT, @MEDIATYPE_Video, nil, F_ScCapturePinVideo);
            end;

            if not assigned (F_ScCapturePinAudio) then begin
               FindConnectedPinsTypeAndSubtype (F_ASFFileMux, PINDIR_INPUT, @MEDIATYPE_Audio, nil, F_ScCapturePinAudio);
            end;
         end
         else begin // rm _AVI
            if not assigned (F_ScCapturePinVideo) then begin
               FindConnectedPinsTypeAndSubtype (F_AVIFileMux, PINDIR_INPUT, @MEDIATYPE_Video, nil, F_ScCapturePinVideo);
            end;

            if not assigned (F_ScCapturePinAudio) then begin
               FindConnectedPinsTypeAndSubtype (F_AVIFileMux, PINDIR_INPUT, @MEDIATYPE_Audio, nil, F_ScCapturePinAudio);
            end;
         end;

         ControlPinByTime (F_ScCapturePinVideo, 'video', TimeStart, TimeStop, 1, 1);
         ControlPinByTime (F_ScCapturePinAudio, 'audio', TimeStart, TimeStop, 1, 1);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ExtractRenderingPins (var  Filter: IBaseFilter; out VideoPin: IPin; out AudioPin: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   VideoFilter, AudioFilter: IBaseFilter;
   RenderIn: IPin;
begin
   try
      Result := False;
      if not CreateInstance(@CLSID_VideoRenderer, IBaseFilter, VideoFilter, 'DummyVideo') then Exit;
      if not AddFilter (VideoFilter, 'DummyVideo') then Exit;
      if not CreateInstance(@CLSID_AudioRender, IBaseFilter, AudioFilter, 'DummyAudio') then Exit;
      if not AddFilter(AudioFilter, 'DummyAudio') then Exit;
      F_CaptureGraphBuilder2.RenderStream (nil, nil, Filter, nil, VideoFilter);
      F_CaptureGraphBuilder2.RenderStream (nil, nil, Filter, nil, AudioFilter);

      if F_CaptureGraphBuilder2.FindPin (VideoFilter, PINDIR_INPUT, nil, nil, False, 0, RenderIn) = S_OK then begin
         if RenderIn.ConnectedTo (VideoPin) = S_OK then begin
            RenderIn.Disconnect;
            VideoPin.Disconnect;
         end;
         RenderIn := nil;
      end;
      if F_CaptureGraphBuilder2.FindPin (AudioFilter, PINDIR_INPUT, nil, nil, False, 0, RenderIn) = S_OK then begin
         if RenderIn.ConnectedTo (AudioPin) = S_OK then begin
            RenderIn.Disconnect;
            AudioPin.Disconnect;
         end;
         RenderIn := nil;
      end;
      Result := True;
   finally
      if assigned (VideoFilter) then begin
         F_GraphBuilder.RemoveFilter (VideoFilter);
         VideoFilter := nil;
      end;
      if assigned (AudioFilter) then begin
         F_GraphBuilder.RemoveFilter (AudioFilter);
         AudioFilter:= nil;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ReencodeOrRecopyFile (ReencodingSettings: pReencodingSettings; CopyingPreallocatedFile: Boolean; UserReencoding: Boolean): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ creates a DestFile compressed file from SourceVideoClip, using the selected video and/or audio compressors
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
   BackupRealRecordingFileName: string;
   AudioStreamBinded: Boolean;
   OleStr: pOleStr;
   VideoPin, AudioPin: IPin;
   OneStreamAdded: Boolean;

   SourceFilter: IBaseFilter;
   Transform: IBaseFilter;
begin
      Result := false;
      OneStreamAdded := False;
      if InitializationStatus <> ipInitialized then Exit;

      FCopyingPreallocData := CopyingPreallocatedFile;
      FReencodeOrRecopyDataSucceeded := False;



      ReencodingSettings^.SourceVideoClip := Trim (ReencodingSettings^.SourceVideoClip);
      ReencodingSettings^.NewVideoClip := Trim (ReencodingSettings^.NewVideoClip);

      if UserReencoding then begin
         if ReencodingSettings^.WMVOutput then begin
            ReencodingSettings^.NewVideoClip := AddOrReplaceFileNameExtension ('wmv', ReencodingSettings^.NewVideoClip);
         end;
      end;

      if LogB (ReencodingSettings^.SourceVideoClip = '', LERROR, e_reencoding, 'source video clip not specified') then Exit;
      if LogB (ReencodingSettings^.NewVideoClip = '', LERROR, e_reencoding, 'new video clip not specified') then Exit;
//      if LogB (not FileExists (ReencodingSettings^.SourceVideoClip), LERROR, e_reencoding, 'source video clip not found') then Exit;
      if LogB (ReencodingSettings^.SourceVideoClip = ReencodingSettings^.NewVideoClip, LERROR, e_reencoding, 'source and destination files must not be identical') then Exit;
      if LogB ((not ReencodingSettings^.IncludeVideoStream) and (not ReencodingSettings^.IncludeAudioStream), LERROR, e_reencoding, 'specify either the video stream, the audio stream or both streams') then Exit;

      if FileExists (ReencodingSettings^.NewVideoClip) then begin
         if LogB (not DeleteFile (ReencodingSettings^.NewVideoClip), LERROR, e_reencoding, 'can''t delete old destination file: ' + ReencodingSettings^.NewVideoClip) then Exit;
      end;

      ForceDirectoriesFromFilePathName (ReencodingSettings^.NewVideoClip);

      ClearGraph (True);

      FLastReencodingSourceFileName := ReencodingSettings^.SourceVideoClip;
      FLastReencodingNewFileName := ReencodingSettings^.NewVideoClip;

      AudioStreamBinded := False;

      ReinitCurrentParams (False);

      if UserReencoding then begin
         FCurrent.RecordingMethod := ReencodingSettings^.Method;
         FCurrent.AudioRecording := ReencodingSettings^.IncludeAudioStream;
         FCurrent.VideoRecording := ReencodingSettings^.IncludeVideoStream;
      end;

      if not (FCurrent.RecordingMethod in [rm_AVI, rm_ASF]) then Exit;

      FCurrent.HoldRecording := (ReencodingSettings^.StartTime <> -1) or (ReencodingSettings^.StopTime <> -1); // used by CompleteGraphBuilding to add the pin stream control

      BackupRealRecordingFileName := FRealRecordingFileName;
      FRealRecordingFileName := ReencodingSettings^.NewVideoClip; { because it's FRealRecordingFileName that is used for free space if EC_PAUSED }
      FReencodingCopyingPreallocatedFile := CopyingPreallocatedFile;
      try
         FGraphType := cs_Reencoding;

         ApplyNotificationSleepTime;

         FOutputFileName := ReencodingSettings^.NewVideoClip;

         if not CreateFilterGraph then Exit;

         if not AddFileWriterFilter then Exit;

         Hr := F_GraphBuilder.AddSourceFilter(OleS(ReencodingSettings^.SourceVideoClip, OleStr), nil, SourceFilter);
         SysFreeString (OleStr);
         if not LogH (Hr, LERROR, e_reencoding, 'source not found or not suitable: ' + ReencodingSettings^.SourceVideoClip) then Exit;

         if (ReencodingSettings^.Method = rm_AVI) and (not ReencodingSettings^.UseVideoCompressor) and (not ReencodingSettings^.UseAudioCompressor) and (not ReencodingSettings^.UseFrameGrabber) then begin
            if ReencodingSettings^.IncludeVideoStream then begin
               F_CaptureGraphBuilder2.RenderStream (nil, nil, SourceFilter, nil, F_AVIFileMux);
            end;
            if ReencodingSettings^.IncludeAudioStream then begin
               F_CaptureGraphBuilder2.RenderStream (nil, nil, SourceFilter, nil, F_AVIFileMux);
            end;
         end
         else begin
            if not ExtractRenderingPins (SourceFilter, VideoPin, AudioPin) then Exit;

            if not assigned (VideoPin) then FCurrent.VideoRecording := False;
            if not assigned (AudioPin) then FCurrent.AudioRecording := False;

            if not InsertASFFilter then Exit;

            if assigned (VideoPin) and ReencodingSettings^.IncludeVideoStream then begin
               if ReencodingSettings^.UseFrameGrabber then begin

                  if FTransformConfig.VideoHalfDeinterlacing then begin
                     if not AddTransform (TransForm, False, True, False, nil, nil, nil) then Exit;
                  end;
                  if FTransformConfig.VideoRotation <> rt_0_deg then begin
                     if not AddTransform (TransForm, True, False, False, nil, nil, nil) then Exit;
                  end;
                  if assigned (Transform) then begin
                     hr:= F_CaptureGraphBuilder2.RenderStream(nil, nil, VideoPin, nil, Transform);
                     if not LogH (Hr, LERROR, e_reencoding, 'can''t insert the frame grabber. Disable it and try again') then Exit;
                     SourceFilter := Transform;
                  end;

                  if FCurrent.FrameGrabber <> fg_Disabled then begin
                     if not CreateGrabberFilter (gf_RGB, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_RGB], nil) then Exit;
                     hr:= F_CaptureGraphBuilder2.RenderStream(nil, nil, VideoPin, nil, FGrabberHandlers[gh_RGB].Grabber);
                     if not LogH (Hr, LERROR, e_reencoding, 'can''t connect the frame grabber. Disable it and try again') then Exit;
                     SourceFilter := FGrabberHandlers[gh_RGB].Grabber;
                  end;
               end;

               if (ReencodingSettings^.UseVideoCompressor) and (ReencodingSettings^.Method = rm_AVI) then begin
                  if not BindAndAddCompressor (F_FilterGraph2, _VideoCompressors, FVideoCompressor, 'VIDC', F_VideoCompressor, True) then Exit;
                  hr:= F_CaptureGraphBuilder2.RenderStream(nil, nil, VideoPin, F_VideoCompressor, F_AVIFileMux);
                  if hr <> S_OK then begin
                     LogB (true, LERROR, e_video_compressor_not_suitable, 'video compressor ' + Intf.VideoCompressorName + ' not suitable');
                     Exit;
                  end;
                  RestoreFilterState (F_VideoCompressor, DeviceRegKeyId (_VideoCompressors, FVideoCompressor));
               end
               else begin
                  if ReencodingSettings^.Method = rm_ASF then begin
                     hr:= F_CaptureGraphBuilder2.RenderStream(nil, nil, VideoPin, nil, F_ASFFileMux);
                  end
                  else begin
                     hr:= F_CaptureGraphBuilder2.RenderStream(nil, nil, VideoPin, nil, F_AVIFileMux);
                  end;
                  if not LogH (Hr, LERROR, e_render_video_stream, 'render Video stream') then Exit;
               end;
               OneStreamAdded := True;
            end;

            if assigned (AudioPin) and ReencodingSettings^.IncludeAudioStream then begin
              if (ReencodingSettings^.UseAudioCompressor) and (ReencodingSettings^.Method = rm_AVI) then begin
                 if not BindAndAddCompressor (F_FilterGraph2, _AudioCompressors, FAudioCompressor, 'AUDC', F_AudioCompressor, True) then Exit;
                 Hr := F_CaptureGraphBuilder2.RenderStream(nil, nil, AudioPin, F_AudioCompressor, F_AVIFileMux);
                 if Failed (Hr) then begin
                    if FindPinInGraphByType (F_GraphBuilder, PINDIR_OUTPUT, True, @MEDIATYPE_Audio, AudioPin, Intf.AudioCompressorName) then begin
                        Hr := F_CaptureGraphBuilder2.RenderStream(nil, nil, AudioPin, F_AudioCompressor, F_AVIFileMux);
                     end;
                  end;
                  LogH (Hr, LERROR, e_audio_compressor_not_suitable, 'audio compressor ' + Intf.AudioCompressorName + ' not suitable');
               end
               else begin
                  if ReencodingSettings^.Method = rm_ASF then begin
                     Hr := F_CaptureGraphBuilder2.RenderStream(nil, nil, AudioPin, nil, F_ASFFileMux);
                  end
                  else begin
                     Hr := F_CaptureGraphBuilder2.RenderStream(nil, nil, AudioPin, nil, F_AVIFileMux);
                  end;
                  if Failed (Hr) then begin
                     if FindPinInGraphByType (F_GraphBuilder, PINDIR_OUTPUT, True, @MEDIATYPE_Audio, AudioPin, Intf.AudioCompressorName) then begin
                        if ReencodingSettings^.Method = rm_ASF then begin
                           Hr := F_CaptureGraphBuilder2.RenderStream(nil, nil, AudioPin, nil, F_ASFFileMux);
                        end
                        else begin
                           Hr := F_CaptureGraphBuilder2.RenderStream(nil, nil, AudioPin, nil, F_AVIFileMux);
                        end;
                     end;
                  end;
                  LogH (Hr, LERROR, e_render_audio_stream, 'cannot reencode audio stream');
               end;
               if assigned (AudioPin) then AudioPin := nil;
               AudioStreamBinded := Succeeded (Hr);
               OneStreamAdded := True;
            end;

            if LogB (not OneStreamAdded, LERROR, e_reencoding, 'incompatible settings: no audio or video stream selected!') then Exit;
         end;

         if not QueryReencodingMediaSeeking then Exit;

         CompleteGraphBuilding (True, ReencodingSettings^.IncludeVideoStream and AudioStreamBinded);

         ChangeGraphState (state_Stopped, 'recom');

         if not ApplyReencodingPositions (ReencodingSettings) then Exit;

         ChangeGraphState (state_Running, 'recom');

         Result := true;
      finally
         if assigned (SourceFilter) then SourceFilter:= nil;
         if assigned (Transform) then Transform := nil;
         if assigned (AudioPin) then AudioPin := nil;
         if assigned (VideoPin) then VideoPin := nil;

         if not Result then begin
            ClearGraph (True);
            if CopyingPreallocatedFile then begin
               if CanInvokeEvent (TPObj(Intf.FOnCopyPreallocDataCompleted)) then Intf.FOnCopyPreallocDataCompleted (Intf, ReencodingSettings^.SourceVideoClip, ReencodingSettings^.NewVideoClip, False);
            end
            else begin
               if CanInvokeEvent (TPObj(Intf.FOnReencodingCompleted)) then Intf.FOnReencodingCompleted (Intf, ReencodingSettings^.SourceVideoClip, ReencodingSettings^.NewVideoClip, False);
            end;
         end;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.ShowFilterDialog (Filter: IUnknown);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ shows any available dialog
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   hr: HResult;
   auuid: TCAGUID;
   Spec: ISpecifyPropertyPages;
begin
      if not assigned (Filter) then Exit;
      hr:= Filter.QueryInterface(ISpecifyPropertyPages, Spec);
      if hr = S_OK then begin
         hr:= Spec.GetPages(auuid);
         if hr = S_OK then begin
            if auuid.cElems > 0 then begin
               OleCreatePropertyFrame(Intf.Handle, 0, 0, nil, 1, @Filter, auuid.cElems, auuid.pElems, 0, 0, nil);
               CoTaskMemFree(auuid.pElems);
            end;
         end;
         Spec := nil;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.WDMDialog (UnkFilter: IUnknown): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Spec: ISpecifyPropertyPages;
   auuid: TCAGUID;
   Hr: HResult;
begin
      Result := false;
      if not assigned (UnkFilter) then Exit;
      hr:= UnkFilter.QueryInterface(ISpecifyPropertyPages, Spec);
      if hr = S_OK then begin
         hr := Spec.GetPages(auuid);
         if hr = S_OK then begin
            if auuid.cElems > 0 then begin
               Result := true;
            end;
         end;
      end;
      if Result then begin
         OleCreatePropertyFrame(Intf.Handle, 30, 30, nil, 1, @UnkFilter, auuid.cElems, auuid.pElems, 0, 0, nil);
         CoTaskMemFree(auuid.pElems);
      end;
      Spec := nil;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AudioDeviceDialog: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   AudioFilter: IBaseFilter;
   BDummy: pBoolean;
begin
      Result := false;
      try
         if InitializationStatus <> ipInitialized then Exit;
         if assigned (F_AudioDevice) then begin
            WDMDialog (F_AudioDevice);
            Exit;
         end;
         if _AudioDevices.FDevices.Count = 0 then Exit;
         if FCurrent.AudioDevice >= _AudioDevices.FDevices.Count then Exit;
         if not Allow ([cs_Down, cs_Preview], LERROR, True) then Exit;
         ReinitCurrentParams (False);
         if not CreateFilterGraph then Exit;
         if not BindAndAddDevice (F_FilterGraph2, _AudioDevices, FCurrent.AudioDevice, '', AudioFilter, False, BDummy, False, '') then Exit;
         WDMDialog (AudioFilter);
         RefreshPreview ('dadd');
         Result := true;
      finally
         if assigned (AudioFilter) then AudioFilter := nil;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.VideoCompressorDialog_InLine: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   AMVfwCompressDialogs: IAMVfwCompressDialogs;
   VideoCaptureOut: IPin;
   CompOut: IPin;
   Ok: Boolean;
   FOldGraphState: TCurrentState;
begin
      Result := false;
      if InitializationStatus <> ipInitialized then Exit;
      if LogB (_VideoDevices.FDevices.Count = 0, LERROR, e_no_video_input_device, 'no video capture device') then Exit;
      if not Allow ([cs_Down, cs_Preview], LERROR, True) then Exit;

      try
         ChangeBusyStateAndCursor (true);
         FOldGraphState := FGraphType;
         ReinitCurrentParams (False);
         if CreateDeviceGraph then begin
            if BindAndAddCompressor (F_FilterGraph2, _VideoCompressors, FVideoCompressor, '', F_VideoCompressor, False) then begin
               if F_CaptureGraphBuilder2.FindPin (F_VideoDevice, PINDIR_OUTPUT, FVideoPinCategoryUsed, nil, true, 0, VideoCaptureOut) = S_OK then begin
                  if InsertExistingFilter (F_VideoCompressor, VideoCaptureOut) then begin
                     if F_CaptureGraphBuilder2.FindPin (F_VideoCompressor, PINDIR_OUTPUT, nil, nil, true, 0, CompOut) = S_OK then begin
                        RestoreFilterState (F_VideoCompressor, DeviceRegKeyId (_VideoCompressors, FVideoCompressor));
                        ChangeBusyStateAndCursor (false);
                        if F_VideoCompressor.QueryInterface (IAMVfwCompressDialogs, AMVfwCompressDialogs) = S_OK then begin
                           AMVfwCompressDialogs.ShowDialog (VfwCompressDialog_Config, Intf.Handle);
                           Ok := True;
                        end
                        else begin
                           Ok := WDMDialog (F_VideoCompressor);
                        end;
                        LogB (not Ok, LWARNING, e_no_dialog_for_this_compressor, 'no dialog for this video compressor');
                        ChangeBusyStateAndCursor (true);
                        SaveFilterState (F_VideoCompressor, DeviceRegKeyId (_VideoCompressors, FVideoCompressor));
                     end;
                  end
                  else begin
                     LogB (True, LERROR, e_video_compressor_not_suitable, 'video compressor not suitable');
                  end;
               end;
            end;
         end;
         ClearGraph (True);
         FGraphType := FOldGraphState;
         RefreshPreview ('dvcd');
      finally
         if assigned (AMVfwCompressDialogs) then AMVfwCompressDialogs:= nil;
         if assigned (VideoCaptureOut) then VideoCaptureOut := nil;
         if assigned (CompOut) then CompOut:= nil;
         ChangeBusyStateAndCursor (false);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.VideoCompressorDialog_Rendered: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   AMVfwCompressDialogs: IAMVfwCompressDialogs;
   VideoCaptureOut: IPin;
   CompOut: IPin;
   FOldGraphState: TCurrentState;
   cw: HWnd;
begin
      Result := false;
      if InitializationStatus <> ipInitialized then Exit;
      if LogB (_VideoDevices.FDevices.Count = 0, LERROR, e_no_video_input_device, 'no video capture device') then Exit;
      if not Allow ([cs_Down, cs_Preview], LERROR, True) then Exit;

      try
         ChangeBusyStateAndCursor (true);
         FOldGraphState := FGraphType;

         ReinitCurrentParams (False);

         FCurrent.AudioRecording := True;
         FCurrent.CompressionMode := cm_CompressOnTheFly;
         FCurrent.RecordingMethod := rm_AVI;
         FGraphType := cs_Recording;
         if CreateBaseGraph then begin
            FOutputFileName := _SyncManager.CreateTempFile ('v~a');
            if AddFileWriterFilter then begin
               if Build_Capture_And_Preview then begin
                  AssignPpSaver (@FPpSaver_MPEGWriter, FMPEGWriterBaseFilterName, RegKeyId + 'MPEGWriter\' + FMPEGWriterBaseFilterName + '\');
                  if assigned (FPpSaver_MPEGWriter.ppInstance) then begin
                     FPpSaver_MPEGWriter.ppInstance.SetRegistrySubKey (FMPEGWriterPropertySet);
                     cw := GetForegroundWindow;
                     BindPpSaver (@FPpSaver_MPEGWriter, F_AVIFileMux);
                     FPpSaver_MPEGWriter.ppInstance.ShowDialog;
                     SetForegroundWindow (cw);
                  end;
                  //WDMDialog (F_AVIFileMux);
               end;
            end;
         end;
         FGraphType := cs_Down;
         ClearGraph (True);
         FGraphType := FOldGraphState;
         RefreshPreview ('dvcd');
      finally
         if assigned (AMVfwCompressDialogs) then AMVfwCompressDialogs:= nil;
         if assigned (VideoCaptureOut) then VideoCaptureOut := nil;
         if assigned (CompOut) then CompOut:= nil;
         ChangeBusyStateAndCursor (false);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.AudioCompressorDialog: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   AMVfwCompressDialogs: IAMVfwCompressDialogs;
   AudioRecordingOut: IPin;
   CompOut: IPin;
   Ok: Boolean;
   FOldGraphState: TCurrentState;
begin
      Result := false;
      if InitializationStatus <> ipInitialized then Exit;
      if LogB (_AudioDevices.FDevices.Count = 0, LERROR, e_no_Audio_input_device, 'no Audio capture device') then Exit;
      if not Allow ([cs_Down, cs_Preview], LERROR, True) then Exit;

      try
         ChangeBusyStateAndCursor (true);
         FOldGraphState := FGraphType;
         ReinitCurrentParams (False);
         if CreateDeviceGraph then begin
            if BindAndAddCompressor (F_FilterGraph2, _AudioCompressors, FAudioCompressor, '', F_AudioCompressor, False) then begin
               if F_CaptureGraphBuilder2.FindPin (F_AudioDevice, PINDIR_OUTPUT, nil, nil, true, 0, AudioRecordingOut) = S_OK then begin
                  if InsertExistingFilter (F_AudioCompressor, AudioRecordingOut) then begin
                     if F_CaptureGraphBuilder2.FindPin (F_AudioCompressor, PINDIR_OUTPUT, nil, nil, true, 0, CompOut) = S_OK then begin
                        RestoreFilterState (F_AudioCompressor, DeviceRegKeyId (_AudioCompressors, FAudioCompressor));
                        ChangeBusyStateAndCursor (false);
                        if F_AudioCompressor.QueryInterface (IAMVfwCompressDialogs, AMVfwCompressDialogs) = S_OK then begin
                           AMVfwCompressDialogs.ShowDialog (VfwCompressDialog_Config, Intf.Handle);
                           Ok := True;
                        end
                        else begin
                           Ok := WDMDialog (F_AudioCompressor);
                        end;
                        LogB (not Ok, LWARNING, e_no_dialog_for_this_compressor, 'no dialog for this audio compressor');
                        ChangeBusyStateAndCursor (true);
                        SaveFilterState (F_AudioCompressor, DeviceRegKeyId (_AudioCompressors, FAudioCompressor));
                     end;
                  end
                  else begin
                     LogB (True, LERROR, e_audio_compressor_not_suitable, 'audio compressor not suitable');
                  end;
               end;
            end;
         end;
         ClearGraph (True);
         FGraphType := FOldGraphState;
         RefreshPreview ('dacd');
      finally
         if assigned (AMVfwCompressDialogs) then AMVfwCompressDialogs:= nil;
         if assigned (AudioRecordingOut) then AudioRecordingOut := nil;
         if assigned (CompOut) then CompOut:= nil;
         ChangeBusyStateAndCursor (false);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.VideoStreamDialog: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      Result := false;
      if InitializationStatus <> ipInitialized then Exit;
      if LogB (_VideoDevices.FDevices.Count = 0, LERROR, e_no_video_input_device, 'no video capture device') then Exit;
      if IsDVSource then Exit;
      if not Allow ([cs_Down, cs_Preview], LERROR, True) then Exit;

      try
         ChangeBusyStateAndCursor (true);
         ReinitCurrentParams (False);
         if CreateBaseGraph then begin
            if assigned (F_AMVideoStreamConfig) then begin
               ChangeBusyStateAndCursor (false);
               ShowFilterDialog (F_AMVideoStreamConfig);
               ChangeBusyStateAndCursor (true);

               VideoStreamConfigGetFormat;
               if VideoStreamConfigGetFrameRate (FFrameRate) then begin
                  FRealFrameRate := FFrameRate;
                  FCurrent.FrameRate := FFrameRate;
               end;
            end;
            ClearGraph (True);
         end;
         Result := true;
      finally
         ChangeBusyStateAndCursor (false);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.VideoDeviceDialog (Dialog: TDialog): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   AMVfwCaptureDialogs: IAMVfwCaptureDialogs;
   Refresh: Boolean;
begin
      Result := false;
      Refresh := False;
      if InitializationStatus <> ipInitialized then Exit;
      if LogB (_VideoDevices.FDevices.Count = 0, LERROR, e_no_video_input_device, 'no video capture device') then Exit;
      if not Allow ([cs_Down, cs_Preview], LERROR, True) then Exit;

      try
         ChangeBusyStateAndCursor (true);

         if BuildNonVisibleVideoGraph then begin
            case Dialog of
               dlg_VideoDevice: begin
                  if assigned (F_VideoDevice) then begin
                     (*if assigned (FPropertyPageSaver) and assigned (FPpSaver_VideoDevice.ppInstance) then begin
                        FPpSaver_VideoDevice.ppInstance.SetIdentifyProperties (FPropertyPageSaver.GetIdentifyProperties);
                        FPpSaver_VideoDevice.ppInstance.ShowDialog;
                     end
                     else begin*)
                        WDMDialog (F_VideoDevice);
                     //end;
                     VideoStreamConfigGetFormat;
                     Refresh := True;
                  end;
               end;

               dlg_VfwFormat: begin
                  if assigned (F_CaptureGraphBuilder2) and assigned (F_VideoDevice) then begin
                     if F_CaptureGraphBuilder2.FindInterface(FVideoPinCategoryUsed, nil, F_VideoDevice, IAMVfwCaptureDialogs, AMVfwCaptureDialogs) = S_OK then begin
                        if AMVfwCaptureDialogs.HasDialog (VfwCaptureDialog_Format) = S_OK then begin
                           ChangeBusyStateAndCursor (false);
                           AMVfwCaptureDialogs.ShowDialog (VfwCaptureDialog_Format, Intf.Handle);
                           ChangeBusyStateAndCursor (true);
                           VideoStreamConfigGetFormat;
                           Refresh := True;
                        end;
                     end;
                  end;
               end;

               dlg_vfwSource: begin
                  if assigned (F_CaptureGraphBuilder2) and assigned (F_VideoDevice) then begin
                     if F_CaptureGraphBuilder2.FindInterface(FVideoPinCategoryUsed, nil, F_VideoDevice, IAMVfwCaptureDialogs, AMVfwCaptureDialogs) = S_OK then begin
                        if AMVfwCaptureDialogs.HasDialog (VfwCaptureDialog_Source) = S_OK then begin
                           ChangeBusyStateAndCursor (false);
                           AMVfwCaptureDialogs.ShowDialog (VfwCaptureDialog_Source, Intf.Handle);
                           ChangeBusyStateAndCursor (true);
                        end;
                     end;
                  end;
               end;

               dlg_vfwDisplay: begin
                  if assigned (F_CaptureGraphBuilder2) and assigned (F_VideoDevice) then begin
                     if F_CaptureGraphBuilder2.FindInterface(FVideoPinCategoryUsed, nil, F_VideoDevice, IAMVfwCaptureDialogs, AMVfwCaptureDialogs) = S_OK then begin
                        if AMVfwCaptureDialogs.HasDialog (VfwCaptureDialog_Display) = S_OK then begin
                           ChangeBusyStateAndCursor (false);
                           AMVfwCaptureDialogs.ShowDialog (VfwCaptureDialog_Display, Intf.Handle);
                           ChangeBusyStateAndCursor (true);
                        end;
                     end;
                  end;
               end;
            end;
            ClearGraph (True);
         end;
         if Refresh then begin
            ReadStoredInterfaceValues;
            if CanInvokeEventWithoutHandle (TPObj(Intf.FOnVideoDeviceSelected)) then Intf.FOnVideoDeviceSelected (Intf);
            //PostEvent (@Intf.FOnVideoDeviceSelected);
         end;
         Result := true;
      finally
         if assigned (AMVfwCaptureDialogs) then AMVfwCaptureDialogs := nil;
         ChangeBusyStateAndCursor (false);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.CheckApplySetAudioVideoDevices;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if not FApplyingSetVideoDeviceDone then begin
      ApplySetVideoDevice;
   end;
   if not FApplyingSetAudioDeviceDone then begin
      ApplySetAudioDevice;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ApplySetVideoDevice: Boolean;
{ loads the current video capture device settings from registry (if not done discovers the new device)
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   w, h: LongInt;
   FAssociatedAudioDevice: LongInt;
begin
   Result := False;
   if InitializationStatus <> ipInitialized then Exit;
   if FVideoSource <> vs_VideoCaptureDevice then Exit;
   if _VideoDevices.Count < 1 then begin
      PostEvent (@Intf.FOnNoVideoDevices);
      Exit;
   end;
   if FVideoDevice < 0 then Exit;
   if NoDevicesOrIndexOutOfRange (FVideoDevice, _VideoDevices.Count, 'video capture device') then Exit;

   if FApplyingSetVideoDevice then Exit;

   ChangeBusyStateAndCursor (true);

   SaveCurrentVideoDeviceSettingsToRegistry;

   FApplyingSetVideoDevice := true;

   FCurrent.VideoDevice := FVideoDevice;

   InitVideoRegSave (@FVideoRegSave);

   if not LoadCurrentVideoDeviceSettingsFromRegistry then begin
      InitVideoRegSave (@FVideoRegSave); { something wrong in the registry, must re-discover }
   end;

   FVideoRegSave[_DeviceDiscovered].b := LoadSettingsAndVideoStreamConfigCapabilitiesFromRegistry;
   if not FVideoRegSave[_DeviceDiscovered].b then begin
      FVideoRegSave[_DeviceDiscovered].b := DiscoverVideoDevice;
   end;

   SaveCurrentVideoDeviceSettingsToRegistry;

   ChangeBusyStateAndCursor (false);

   if FVideoRegSave[_DeviceDiscovered].b then begin
      if DecodeVideoSizeUsingDefault (-1, w, h) then begin
         FVideoSourceWidth := w;
         FVideoSourceHeight := h;
      end
      else begin
         FVideoSourceWidth := 320;
         FVideoSourceHeight := 240;
      end;

      ResizeVideoWindows (True);

      WriteLog (nil, sBlue, 'call change video device');
      if CanInvokeEventWithoutHandle (TPObj(Intf.FOnVideoDeviceSelected)) then Intf.FOnVideoDeviceSelected (Intf);
      //PostEvent (@Intf.FOnVideoDeviceSelected);
      WriteLog (nil, sBlue, 'end call change video device');

      if CanAssociateAudioAndVideoDevices then begin
         if FVideoRegSave[_AudioDeviceAssociated].s <> '' then begin
            FAssociatedAudioDevice := ReturnIndexFromTextList (_AudioDevices.List, FVideoRegSave[_AudioDeviceAssociated].s);
            if FAssociatedAudioDevice <> -1 then begin
               FAudioDevice := FAssociatedAudioDevice;
               ApplySetAudioDevice;
            end;
         end
         else if FCurrent.AudioDevice <> -1 then begin
            FVideoRegSave[_AudioDeviceAssociated].s := _AudioDevices.FDevices[FCurrent.AudioDevice];
         end;
         { NotifyAudioAndVideoDevicesAssociated; }
      end;
   end;

   (*if assigned (FPropertyPageSaver) then begin
      AssignPpSaver (@FPpSaver_VideoDevice, _VideoDevices.DeviceName (FCurrent.VideoDevice), DeviceRegKeyId (_VideoDevices, FCurrent.VideoDevice));
   end;*)

   FApplyingSetVideoDevice:= false;
   Result := FVideoRegSave[_DeviceDiscovered].b;

   FApplyingSetVideoDeviceDone := True;
end;

{
procedure TVdgr.NotifyAudioAndVideoDevicesAssociated;
begin
   if (FGraphType = cs_Down)
    or ((FGraphType in [cs_Preview, cs_Recording]) and assigned (F_AudioDevice)) then begin
      if (Intf.GetAudioInput >= 0) and (Intf.GetAudioInput < Intf.GetAudioInputsCount) then begin
         LogB (True, LINFO, i_audio_device_associated_to_video_device, '"' + Intf.GetVideoDeviceName + '"' + #13#10 + 'associated to ' + '"' + Intf.GetAudioDeviceName + '"' + #13#10 + 'on input "' + GetAudioInputName + '"');
      end
      else begin
         LogB (True, LINFO, i_audio_device_associated_to_video_device, Intf.GetVideoDeviceName + ' associated to ' + Intf.GetAudioDeviceName);
      end;
   end;
end;
}

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ApplySetAudioDevice: Boolean;
{ loads the current Audio settings from registry (if not done discovers the new device)
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   RegKey: TRegistry2;
   LoadFromRegistry: Boolean;
begin
   Result := False;
   if InitializationStatus <> ipInitialized then Exit;
   if FVideoSource <> vs_VideoCaptureDevice then Exit;
   if _AudioDevices.Count < 1 then Exit;
   if FAudioDevice < 0 then Exit;
   if NoDevicesOrIndexOutOfRange (FAudioDevice, _AudioDevices.Count, 'audio capture device') then Exit;

   if FApplyingSetAudioDevice then Exit;
   FApplyingSetAudioDevice := True;

   ChangeBusyStateAndCursor (true);

   SaveCurrentAudioDeviceSettingsToRegistry;

   FCurrent.AudioDevice := FAudioDevice;

   InitAudioRegSave (@FAudioRegSave);

   RegKey := TRegistry2.Create (False);
   LoadFromRegistry := RegKey.KeyExists (DeviceRegKeyId (_AudioDevices, FCurrent.AudioDevice));
   RegKey.Free;

   if LoadFromRegistry then begin
      LoadCurrentAudioDeviceSettingsFromRegistry;
   end;

   if not FAudioRegSave[_A_DeviceDiscovered].b then begin
      if DiscoverAudioDevice then begin
         FAudioRegSave[_A_DeviceDiscovered].b := true;
      end;
   end;
   SaveCurrentAudioDeviceSettingsToRegistry;

   if FAudioRegSave[_A_DeviceDiscovered].b then begin

      if CanAssociateAudioAndVideoDevices then begin
         FVideoRegSave[_AudioDeviceAssociated].s := _AudioDevices.FDevices[FCurrent.AudioDevice];
      end;

      ActivateAudioInputAndSetValues;

      if CanInvokeEventWithoutHandle (TPObj(Intf.FOnAudioDeviceSelected)) then Intf.FOnAudioDeviceSelected (Intf);
      //PostEvent (@Intf.FOnAudioDeviceSelected);
   end;

   ChangeBusyStateAndCursor (false);

   Result := FAudioRegSave[_A_DeviceDiscovered].b;
   FApplyingSetAudioDevice := False;
   FApplyingSetAudioDeviceDone := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.StartPlayerForwards;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      if LogB (FGraphType <> cs_Playback, LERROR, w_not_playing, 'no clip opened') then Exit;
      if LogB (FCurrent.Networkstreaming <> ns_Disabled, LERROR, e_not_allowed_during_network_streaming, 'not allowed during network streaming') then Exit;
      if LogB (not FPlayerCanSeek, LWARNING, e_failed_to_play_backwards, 'this clip cannot be played forwards') then Exit;
      if not FGraphAccessAllowed then Exit;

      FCurrentFrameData.PlayerEmulateSpeedRatio := False;
      FCurrentFrameData.PLayerSeekBackwards := False;

      if not FPlayerBackwardTimerEnabled then begin
         FPlayerBackwardTimerEnabled := True;
         PostCommand (WMPlayStartByStep);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.StartPlayerBackwards;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      if LogB (FGraphType <> cs_Playback, LERROR, w_not_playing, 'no clip opened') then Exit;
      if LogB (FCurrent.Networkstreaming <> ns_Disabled, LERROR, e_not_allowed_during_network_streaming, 'not allowed during network streaming') then Exit;
      if LogB (not FPlayerCanSeek, LWARNING, e_failed_to_play_backwards, 'this clip cannot be played backwards') then Exit;
      if not FGraphAccessAllowed then Exit;

      FCurrentFrameData.PlayerEmulateSpeedRatio := False;
      FCurrentFrameData.PLayerSeekBackwards := True;

      if not FPlayerBackwardTimerEnabled then begin
         FPlayerBackwardTimerEnabled := True;
         PostCommand (WMPlayStartByStep);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.RunEmulatedPlayback;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
     if not FGraphAccessAllowed then Exit;
     if FFilterState <> state_Paused then begin
        ChangeGraphState (State_Paused, 'spf');
      end;
      FCurrentFrameData.PlayerEmulateSpeedRatio := True;
      FCurrentFrameData.PLayerSeekBackwards := False;

      if not FPlayerBackwardTimerEnabled then begin
         FPlayerBackwardTimerEnabled:= True;
         PostCommand (WMPlayStartByStep);
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertASFRecording (UseSmartTee: Boolean; var VideoOut: IPin): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
   OleStr: pOleStr;
   PreviewOut: IPin;
   InfTee: IBaseFilter;
begin
   try
      Result := False;

      if assigned (F_ASFFileMux) then Exit;

      if UseSmartTee then begin
         if not InsertSmartTee (@CLSID_SmartTee, SingleText('Tee1'), VideoOut, VideoOut, PreviewOut) then Exit;
      end
      else begin
         if not InsertFilterInlineGetFilter (@CLSID_InfTee, SingleText('Tee2'), InfTee, nil, VideoOut) then Exit;
      end;
      hr := F_CaptureGraphBuilder2.SetOutputFileName(@MEDIASubtype_ASF, OleS(_SyncManager.CreateTempFile ('v~b'), OleStr), F_ASFFileMux, F_ASFFileSink);
      SysFreeString (OleStr);
      if not LogH (Hr, LTRACE, e_failed_to_create_file, 'cannot create asf output file name') then Exit;
      if not InsertASFFilter then Exit;
      if Failed (F_CaptureGraphBuilder2.RenderStream (nil, nil, VideoOut, nil, F_ASFFileMux)) then Exit;
      if not assigned (InfTee) then begin
         VideoOut := PreviewOut;
      end
      else begin
         VideoOut := nil;
         if Failed (F_CaptureGraphBuilder2.FindPin (InfTee, PINDIR_OUTPUT, nil, nil, True, 0, VideoOut)) then Exit;
      end;
      Result := True;
   finally
      //if assigned (PreviewOut) then CaptureOut := nil;
      if assigned (InfTee) then InfTee := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.IsPlayerStreaming: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := (FGraphType = cs_Playback) and (FCurrent.NetworkStreaming <> ns_disabled);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.IdentifyCodecs;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pEnumFilters: iEnumFilters;
   cFetched: ULONG;
   pFilter: IBaseFilter;
   hr: HResult;
   FilterInfo: TFilterInfo;
   EnumPins: IEnumPins;
   InCount, OutCount: LongInt;
   Done: Boolean;
   ppPin: IPin;
   PinDir: TPin_Direction;
   n: LongInt;
   FilterName: String;
   mt: TAM_MEDIA_TYPE;
   MajorType: TGUID;
begin
    FPlayerAudioCodec := 'none';
    FPlayerVideoCodec := 'none';

    if not assigned (F_GraphBuilder) then Exit;

    hr := F_GraphBuilder.EnumFilters(pEnumFilters);
    if (hr = S_OK) and assigned (pEnumFilters) then begin
       pEnumFilters.Reset;
       while pEnumFilters.Next(1, pFilter, @cFetched) = S_OK do begin
          if assigned (pFilter) then begin
             if pFilter.QueryFilterInfo (FilterInfo) = S_OK then begin
                InCount := 0;
                OutCount := 0;
                if Succeeded (pFilter.EnumPins(EnumPins)) then begin
                   Done := false;
                   while(EnumPins.Next(1, ppPin, @n) = S_OK)  and (not Done) do begin
                      if assigned (ppPin) then begin
                         if succeeded (ppPin.QueryDirection (PinDir)) then begin
                            case PinDir of
                               PINDIR_INPUT:  begin
                                                 inc (InCount);
                                              end;
                               PINDIR_OUTPUT: begin
                                                 inc (OutCount);
                                                 if succeeded (ppPin.ConnectionMediaType (@mt)) then begin
                                                    MajorType := mt.majortype;
                                                    FreeMediaType (@mt);
                                                 end;
                                              end;
                            end;
                         end;
                         ppPin := nil;
                      end
                      else begin
                         Done := True;
                      end;
                   end;
                   EnumPins := nil;
                end;
                if (InCount = 1) and (OutCount = 1) then begin
                   FilterName := FilterInfo.achName;
                   if (pos ('Splitter', FilterName) = 0) and (pos ('Color Space Converter', FilterName) = 0) and (copy (FilterName, 1, 3) <> 'GRB') then begin
                      if IsEqualGuid (MajorType, MEDIATYPE_Audio) then begin
                         FPlayerAudioCodec := FilterInfo.achName;
                      end
                      else begin
                         FPlayerVideoCodec := FilterInfo.achName;
                      end;
                   end;
                end;
                FilterInfo.pGraph := nil;
             end;
             pFilter:= nil;
          end;
       end;
       pEnumFilters:= nil;
    end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.Build_File_Rendering (FileNameOrUrl: String; InsertAudioTee: Boolean; var VideoOut: IPin; var AudioOut: IPin) : Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
   OleStr: pWideChar;
   Filter: IBaseFilter;
   RenderIn: IPin;
   InfTee: IBaseFilter;
   PinInfo: TPin_Info;
   ClassID: TGUID;
   pstart, pstop : int64;
begin
   Result := False;
   try
      Hr := F_GraphBuilder.RenderFile (OleS(FileNameOrUrl, OleStr), nil);
      SysFreeString (OleStr);
      if not LogH (Hr, LTRACE, e_failed_to_render_file, 'cannot render file') then begin
         Exit;
      end;

      if FGraphType = cs_Playback then begin
         QueryPlayerMediaSeeking; { need renderer, must NOT be moved }
      end
      else begin // preview or recording
         if Succeeded (F_GraphBuilder.QueryInterface (IMediaSeeking, F_MediaSeeking)) then begin
            if (FVideoSource_FileOrURL_StartTime > 0) or (FVideoSource_FileOrURL_StopTime > -1) then begin
               if FVideoSource_FileOrURL_StartTime > 0 then begin
                  pStart := FVideoSource_FileOrURL_StartTime;
               end
               else begin
                  pstart := 0;
               end;
               if FVideoSource_FileOrURL_StopTime > 0 then begin
                  pStop := FVideoSource_FileOrURL_StopTime;
               end
               else begin
                  pstop := high(int64);
               end;
               F_MediaSeeking.SetPositions (@pStart, AM_SEEKING_AbsolutePositioning, @pStop, AM_SEEKING_AbsolutePositioning);
            end;
         end;
      end;

      if FindRenderer(@MEDIATYPE_Audio, Filter, RenderIn, False) then begin
         if FGraphType = cs_Playback then begin
            FIsPlayerAudioStreamAvailable := ts_True;
            if (not FCurrent.PlayerAudioRendering) or IsPlayerStreaming then begin
               if RenderIn.ConnectedTo (AudioOut) = S_OK then begin
                  AudioOut.Disconnect;
                  RenderIn.Disconnect;
                  if InsertAudioTee then begin
                     if not InsertFilterInlineGetFilter (@CLSID_InfTee, SingleText('Inf Tee Vid'), InfTee, nil, AudioOut) then Exit;
                     if Failed (AudioOut.Connect (RenderIn, nil)) then Exit;
                     if Failed (F_CaptureGraphBuilder2.FindPin (InfTee, PINDIR_OUTPUT, nil, nil, true, 0, AudioOut)) then Exit;
                  end
                  else begin
                     F_GraphBuilder.RemoveFilter (Filter);
                     InsertNullRenderer (AudioOut, False);
                  end;
               end;
            end;
         end
         else begin // preview / recording, will be handled later
            if RenderIn.ConnectedTo (AudioOut) = S_OK then begin
               AudioOut.Disconnect;
               RenderIn.Disconnect;
               F_GraphBuilder.RemoveFilter (Filter);
            end;
         end;
         RenderIn := nil;
         Filter := nil;
      end
      else begin
         FIsPlayerAudioStreamAvailable := ts_False;
         FCurrent.PlayerAudioRendering := False;
      end;

      if FindRenderer(@MEDIATYPE_Video, Filter, RenderIn, True) then begin
         if RenderIn.ConnectedTo (VideoOut) = S_OK then begin
            RenderIn.Disconnect;
            RenderIn := nil;
            VideoOut.Disconnect;
            F_GraphBuilder.RemoveFilter (Filter);
            Filter := nil;
            if VideoOut.QueryPinInfo (PinInfo) = S_OK then begin
               if assigned (PinInfo.pFilter) then begin
                  if PinInfo.pFilter.GetClassID (ClassID) = S_OK then begin
                     if _IsEqualGUID (@ClassID, @CLSID_Colour) then begin
                        VideoOut := nil;
                        RenderIn := nil;
                        if F_CaptureGraphBuilder2.FindPin (PinInfo.pFilter, PINDIR_INPUT, nil, nil, false, 0, RenderIn) = S_OK then begin
                           if RenderIn.ConnectedTo (VideoOut) = S_OK then begin
                              RenderIn.Disconnect;
                              VideoOut.Disconnect;
                              RenderIn := nil;
                              F_GraphBuilder.RemoveFilter (PinInfo.pFilter);
                           end;
                        end;
                     end;
                  end;
                  PinInfo.pFilter := nil;
               end;
            end;
         end;
      end;
      Result := True;
   finally
      if assigned (Filter) then Filter := nil;
      if assigned (RenderIn) then RenderIn := nil;
      if assigned (InfTee) then InfTee := nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.Build_Player_Rendering : Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ opens the player.
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   pOleS: pWideChar;

   VideoOut: IPin;
   Filter: IBaseFilter;
   RenderIn: IPin;
   DVDec: IIPDVDec;
   AudioOut: IPin;
   FilterIn: Ipin;
   NewCodec: IBaseFilter;
   NewCodecOk: Boolean;
   NewCodecName: String;
   NewCodecGUID: TGUID;
   DvIn, OutToDvIn: IPin;
   OleStr: pOleStr;
   DummyBool: Boolean;
   HR: HRESULT;
begin

   Result := False;
   try
      PostEvent (@Intf.FOnReinitializing);

      ChangeBusyStateAndCursor (true);

      FPlayerFrameCount := 0;
      FPlayerBufferingData:= False;

      FGraphType := cs_Playback;

      { CheckSequentialFileCount; }
      ApplyNotificationSleepTime;

      ReinitCurrentParams (False);

      CreateFilterGraph;

      //modify by Terry at 2010-06-12 for changed MTV audio channel
      a := TAudioFilter.Create(HR) ;
      (F_GraphBuilder as IGraphBuilder).AddFilter(a as IBaseFilter,  'Audio Filter');
//      a.put_State( asAll );
      //end modify

      if FPlayerForcedCodec <> '' then begin
         if FPlayerForcedCodec[1] = '{' then begin
            NewCodecGUID := StringToGUID (FPlayerForcedCodec);
            NewCodecOk := BindFilterFromCLSID (@CLSID_LegacyAmFilterCategory, @NewCodecGUID, NewCodecName, NewCodec);
         end
         else begin
            NewCodecOk := BindFilterFromSubname (@CLSID_LegacyAmFilterCategory, FPlayerForcedCodec, newCodecName, NewCodec);
         end;
         if NewCodecOk then begin
            NewCodecOk := F_GraphBuilder.AddFilter (NewCodec, OleS(NewCodecName, OleStr)) = S_OK;
            SysFreeString (OleStr);
            LogB (not newCodecOk, LERROR, e_failed_to_bind_codec, 'cannot bind player codec');
         end
         else begin
            LogB (true, LERROR, e_failed_to_bind_codec, 'player codec not found');
         end;
      end;

      { FPlayerFileName := 'mms://www.datastead.com/demo/demo.wmv'; }

      if not Build_File_Rendering (FPlayerFileName, (FCurrent.PlayerAudioRendering and IsPlayerStreaming), VideoOut, AudioOut) then Exit;

      FGlobalRegSave[_LastClipPlayed].s := FPlayerFilename;

     if not assigned (VideoOut) then begin  // no video stream
      FCurrent.FrameGrabber := fg_Disabled;
     end
     else begin

      if FCurrentFrameData.PlayerEmulateSpeedRatioTickCountInterval > 0 then begin
         { if not InsertGrabberFilter (VideoOut, gf_Locking, @FGrabberHandlers[gh_LockingVideo]) then Exit; }
      end;

      InsertThirdPartyFilters (tpf_VideoSource, VideoOut);
      InsertThirdPartyFilters (tpf_VideoCapture, VideoOut);

      if FTransformConfig.VideoHalfDeinterlacing then begin
         InsertTransform (VideoOut, False, True, False, nil, nil, nil);
      end;
      if FTransformConfig.VideoRotation <> rt_0_deg then begin
         InsertTransform (VideoOut, True, False, False, nil, nil, nil);
      end;

      if FCurrent.FrameGrabber <> fg_Disabled then begin
         if not InsertGrabberFilter (VideoOut, gf_RGB, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_RGB], nil) then begin
            FCurrent.FrameGrabber := fg_Disabled;
            FPlayerFailedToInsertFrameGrabber := True;
         end;
         LogB (FCurrent.FrameGrabber = fg_Disabled, LERROR, e_failed_to_bind_frame_grabber, 'failed to bind the frame grabber, it is probable that the current decompressor does not accept uncompressed RGB, you install another decompressor and use the PlayerForcedCodec property if necessary.');
      end;

      FCurrentFrameData.DVDataAvailable := False;

      pOleS := stringToOleStr ('DV Video Decoder');
      Filter := nil;
      if F_GraphBuilder.FindFilterByName (pOleS, Filter) = S_OK then begin

         if Succeeded (F_CaptureGraphBuilder2.FindPin (Filter, PINDIR_INPUT, nil, nil, false, 0, DvIn)) then begin
            if Succeeded (DvIn.ConnectedTo (OutToDvIn)) then begin
               DvIn.Disconnect;
               OutToDvIn.Disconnect;
               InsertGrabberFilter (OutToDvIn, gf_DVData, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_NotifyDVData], nil);
               OutToDvIn.Connect (DvIn, nil);
               OutToDvIn := nil;
               FCurrentFrameData.DVDataAvailable := True;
            end;
            DvIn := nil;
         end;
         if Filter.QueryInterface (IIPDVDec, DVDec) = S_OK then begin
            case FPlayerDVSize of
               dvFull: DvDec.put_IPDisplay (DVRESOLUTION_FULL);
               dvHalf: DvDec.put_IPDisplay (DVRESOLUTION_HALF);
               dvQuarter: DvDec.put_IPDisplay (DVRESOLUTION_QUARTER);
               dvDC: DvDec.put_IPDisplay (DVRESOLUTION_DC);
            end;
            DvDec := nil;
         end;
         Filter := nil;
         if FCurrent.VideoRenderer = vr_VMR9 then begin
            FCurrent.VideoRenderer := vr_VMR7;
         end;
      end;
      sysFreeString (pOleS);


      if IsPlayerStreaming then begin
         FCurrent.AudioRecording := (FIsPlayerAudioStreamAvailable = ts_True) and (FCurrent.PlayerAudioRendering);
         if not InsertASFRecording (True, VideoOut) then Exit;
         if (FCurrent.AudioRecording) and assigned (AudioOut) then begin
            if assigned (F_ASFFileMux) then begin
               if Failed (F_CaptureGraphBuilder2.RenderStream (nil, nil, AudioOut, nil, F_ASFFileMux)) then Exit;
            end;
         end;
      end;

      InsertThirdPartyFilters (tpf_VideoPreview, VideoOut);

      if not InsertVideoDisplay (VideoOut) then begin
         if AddRendererFilterGetPin (SingleText ('rndr'), @FVideoRendererW, RenderIn, False, DummyBool) then begin
             if Succeeded (F_GraphBuilder.RenderFile (OleS(FPlayerFilename, OleStr), nil)) then begin
                RetrieveVideoFormatInfo (RenderIn);
            end;
         end;
      end;

      FPlayerBufferingData:= False;
     end;
      Result := CompleteGraphBuilding (True, False);

      IdentifyCodecs;

      FCurrentFrameData.InitialFrameTime := 0;
      FCurrentFrameData.InitialFrameNumber := 0;

      //FlushMessages; ZZZZZ

      if assigned (FPlayerTrackBar) then begin
         FPlayerTrackBar.OnChange := PlayerTrackBarChange;
         FPlayerTrackBar.Min := 1;
         FPlayerTrackBar.Frequency := 1;
         FPlayerTrackBar.PageSize := 1;
         FPlayerTrackBar.Max := FPlayerFrameCount;
      end;

      //ShowDisplays;
      isV := (Assigned(FVideoWindow.FAssociatedRenderer) and FVideoWindow.FActivated) or
             (Assigned (FVideoWindow2.FAssociatedRenderer) and FVideoWindow2.FActivated);


      SetGraphStateBuilt;

   finally

      if assigned (RenderIn) then RenderIn := nil;
      if assigned (Filter) then Filter := nil;
      if assigned (VideoOut) then VideoOut := nil;
      if assigned (DVDec) then DVDec := nil;
      if assigned (FilterIn) then FilterIn := nil;
      if assigned (NewCodec) then NewCodec := nil;

      if not Result then begin
         LogH (E_FAIL, LERROR, e_failed_to_render_file, 'cannot play ' + FPlayerFileName);
         LogTrees;
         ClearGraph (True);
      end;
      ChangeBusyStateAndCursor (false);

      if FGraphState = gs_CanActivate then begin
         FGraphState := gs_Activating;
         ActivateGraph;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.FileMuxSettings (SetMasterStream: Boolean);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ set the AVI file options of the File F_FileMux
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Hr: HResult;
   ConfigAVIMux: IConfigAviMux;
   Interleaving: IConfigInterleaving;
   cw: Hwnd;
begin
      try
         if not assigned (F_AVIFileMux)  then Exit;

         if FMPEGWriterFilter = '' then begin
            hr:= F_AVIFileMux.QueryInterface(IConfigAviMux, ConfigAVIMux);
            if LogH (Hr, LTRACE, e_query_config_avi_mux, 'query config avi F_AVIFileMux') then begin

               hr := ConfigAVIMux.SetOutputCompatibilityIndex(not FAVIFormatOpenDML);
               LogH (Hr, LERROR, e_set_output_compatibility_index, 'set output Compatibility Index');

               if SetMasterStream then begin
                  hr:= ConfigAVIMux.SetMasterStream(DecodeMasterStream (FUseMasterStream));
                  LogH (Hr, LERROR, e_set_master_stream, 'set master stream');
               end;
            end;

            if FCurrent.AudioRecording then begin
               if FCurrent.RecordingMethod = rm_AVI then begin
                  hr := F_AVIFileMux.QueryInterface(IConfigInterleaving, Interleaving);
                  if hr = S_OK then begin
                     hr := Interleaving.put_Mode(im_None);
                  end;
                  LogH (Hr, LERROR, e_set_interleaving_mode, 'set interleaving mode');
               end;
            end;
         end
         else begin
            if assigned (FPropertyPageSaver) then begin
               AssignPpSaver (@FPpSaver_MPEGWriter, FMPEGWriterBaseFilterName, RegKeyId + 'MPEGWriter\' + FMPEGWriterBaseFilterName + '\');
               if assigned (FPpSaver_MPEGWriter.ppInstance) then begin
                  FPpSaver_MPEGWriter.ppInstance.SetRegistrySubKey (FMPEGWriterPropertySet);
                  cw := GetForegroundWindow;
                  BindPpSaver (@FPpSaver_MPEGWriter, F_AVIFileMux);
                  //if dlg_VideoCompressor in FShowDialogs then begin
                  //   FPpSaver_MPEGWriter.ppInstance.ShowDialog;
                  //end;
                  SetForegroundWindow (cw);
               end;
            end
            else begin
               //if dlg_VideoCompressor in FShowDialogs then begin
               //   LogB (True, LWARNING, w_filter_does_not_save_properties, 'this filter does not save its properties, using TPropertyPageSaver is recommended');
               //   WDMDialog (F_AVIFileMux);
               //end;
            end;
         end;
      finally
         if assigned (ConfigAVIMux) then ConfigAVIMux := nil;
         if assigned (Interleaving) then Interleaving:= nil;
      end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertGrabberFilterDerived (CLSID_IntermFilter: pGUID; var OutputPin: IPin; GrabberFilterType: TGrabberFilterType; GrabberHandler: pGrabberHandler): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   InfTee: IBaseFilter;
   IntermFilter: IBaseFilter;

begin
   Result := False;
   try
      if not InsertFilterInlineGetFilter (@CLSID_InfTee, SingleText('Inf Tee Vid'), InfTee, nil, OutputPin) then Exit;
      if assigned (CLSID_IntermFilter) then begin
         if not InsertFilterInlineGetFilter (CLSID_IntermFilter, SingleText ('Interm Filter'), IntermFilter, @MEDIATYPE_Video, OutputPin) then Exit;
         ChangeDVResolution (IntermFilter); { if DV }
      end;
      if not InsertGrabberFilter (OutputPin, gf_RGB, FCurrent.FrameGrabberRGBFormat, @FGrabberHandlers[gh_RGB], nil) then Exit;
      InsertNullRenderer (OutputPin, False);
      OutputPin := nil;
      if not F_CaptureGraphBuilder2.FindPin (InfTee, PINDIR_OUTPUT, nil, nil, true, 0, OutputPin) = S_OK then Exit;
      Result := True;
   finally
      if assigned (InfTee) then InfTee := nil;
      if assigned (IntermFilter) then IntermFilter:= nil;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.CreateGrabberFilter (GrabberFilterType: TGrabberFilterType; FrameGrabberRGBFormat: TFrameGrabberRGBFormat; GrabberHandler: pGrabberHandler; UseConnectionMediaType: PAM_MEDIA_TYPE): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FilterName: String;

   procedure SetFilterName;
   begin
      case GrabberFilterType of
         gf_Sample: begin
            FilterName       := 'GRB_Sample';
         end;
         gf_Dummy: begin
            FilterName       := 'GRB_Dummy';
         end;
         gf_Notify: begin
            FilterName       := 'GRB_Notify';
         end;
         gf_RGB: begin
            FilterName       := 'GRB_RGB';
         end;
         gf_DVData: begin
            FilterName       := 'GRB_DvData';
         end;
         gf_Lock: begin
            FilterName       := 'GRB_Lock';
         end;
         gf_LockAndShift: begin
            FilterName       := 'GRB_LockAndShift';
         end;
         gf_ClearFrame: begin
            FilterName       := 'GRB_Clear';
         end;
         { gf_CxPreferredFormat: begin  gf_CxPreferredFormat exists ONLY FOR TESTS >= gf_CxPreferredFormat
            FilterName := 'GRB_CxPrefFmt';
         end; }
      end;
   end;
begin
   Result := False;
   try
      ClearGrabberHandler (GrabberHandler, false);

      SetFilterName;

      if GrabberFilterType >= gf_RGB then begin
         if not LoadFilter (nil, 'v~f', @LoadArray, GrabberHandler^.Handle, 'CreateLocalGrabberInstance', GrabberHandler^.Grabber, SingleText(FilterName)) then Exit;
      end
      else begin
         if not LoadFilter (nil, 'v~f', @LoadArray, GrabberHandler^.Handle, 'CreateLocalGrabberInstanceNoModify', GrabberHandler^.Grabber, SingleText(FilterName)) then Exit;
      end;

      if GrabberHandler^.Grabber.QueryInterface (IFrameSample, GrabberHandler^.FrameSample) <> S_OK then Exit;
      if GrabberHandler^.FrameSample.Configure (GrabberFilterType, GrabberHandler^.Control) <> S_OK then Exit;

      GrabberHandler^.Control^.SampleGrabberEnabled := True;
      GrabberHandler^.Control^.NotifyFrameEnabled := True;
      GrabberHandler^.Control^.NotifyDVDataEnabled := True;
      GrabberHandler^.Control^.CanCaptureAndNotifyFrame := True; // by default, can be disabled later

      if LogB (GrabberHandler^.Control^.CheckVersion <> TVideoGrabberDXFiltersVersion, LERROR, e_TVideoGrabber_Filter_obsolete, 'TVideoGrabber Dx filter obsolete') then Exit;

      GrabberHandler^.Control^.Component := Self;

      if (FMultiplexedRole = mr_MultiplexedMaster) and (FGraphType in [cs_Preview, cs_Recording]) then begin
         GrabberHandler^.Control^.ProcessRGBFrame := @GrabberProcessRGBFrameMultiplexed;
      end
      else
      begin
         GrabberHandler^.Control^.ProcessRGBFrame := @GrabberProcessRGBFrame;
      end;

      GrabberHandler^.Control^.NotifyFrame := @GrabberProcessNotifyFrame;
      GrabberHandler^.Control^.NotifyDVData := @GrabberNotifyDVData;
      if FSampleCaptureAsyncEvent then begin
         GrabberHandler^.Control^.SampleGrabber := @GrabberProcessSampleAsync;
      end
      else begin
         GrabberHandler^.Control^.SampleGrabber := @GrabberProcessSample;
      end;
      GrabberHandler^.Control^.BufferCount := FFrameBuffers;
      GrabberHandler^.Control^.LockState := False;
      GrabberHandler^.Control^.ClearFrame := false;

      Windows.CopyMemory (@GrabberHandler^.Control^.Effects, @FVideoEffects, SizeOf (TVideoEffects));

      GrabberHandler^.Control^.RowSize := 0;
      GrabberHandler^.Control^.AutoSelectRGBFormat := False; { not used for the moment }
      GrabberHandler^.Control^.UpdateFrameRate := False;
      GrabberHandler^.Control^.ForceRGBFormat := FCurrent.FrameGrabberRGBFormat;

      SetFilterName;

      if not AddFilter (GrabberHandler^.Grabber, SingleText(FilterName)) then Exit;

      Result := True;
   finally
      if not Result then begin
         if assigned (GrabberHandler^.Grabber) then begin
            F_GraphBuilder.RemoveFilter (GrabberHandler^.Grabber);
            ClearGrabberHandler (GrabberHandler, False);
         end;
      end;
      LogB (not Result, LTRACE, e_failed, 'insert grabber filter');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertGrabberFilter (var OutputPin: IPin; GrabberFilterType: TGrabberFilterType; FrameGrabberRGBFormat: TFrameGrabberRGBFormat; GrabberHandler: pGrabberHandler; UseConnectionMediaType: PAM_MEDIA_TYPE): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   FilterIn: IPin;
   FilterOut: IPin;
begin
   Result := False;
   try
      if (GrabberFilterType = gf_RGB) and (not FCurrent.MotionDetectorEnabled) then begin
            EnableDisableVideoEffects;
            EnableDisableVideoTransform;
         if (FVideoEffects.Enabled or FTransformConfig.Enabled) and (FrameGrabberRGBFormat > fgf_RGB24) then begin // cannot apply video effects
            if InsertGrabberFilter (OutputPin, gf_RGB, fgf_RGB24, @FGrabberHandlers[gh_DummyRGB], UseConnectionMediaType) then begin
               FGrabberHandlers[gh_DummyRGB].Control^.CanCaptureAndNotifyFrame := False; // only processing
               UseConnectionMediaType := nil;
            end;
         end;
      end;

      if not CreateGrabberFilter (GrabberFilterType, FrameGrabberRGBFormat, GrabberHandler, UseConnectionMediaType) then Exit;

      if F_CaptureGraphBuilder2.FindPin (GrabberHandler^.Grabber, PINDIR_INPUT, nil, nil, true, 0, FilterIn) <> S_OK then Exit;
      if F_CaptureGraphBuilder2.FindPin (GrabberHandler^.Grabber, PINDIR_OUTPUT, nil, nil, true, 0, FilterOut) <> S_OK then Exit;

      if assigned (UseConnectionMediaType) then begin
         if OutputPin.Connect (FilterIn, UseConnectionMediaType) <> S_OK then Exit;
      end
      else begin
         if not Connect (OutputPin, FilterIn) then Exit;
      end;

      OutputPin := nil;
      OutputPin := FilterOut;

      if GrabberFilterType = gf_RGB then begin
         if FSampleCapture_Video = sc_AfterOnDraw then begin
            if not InsertGrabberFilter (OutputPin, gf_Sample, FrameGrabberRGBFormat, @FGrabberHandlers[gh_SampleVideo], nil) then Exit;
         end;
      end;

      Result := True;
   finally
      if assigned (FilterIn) then FilterIn := nil;
      if assigned (FilterOut) then FilterOut := nil;
      if not Result then begin
         if assigned (GrabberHandler^.Grabber) then begin
            F_GraphBuilder.RemoveFilter (GrabberHandler^.Grabber);
            ClearGrabberHandler (GrabberHandler, False);
         end;
      end;
      LogB (not Result, LTRACE, e_failed, 'insert grabber filter');
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TVdgr.InsertThirdPartyFilters (Location: TThirdPartyFilterList; var OutputPin: IPin);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i: LongInt;
   Ok: Boolean;
   InPin: IPin;
   OutPin: IPin;
begin
   if not assigned (OutputPin) then Exit;

   for i := 0 to ThirdPartyFilterMaxCount - 1 do begin
      with FThirdPartyFilter[LongInt (Location), i] do begin
         if Enabled then begin
            if not _IsEqualGUID (@FilterGUID, @GUID_NULL) then begin
               if CreateInstance (@FilterGUID, IBaseFilter, Filter, 'create third party filter') then begin
                  Ok := AddFilter (Filter, SingleText(FilterName));
                  LogB (not Ok, LERROR, e_add_filter, 'cannot add ' + FilterName);
                  if Ok then begin
                     Ok := F_CaptureGraphBuilder2.FindPin (Filter, PINDIR_INPUT, nil, nil, true, 0, InPin) = S_OK;
                     LogB (not Ok, LERROR, e_pin_not_found, 'cannot find input pin: ' + FilterName);
                     if Ok then begin
                        Ok := F_CaptureGraphBuilder2.FindPin (Filter, PINDIR_OUTPUT, nil, nil, true, 0, OutPin) = S_OK;
                        LogB (not Ok, LERROR, e_pin_not_found, 'cannot find output pin: ' + FilterName);
                        if Ok then begin
                           Ok := Connect (OutputPin, InPin);
                           if Ok then begin
                              LogB (True, LINFO, i_third_party_filter_inserted, 'filter inserted on ' + sLocation (Location) + ':' + FilterName);
                              OutputPin := nil;
                              OutputPin := OutPin;
                              if Filter.QueryInterface (IUnknown, FilterIntf) = S_OK then begin
                                 if CanInvokeEvent (TPObj(Intf.FOnThirdPartyFilterConnected)) then Intf.FOnThirdPartyFilterConnected (Intf, Location, i, FilterIntf);
                                 FilterIntf := nil;
                              end;
                              if SavedFilterState then begin
                                 RestoreFilterState (Filter, ThirdPartyFilterRegKeyId (FilterGUID));
                              end;
                           end
                           else begin
                              LogB (True, LWARNING, w_cannot_connect_thirdparty_filter, 'cannot connect third-party filter ' + FilterName);
                           end;
                        end;
                     end;
                     if not Ok then begin
                        F_GraphBuilder.RemoveFilter (Filter);
                        Filter := nil;
                     end;
                  end;
               end;
               if assigned (InPin) then InPin := nil;
               if assigned (OutPin) then OutPin := nil;
            end;
         end;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.ConnectMPEGWriter: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{ builds the downstream part of the capture graph
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
{const
    MainConcept MPEG Encoder demo = {41918F50-ADF0-4FF6-882E-A6DBAD1A8C06
    MainConcept MPEG Encoder = {2BE4D150-6F2E-4B3A-B0BD-E880917238DC}
var
   CodecOk: Boolean;
   CodecGUID: TGUID;
   OleStr: pOleStr;
begin
   try
      Result := False;
      if FMPEGWriterFilter = '' then Exit;
      if assigned (F_AVIFileMux) then Exit;
      if FOutputFileName = '' then Exit;

      if FMPEGWriterFilter[1] = '{' then begin
         CodecGUID := StringToGUID (FMPEGWriterFilter);
         CodecOk := BindFilterFromCLSID (@CLSID_LegacyAmFilterCategory, @CodecGUID, FMPEGWriterBaseFilterName, F_AVIFileMux);
      end
      else begin
         CodecOk := BindFilterFromSubname (@CLSID_LegacyAmFilterCategory, FMPEGWriterFilter, FMPEGWriterBaseFilterName, F_AVIFileMux);
      end;

      if LogB (not CodecOk, LERROR, e_failed_to_bind_codec, 'MPEGWriterFilter not found: ' + FMPEGWriterFilter) then Exit;

      CodecOk := F_GraphBuilder.AddFilter (F_AVIFileMux, OleS(FMPEGWriterBaseFilterName, OleStr)) = S_OK;
      SysFreeString (OleStr);
      if LogB (not CodecOk, LERROR, e_failed_to_bind_codec, 'cannot bind MPEGWriterFilter: ' + FMPEGWriterBaseFilterName) then Exit;

      if F_AVIFileMux.QueryInterface (IFileSinkFilter, F_AVIFileSink) <> S_OK then Exit;
      if F_AVIFileSink.SetFileName (OleS(FOutputFileName, OleStr), nil) <> S_OK then Exit;
      SysFreeString (OleStr);

      Result := True;
   finally
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.IsLiveVideoSource: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := (FVideoSource = vs_VideoCaptureDevice)
   and (FMultiplexedRole <> mr_MultiplexedSlave)
   ;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.IsDVSource: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := IsLiveVideoSource and FVideoRegSave[_IsDigitalVideoIn].b;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.IsMPEGSource: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := IsLiveVideoSource and FVideoRegSave[_IsMpegStream].b;
end;


{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.IsASFRecordingOrStreaming: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := (FCurrent.NetworkStreaming in [ns_ASFStreamingToPublishingPoint, ns_ASFDirectNetworkStreaming])
     or (FGraphType in [cs_Recording, cs_Reencoding]) and (FCurrent.RecordingMethod in [rm_ASF, rm_Stream]);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function LoadProfileFromFile (FilePath: String; ms: TMemoryStream): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   fs: TFileStream;
begin
   Result := False;
   fs := nil;
   try
      if not assigned (ms) then Exit;
      fs := tfilestream.create (FilePath, fmOpenRead);
      ms.LoadFromStream (fs);
      Result := True;
   finally
      if assigned (fs) then begin
         fs.Free;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TVdgr.InsertASFFilter: Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
const
  AM_CONFIGASFWRITER_PARAM_AUTOINDEX = 0;
  AM_CONFIGASFWRITER_PARAM_MULTIPASS = 1;
  AM_CONFIGASFWRITER_PARAM_DONTCOMPRESS = 2;
var
   XML: TASFXML;
   pcXML: pOleStr;
   pwszUrl: POleStr;
   pcchURL: LongWord;
   pUrl: pOleStr;
   SinkCount: LongWord;
   Done: Boolean;
   ProfileSize: LongWord;
   ProfileBuffer: pWideChar;
   Profile: String;
   ProfileLoaded: Boolean;
   WMProfile: IWMProfile;
   WMProfileManager: IWMProfileManager;
   WMProfileManager2: IWMProfileManager2;
   WMWriterAdvanced2: IWMWriterAdvanced2;
   ServiceProvider: IServiceProvider;
   ConfigAsfWriter: IConfigAsfWriter2;
   DummySink: IWMWriterSink;
   NetworkOk: Boolean;
   HostNameAndPort: String;
   p: LongInt;
   ProfilesCount: LongWord;
   sProfilName: dword;
   pProfilName: pWideChar;
   NetworkPortUsed: LongWord;
   ms: TMemoryStream;
begin
   Result := True;

   XML := TASFXML.Create;

   pwszUrl := nil;
   pcXML := nil;
   FStreamingHostPort := 0;
   FStreamingHostName := '';

   try
      if not assigned (F_ASFFileMux) then Exit;

      if not LoadWMVASFNetLib then Exit;

      if Failed (WMCreateProfileManager (WMProfileManager)) then Exit;

      if Succeeded (WMProfileManager.QueryInterface (IWMProfileManager2, WMProfileManager2)) then begin
         WMProfileManager2.SetSystemProfileVersion (WMT_VER_8_0);
         WMProfileManager2 := nil;
      end;

      if Failed (F_ASFFileMux.QueryInterface(IConfigAsfWriter, ConfigAsfWriter)) then Exit;

      Profile := '';

      if FASFProfileFromCustomFile = '' then begin
         if FASFProfile = -1 then begin
            ProfileLoaded := Succeeded (ConfigASFWriter.GetCurrentProfile (WMProfile));
         end
         else begin
            if Failed (WMProfileManager.GetSystemProfileCount (ProfilesCount)) then Exit;
            if LogB ((FASFProfile < 0) or (FASFProfile >= LongInt (ProfilesCount)), LERROR, e_index_out_of_range, 'ASF profile index out of range') then Exit;
            ProfileLoaded := Succeeded (WMProfileManager.LoadSystemProfile (FASFProfile, WMProfile));
            if ProfileLoaded then begin
               if Succeeded (WMProfile.GetName (nil, sProfilName)) then begin
                  GetMem (pProfilName, sProfilName shl 1);
                  if Succeeded (WMProfile.GetName (pProfilName, sProfilName)) then begin
                     LogB (True, LINFO, i_using_ASF_Profile, 'using ASF profile: "' + pProfilName + '"');
                  end;
                  FreeMem (pProfilName);
               end;
            end;
         end;
      end
      else begin
         ms := TMemoryStream.Create;
         ProfileLoaded := LoadProfileFromFile (FASFProfileFromCustomFile, ms);
         if ProfileLoaded then begin
            ProfileLoaded := Succeeded (WMProfileManager.LoadProfileByData (ms.Memory, WMProfile));
         end;
         ms.free;
      end;
      if LogB (not ProfileLoaded, LERROR, e_failed_to_load_ASF_profile, 'failed to load ASF profile') then Exit;

      ProfileSize := 0;
      if Succeeded (WMProfileManager.SaveProfile (WMProfile, nil, ProfileSize)) then begin
         GetMem (ProfileBuffer, ProfileSize shl 1);
         if Succeeded (WMProfileManager.SaveProfile (WMProfile, ProfileBuffer, ProfileSize)) then begin
            Profile := ProfileBuffer;
         end;
         FreeMem (ProfileBuffer);
      end;
      if assigned (WMProfile) then WMProfile := nil;

      XML.ParseXML (Profile);

      if not XML.FilterStreams (FCurrent.VideoRecording, FCurrent.AudioRecording) then Exit;

      if FASFSettings.AudioBitRate <> -1 then begin
         XML.UpdateASFValue ('BitRate', IntToStr (FASFSettings.AudioBitRate), xdt_AudioStream);
      end;

      if FASFSettings.AudioChannels in [1..2] then begin
         XML.UpdateASFValue ('nChannels', IntToStr (FASFSettings.AudioChannels), xdt_AudioStream);
      end;

      if FASFSettings.VideoBitRate <> -1 then begin
         XML.UpdateASFValue ('BitRate', IntToStr (FASFSettings.VideoBitRate), xdt_VideoStream);
         XML.UpdateASFValue ('dwBitRate', IntToStr (FASFSettings.VideoBitRate), xdt_VideoStream);
      end;

      if (FASFSettings.VideoWidth >= 0) and (FASFSettings.VideoHeight >= 0) then begin
         XML.UpdateASFValue ('biwidth', IntToStr (FASFSettings.VideoWidth), xdt_VideoStream);
         XML.UpdateASFValue ('right', IntToStr (FASFSettings.VideoWidth), xdt_VideoStream);
         XML.UpdateASFValue ('biheight', IntToStr (FASFSettings.VideoHeight), xdt_VideoStream);
         XML.UpdateASFValue ('bottom', IntToStr (FASFSettings.VideoHeight), xdt_VideoStream);
      end;

      if FASFSettings.VideoQuality <> -1 then begin
         XML.UpdateASFValue ('Quality', IntToStr (FASFSettings.VideoQuality), xdt_VideoStream);
      end;

      if FASFSettings.VideoMaxKeyFrameSpacing <> -1 then begin
         XML.UpdateASFValue ('MaxKeyFrameSpacing', IntToStr (FASFSettings.VideoMaxKeyFrameSpacing), xdt_VideoStream);
      end;

      if not XML.GenerateXML then Exit;

      //msgx (XML.GetGeneratedXML);

      pcXML := StringTOOleStr (XML.GetGeneratedXML);
      if Succeeded (WMProfileManager.LoadProfileByData (pcXML, WMProfile)) then begin
         Result := Succeeded (ConfigAsfWriter.ConfigureFilterUsingProfile (WMProfile));
         WMProfile := nil;
      end;

      {
      if Succeeded(F_FileMux.QueryInterface(IFileSinkFilter, FileSinkFilter)) then begin
         FileSinkFilter.SetFileName('test.asf', nil);
         FileSinkFilter := nil;
      end;
      if not AddFilter (F_FileMux, 'ASF Filter') then Exit;

       NOT IMPLEMENTED FOR THE MOMENT
      if Succeeded(F_FileMux.QueryInterface(IConfigAsfWriter2, ConfigAsfWriter)) then begin
         ConfigAsfWriter.SetParam(AM_CONFIGASFWRITER_PARAM_AUTOINDEX, Cardinal(FAutoIndex), 0);
         ConfigAsfWriter.SetParam(AM_CONFIGASFWRITER_PARAM_MULTIPASS, Cardinal(FMultiPass), 0);
         ConfigAsfWriter.SetParam(AM_CONFIGASFWRITER_PARAM_DONTCOMPRESS, Cardinal(FDontCompress), 0);
      end;
      }

      if Failed (F_ASFFileMux.QueryInterface(IServiceProvider, ServiceProvider)) then Exit;
      if Failed  (ServiceProvider.QueryService(IWMWriterAdvanced2, IWMWriterAdvanced2, WMWriterAdvanced2)) then Exit;

      if FCurrent.RecordingMethod <> rm_ASF then begin
         Done := False;
         while not Done do begin
            if Failed (WMWriterAdvanced2.GetSinkCount (SinkCount)) then begin
               Done := True;
            end
            else begin
               if SinkCount = 0 then begin
                  Done := True;
               end
               else begin
                  if Succeeded (WMWriterAdvanced2.GetSink (0, DummySink)) then begin
                     if Failed (WMWriterAdvanced2.RemoveSink (DummySink)) then begin
                        Done := True;
                     end;
                     DummySink := nil;
                  end
                  else begin
                     Done := True;
                  end;
               end;
            end;
         end;
      end;

      WMWriterAdvanced2.SetLiveSource (True);

      if TASFDeinterlaceMode (FASFSettings.DeinterlaceMode) <> adm_NotInterlaced then begin
         WMWriterAdvanced2.SetInputSetting (0, 'DeinterlaceMode', WMT_TYPE_DWORD, @FASFSettings.DeinterlaceMode, sizeof (FASFSettings.DeinterlaceMode));
      end;

      if FASFSettings.JPEGCompressionQuality <> MAXDWORD then begin
         WMWriterAdvanced2.SetInputSetting (0, 'JPEGCompressionQuality', WMT_TYPE_DWORD, @FASFSettings.JPEGCompressionQuality, sizeof (FASFSettings.JPEGCompressionQuality));
      end;

      WMWriterAdvanced2.SetInputSetting (0, 'FixedFrameRate', WMT_TYPE_BOOL, @FASFSettings.FixedFrameRate, sizeof (FASFSettings.FixedFrameRate));

      if FCurrent.NetworkStreaming = ns_ASFStreamingToPublishingPoint then begin
         if Succeeded (WMCreateWriterPushSink (F_WMWriterPushSink)) then begin
            pwszUrl := StringToOleStr (FASFMediaServerPublishingPoint);
            { pwszUrl := StringToOleStr ('http://XP2600/Essai3'); // for testing purpose }
            Result := Succeeded (F_WMWriterPushSink.Connect (pwszUrl, nil, TRUE));
            if Result then begin
               Result := Succeeded (WMWriterAdvanced2.AddSink(F_WMWriterPushSink));
               LogB (Result, LINFO, i_streaming_to_publishing_point, 'streaming to "' + FASFMediaServerPublishingPoint + '"');
            end;
            if LogB (not Result, LERROR, e_failed_to_connect_to_server, 'failed to connect to publishing point "' + FASFMediaServerPublishingPoint + '"') then Exit;
         end;
      end
      else if FCurrent.NetworkStreaming = ns_ASFDirectNetworkStreaming then begin
         NetworkOk := Succeeded(WMCreateWriterNetworkSink(F_WMWriterNetworkSink));
         if NetworkOk then begin
            NetworkOk := Succeeded(F_WMWriterNetworkSink.SetNetworkProtocol(WMT_PROTOCOL_HTTP));
         end;
         if NetworkOk then begin
             NetworkOk := Succeeded(F_WMWriterNetworkSink.SetMaximumClients(FASFNetworkMaxUsers));
         end;
         if NetworkOk then begin
            NetworkPortUsed := FASFNetworkPort;
            NetworkOk := Succeeded(F_WMWriterNetworkSink.Open(NetworkPortUsed));
            if NetworkOk then begin
               FASFNetworkPort := NetworkPortUsed;
            end;
         end;
         if NetworkOk then begin
            NetworkOk := Succeeded(WMWriterAdvanced2.AddSink(F_WMWriterNetworkSink));
         end;
         if NetworkOk then begin
            if Succeeded(F_WMWriterNetworkSink.GetHostURL (nil, pcchURL)) then begin
               pUrl := SysAllocStringLen (nil, pcchURL shl 1);
               if Succeeded(F_WMWriterNetworkSink.GetHostURL (pUrl, pcchURL)) then begin
                  FStreamingUrl := pUrl;
                  p := pos ('http', FStreamingUrl);
                  if p = 1 then begin
                     HostNameAndPort := Copy (FStreamingUrl, 8, MAXINT);
                     FStreamingUrl := 'mms' + '://' + HostNameAndPort;
                     p := pos (':', HostNameAndPort);
                     if p > 0 then begin
                        FStreamingHostName := Copy (HostNameAndPort, 1, p - 1);
                        FStreamingHostPort := StrToIntDef (Copy (HostNameAndPort, p + 1, MAXINT), 0);
                     end;
                  end;
               end;
               SysFreeString (pUrl);
            end;
         end;
         if LogB (not NetworkOk, LERROR, e_failed_to_setup_network_streaming, 'failed to setup network streaming') then Exit;
      end;
      Result := True;

   finally
      if assigned (pcXML) then SysFreeString (pcXML);
      if assigned (pwszUrl) then SysFreeString (pwszUrl);
      if assigned (WMProfile) then WMProfile := nil;
      if assigned (WMProfileManager) then WMProfileManager := nil;
      if assigned (WMWriterAdvanced2) then WMWriterAdvanced2 := nil;
      if assigned (ServiceProvider) then ServiceProvider := nil;
      if assigned (ConfigAsfWriter) then ConfigAsfWriter := nil;
      if assigned (DummySink) then DummySink := nil;
      XML.Free;
      if Result then begin
         if FStreamingHostPort > 0 then begin
            PostEvent (@Intf.FOnDirectNetworkStreamingHostUrl);
         end;
      end;
   end;
end;

const
   DEFAULTLEVEL = 5;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
constructor TImplMotionDetector.Create;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
      SetCellCount (10, 10);
      FMotionRatio:= 0;
      ClearMotionResults;
      FCompareBlue := True;
      FCompareGreen := True;
      FGreyScale := False;
      FCompareRed := True;
      FEnabled := False;
      FMaxDetectionsPerSecond := 0;
      if FMaxDetectionsPerSecond > 0 then begin
         FMaxFrameTimeInterval100ns := Round (REFTIME_UNITS / FMaxDetectionsPerSecond);
      end
      else begin
         FMaxFrameTimeInterval100ns := 0;
      end;
      FLatestFrameTime := -1;
      FReduceCPULoad := 1;
      FReleaseFrame:= True;
      FReset:= False;
      FRGBSize := 0;
      FStepsFound:= False;
      FDialogBitmap := TBitmap.Create;
      FReduceVideoNoise := False;
      FChangedCompareCriterias:= True;
      FCurrentLevel := DEFAULTLEVEL;
      InitGrid (FCurrentLevel);
      FReduceCPULoadValue := 1;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
destructor TImplMotionDetector.Destroy;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FDialogBitmap.Free;
   inherited Destroy;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TImplMotionDetector.DetectMotion (OldDib, NewDib: pDibSection; NewFrameTime: int64): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   x,y : LongInt;
   pBm1, pBm2: LongWord;
   iX, iY: LongInt;
   Threshold: integer;
   MotionPixelsDetected: int64;
   MotionPixelsTotal: int64;
   DoneX, DoneY: Boolean;
   bmWidth, bmHeight, bmHeightBound: LongInt;
   MotionDetected: Boolean;
   ReduceCPULoadValueHorzStep: LongWord;
   FirstLinePixel: LongWord;
begin
      Result := False;

         MotionDetected := False;
         FMotionRatio := 0;
         if not FEnabled then Exit;

         if not assigned (NewDib) then Exit;

         bmWidth := NewDib^.dsBm.bmWidth;
         bmHeight := abs (NewDib^.dsBm.bmHeight);
         bmHeightBound := bmHeight - 1;

         if assigned (OldDib) then begin
            if (NewDib^.dsBm.bmWidth <> OldDib^.dsBm.bmWidth) or (NewDib^.dsBm.bmHeight <> OldDib^.dsBm.bmHeight) then begin
               FReset := True;
            end;
         end
         else begin
            FReset := True;
         end;

         if FReset then begin
            FLatestFrameTime := -1;
            FReset := False;

            if NewDib^.dsBm.bmBitsPixel = 24 then begin
               FRGBSize := 3;
            end
            else if NewDib^.dsBm.bmBitsPixel = 32 then begin
               FRGBSize := 4;
            end
            else begin
               Exit; // not supported
            end;

            CalculateReduceCPULoad (NewDib^.dsBm.bmWidth, bmHeight);
            if FGreyScale then begin
               ModifyColorsToGreyScale (NewDib, LongWord (NewDib^.dsBm.bmBits), bmWidth, bmHeight, bmHeightBound);
            end;
            if FReduceVideoNoise then begin
               DoReduceVideoNoiseImage (NewDib, LongWord (NewDib^.dsBm.bmBits), bmWidth, bmHeight, bmHeightBound);
            end;
            FindSteps (NewDib^.dsBm.bmWidth, abs(NewDib^.dsBm.bmHeight));
            Exit;
         end;

         FLatestFrameTime := NewFrameTime;

         if FGreyScale then begin
            ModifyColorsToGreyScale (NewDib, LongWord (NewDib^.dsBm.bmBits), bmWidth, bmHeight, bmHeightBound);
         end;
         if FReduceVideoNoise then begin
            DoReduceVideoNoiseImage (NewDib, LongWord (NewDib^.dsBm.bmBits), bmWidth, bmHeight, bmHeightBound);
         end;

         ReduceCPULoadValueHorzStep := FReduceCPULoadValue * FRGBSize;

         MotionPixelsDetected := 0;
         MotionPixelsTotal := 0;
         ClearMotionResults;

         iY := 0;

         y := 0;

         DoneY := False;
         while not DoneY do begin
            if y >= bmHeight then begin
               DoneY := True;
            end
            else begin
               if iY < FGridYBound then begin
                  if y > FInternalGrid.YStep[iY] then begin
                     inc (iY);
                  end;
               end;

               FirstLinePixel := LongWord(bmHeightBound - y) * LongWord(bmWidth) * FRGBSize;
               PBm1 := LongWord (NewDib^.dsBm.bmBits) + FirstLinePixel;
               PBm2 := LongWord (OldDib^.dsBm.bmBits) + FirstLinePixel;

               iX := 0;
               x := 0;
               DoneX := False;
               while not DoneX do begin
                  if x >= bmWidth then begin
                     DoneX := True;
                  end
                  else begin
                     if iX < FGridXBound then begin
                        if x > FInternalGrid.XStep[iX] then begin
                           inc (iX);
                        end;
                     end;

                     if FInternalGrid.Grid_0_9[iX, iY] > 0 then begin

                        inc (FInternalGrid.MotionPixelTotal[iX, iY]);

                        Threshold := FInternalGrid.Sensitivity_0_256[iX, iY];

                        if FGreyScale then begin
                           if (abs (pTBgr(pBm1)^[Bc] - pTBgr(pBm2)^[Bc]) > Threshold) then begin { GreyScale, 1 color is sufficient }
                              inc (FInternalGrid.MotionPixelDetected[iX, iY]);
                           end;
                        end
                        else begin
                           if (FCompareBlue  and (abs (pTBgr(pBm1)^[Bc] - pTBgr(pBm2)^[Bc]) > Threshold)) or
                            (FCompareGreen and (abs (pTBgr(pBm1)^[Gc] - pTBgr(pBm2)^[Gc]) > Threshold)) or
                            (FCompareRed   and (abs (pTBgr(pBm1)^[Rc] - pTBgr(pBm2)^[Rc]) > Threshold)) then begin
                              inc (FInternalGrid.MotionPixelDetected[iX, iY]);
                           end;
                        end;
                     end;
                     inc (MotionPixelsTotal, FInternalGrid.MotionPixelTotal[iX, iY]);
                     inc (MotionPixelsDetected, FInternalGrid.MotionPixelDetected[iX, iY]);
                     inc (pBm1, ReduceCPULoadValueHorzStep);
                     inc (pBm2, ReduceCPULoadValueHorzStep);
                     inc (x, FReduceCPULoadValue);
                  end;
               end;
               inc (y, FReduceCPULoadValue);
            end;
         end;

         if FChangedCompareCriterias then begin
            FChangedCompareCriterias := False;
         end
         else begin
            if MotionPixelsDetected > 0 then begin
               FMotionRatio:= MotionPixelsDetected / MotionPixelsTotal;
               MotionDetected := True;
            end;
         end;

         Result := MotionDetected;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.InitGrid (Level: integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i, j: integer;
   Mx: string;
begin
   Mx := '';
   for i := 0 to FGridYBound do begin
      for j := 0 to FGridXBound do begin
         Mx := Mx + Char (Level + 48);
      end;
      Mx := Mx + ' ';
   end;
   SetMotionDetector_Grid (Mx);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.GloballyIncOrDecSensitivity (Value: integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i, j: integer;
   Current: integer;
begin
   for i := 0 to FGridXBound do begin
      for j := 0 to FGridYBound do begin
         Current := FInternalGrid.Grid_0_9[i,j];
         if (Current > 0) and (((Value < 0) and  (Current > 1)) or ((Value > 0) and (Current < 9))) then begin
            Current := Current  + Value;
            if Current < 0 then begin
               Current := 0;
            end;
            if Current > 9 then begin
               Current := 0;
            end;
            SetInternalGridValue (i, j, Current);
         end;
      end;
   end;
   RebuildGridFromInternal;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.ResetGlobalSensitivity (Value: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i, j: integer;
begin
   if Value <= 9 then begin
      for i := 0 to FGridXBound do begin
         for j := 0 to FGridYBound do begin
            SetInternalGridValue (i, j, Value);
         end;
      end;
      RebuildGridFromInternal;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.SetInternalGridValue (i, j, Value_0_9: integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FInternalGrid.Grid_0_9[i, j] := Value_0_9;
   FInternalGrid.Sensitivity_0_256[i, j] := 256 - ((Value_0_9 * 56) shr 1); { = 256 - n * 28,4 }
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TImplMotionDetector.IsGridValid (Value: string): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   GridStringLen: integer;
   m: integer;
   i, j: integer;
   GridValid: Boolean;
begin
   GridStringLen := (FGridXSize * FGridYSize) + FGridYSize - 1; { 109 for 10 }
   Value := Trim (Copy (Value, 1, GridStringLen));

   GridValid := False;

   if length (Value) = GridStringLen then begin
      GridValid := True;
      m := 1;
      for j := 0 to FGridYBound do begin
         for i := 0 to FGridXBound do begin
            if (Value[m] < '0') or (Value[m] > '9') then begin
               GridValid := False;
            end;
            inc (m);
         end;
         if j < FGridYBound then begin
            if Value[m] <> ' ' then begin
               GridValid := False;
            end;
         end;
         inc (m);
      end;
   end;
   Result := GridValid;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.SetMotionDetector_Grid (Value: string);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i, j: integer;
   Value_0_9: integer;
   m: integer;
begin
   FIsGridValid := IsGridValid (Value);

   if Value = FGrid then Exit;

   if not FIsGridValid then Exit;

   FGrid := Value;

   m := 1;
   for j := 0 to FGridYBound do begin
      for i := 0 to FGridXBound do begin
         Value_0_9 := ord(Value[m]) - 48;
         SetInternalGridValue (i, j, Value_0_9);
         inc (m);
      end;
      inc (m);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure Init2DArray (var IntArray2D: T2DIntArray; X, Y: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
  i : Integer;
begin
  SetLength(IntArray2D, x);
  for i := Low(IntArray2D) to High(IntArray2D) do begin
     SetLength(IntArray2D[i], y);
  end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TImplMotionDetector.SetCellCount (ValueX, ValueY: integer): Boolean;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Result := False;

   if (ValueX < 1) or (ValueY < 1) then begin
      Exit;
   end;

   Result := True;

   if (FGridXSize = ValueX) and (FGridYSize = ValueY) then Exit;

   FGridXSize := ValueX;
   FGridYSize := ValueY;

   FGridXBound := ValueX - 1;
   FGridYBound := ValueY - 1;

   with FInternalGrid do begin
      SetLength (Grid_0_9, FGridXSize, FGridYSize);
      SetLength (MotionPixelDetected, FGridXSize, FGridYSize);
      SetLength (MotionPixelTotal, FGridXSize, FGridYSize);
      SetLength (Sensitivity_0_256, FGridXSize, FGridYSize);
      SetLength (xStep, FGridXSize);
      SetLength (yStep, FGridYSize);
   end;
   InitGrid (FCurrentLevel);
   //if assigned (FCurrentBitmap) then begin
   //   FindSteps;
   //end;
   FChangedCompareCriterias := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.RebuildGridFromInternal;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i, j: integer;
begin
   FGrid := '';
   for j := 0 to FGridYBound do begin
      for i := 0 to FGridXBound do begin
          FGrid := FGrid + Char (FInternalGrid.Grid_0_9[i, j] + 48);
      end;
      if j < FGridYBound then begin
         FGrid := FGrid + ' ';
      end;
   end;
   FIsGridValid := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.CalculateReduceCPULoad (Width, Height: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FReduceCPULoad > 0 then begin
      FReduceCPULoadValue := FReduceCPULoad;
   end
   else begin
      if (Width > 639) or (Height > 479) then begin
         FReduceCPULoadValue := 8;
      end
      else if (Width > 419) or (Height > 249) then begin
         FReduceCPULoadValue := 6;
      end
      else if (Width > 159) or (Height > 119) then begin
         FReduceCPULoadValue := 4;
      end
      else begin
         FReduceCPULoadValue := 2;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.DisplayGrid (Canvas: TCanvas; w, h, xstep, ystep, NoBorderMargin: integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   x,y : Integer;
   DoneX, DoneY: Boolean;
   TopX, TopY: Integer;
begin
         TopX := w - NoBorderMargin;
         TopY := h - NoBorderMargin;
         Canvas.Pen.Color := clWhite;
         y := yStep;
         DoneY := False;
         while not DoneY do begin
            if y >= h then begin
               DoneY := True;
            end
            else begin
               if y < TopY then begin
                  Canvas.MoveTo (0, y);
                  Canvas.LineTo (w - 1, y);
               end;
               inc (y, yStep);
            end;
         end;
         x := xStep;
         DoneX := False;
         while not DoneX do begin
            if x >= w then begin
               DoneX := True;
            end
            else begin
               if x < TopX then begin
                  Canvas.MoveTo (x, 0);
                  Canvas.LineTo (x, y - 1);
               end;
               inc (x, xStep);
            end;
         end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure BmTextParams (xWidth, yHeight: Double; var FontSize, xShift, yShift: integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   xCenter, yCenter: Double;
begin
   xCenter := xWidth / 2;
   yCenter := yHeight / 2;
   if xWidth < 20 then begin
      FontSize := 7;
      xCenter := xCenter - 2;
      yCenter := yCenter - 5;
   end
   else if xWidth < 30 then begin
      FontSize := 8;
      xCenter := xCenter - 3;
      yCenter := yCenter - 8;
   end
   else if xWidth < 40 then begin
      FontSize := 10;
      xCenter := xCenter - 4;
      yCenter := yCenter - 8;
   end
   else if xWidth < 50 then begin
      FontSize := 12;
      xCenter := xCenter - 4;
      yCenter := yCenter - 8;
   end
   else begin
      FontSize := 14;
      xCenter := xCenter - 4;
      yCenter := yCenter - 8;
   end;
   if xCenter < 0 then begin
      xCenter := 1;
   end;
   if yCenter < 0 then begin
      yCenter := 1;
   end;
   xShift := Round (xCenter);
   yShift := Round (yCenter);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.DisplayCoefs (Canvas: TCanvas; w, h, xsize, ysize, xstep, ystep: integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   x, y: integer;
   xShift, yShift: integer;
   FontSize: integer;
begin
   Canvas.Font.Name := 'Courier New';
   Canvas.Brush.Color := clDkGray;
   Canvas.Font.Color := clWhite;
   BmTextParams (xStep, yStep, FontSize, xShift, yShift);
   Canvas.Font.Size  := FontSize;
   for x := 0 to xSize - 1 do begin
       for y := 0 to ySize - 1 do begin
          Canvas.TextOut (Round (x * xStep) + xShift, Round (y * yStep) + yShift, inttostr (DlgDet.FInternalGrid.Grid_0_9[x, y]));
       end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.FindSteps (Width, Height: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   x, y: integer;
begin
   FStepsFound := False;
   if Width = 0 then Exit;
   if Height = 0 then Exit;

   FInternalGrid.xCount := Width / FGridXSize;
   FInternalGrid.yCount := Height / FGridYSize;
   for x := 0 to FGridXSize - 2 do begin
      FInternalGrid.xStep[x] := Round (FInternalGrid.xCount * (x+1));
   end;
   FInternalGrid.xStep[FGridXSize - 1] := MAXINT;

   for y := 0 to FGridYSize - 2 do begin
      FInternalGrid.yStep[y] := Round (FInternalGrid.yCount * (y+1));
   end;
   FInternalGrid.yStep[FGridYSize - 1] := MAXINT;

   FStepsFound := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.DoReduceVideoNoiseImage (DIB: pDibSection; BitmapBits: LongWord; Width, Height, HeightBound: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TmpBitmap: HBitmap;
   TmpBitmapBits: Pointer;
begin
   TmpBitmap := CreateDIBSection (0, PBitmapInfo (@DIB.dsBmih)^, DIB_RGB_COLORS, TmpBitmapBits, 0, 0);
   if TmpBitmap = 0 then Exit;
   Windows.CopyMemory (TmpBitmapBits, Pointer(BitmapBits), DIB.dsBmih.BiSizeImage);
   ReduceVideoNoiseImage (LongWord (TmpBitmapBits), DIB, BitmapBits, Width, Height, HeightBound);
   DeleteObject (TmpBitmap);
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.ReduceVideoNoiseImage (SrcBitmapBits: LongWord; DestDIB: pDibSection; DestBitmapBits: LongWord; Width, Height, HeightBound: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   x,y : Integer;

   pS_Prev, pS_Curr, pS_Next: LongWord;
   pD_Prev, pD_Curr, pD_Next: LongWord;

   CurrentLineFirstPixel: LongWord;
   iMax: integer;
   LineWidth: LongWord;
begin
   if Height < 3 then Exit;
   if Width < 3 then Exit;

   pS_Curr := 0;
   pS_Next := 0;
   pD_Curr := 0;

   LineWidth := LongWord(Width) * FRGBSize;

   for y := 0 to HeightBound do begin

      CurrentLineFirstPixel := LongWord(y * Width) * FRGBSize;
      pS_Prev := SrcBitmapBits + CurrentLineFirstPixel;
      pD_Prev := DestBitmapBits + CurrentLineFirstPixel;

      iMax := Width - 4;

      for x := 0 to iMax do begin

         pS_Curr := pS_Prev + FRGBSize;
         pS_Next := pS_Curr + FRGBSize;

         if x = 0 then begin
            pTBgr(pD_Prev)^[Bc] := (pTBgr(pS_Prev)^[Bc] + pTBgr(pS_Curr)^[Bc]) div 3;
            pTBgr(pD_Prev)^[Gc] := (pTBgr(pS_Prev)^[Gc] + pTBgr(pS_Curr)^[Gc]) div 3;
            pTBgr(pD_Prev)^[Rc] := (pTBgr(pS_Prev)^[Rc] + pTBgr(pS_Curr)^[Rc]) div 3;
         end;

         pD_Curr := pD_Prev + FRGBSize;

         pTBgr(pD_Curr)^[Bc] := (pTBgr(pS_Prev)^[Bc] + pTBgr(pS_Curr)^[Bc] + pTBgr(pS_Next)^[Bc]) div 3;
         pTBgr(pD_Curr)^[Gc] := (pTBgr(pS_Prev)^[Gc] + pTBgr(pS_Curr)^[Gc] + pTBgr(pS_Next)^[Gc]) div 3;
         pTBgr(pD_Curr)^[Rc] := (pTBgr(pS_Prev)^[Rc] + pTBgr(pS_Curr)^[Rc] + pTBgr(pS_Next)^[Rc]) div 3;

         pS_Prev := pS_Curr;
         pD_Prev := pD_Curr;
      end;

      { last pD_Next for x = iMax }
      pD_Next := pD_Curr + FRGBSize;
      pTBgr(pD_Next)^[Bc] := (pTBgr(pS_Next)^[Bc] + pTBgr(pS_Curr)^[Bc]) div 3;
      pTBgr(pD_Next)^[Gc] := (pTBgr(pS_Next)^[Gc] + pTBgr(pS_Curr)^[Gc]) div 3;
      pTBgr(pD_Next)^[Rc] := (pTBgr(pS_Next)^[Rc] + pTBgr(pS_Curr)^[Rc]) div 3;
   end;

   iMax := Height - 4;
   for y := 0 to iMax do begin

      CurrentLineFirstPixel := LongWord (y * Width) * FRGBSize;

      pS_Prev := SrcBitmapBits + CurrentLineFirstPixel;
      pS_Curr := SrcBitmapBits + CurrentLineFirstPixel + LineWidth;
      pS_Next := SrcBitmapBits + CurrentLineFirstPixel + (LineWidth shl 1);

      pD_Prev := DestBitmapBits + CurrentLineFirstPixel;
      pD_Curr := DestBitmapBits + CurrentLineFirstPixel + LineWidth;
      pD_Next := DestBitmapBits + CurrentLineFirstPixel + (LineWidth shl 1);

      for x := 0 to Width - 1 do begin

         pTBgr(pD_Curr)^[Bc] := (pTBgr(pS_Prev)^[Bc] + pTBgr(pS_Curr)^[Bc] + pTBgr(pS_Next)^[Bc]) div 3;
         pTBgr(pD_Curr)^[Gc] := (pTBgr(pS_Prev)^[Gc] + pTBgr(pS_Curr)^[Gc] + pTBgr(pS_Next)^[Gc]) div 3;
         pTBgr(pD_Curr)^[Rc] := (pTBgr(pS_Prev)^[Rc] + pTBgr(pS_Curr)^[Rc] + pTBgr(pS_Next)^[Rc]) div 3;

         if y = 0 then begin
            pTBgr(pD_Prev)^[Bc] := (pTBgr(pS_Prev)^[Bc] + pTBgr(pS_Curr)^[Bc]) div 3;
            pTBgr(pD_Prev)^[Gc] := (pTBgr(pS_Prev)^[Gc] + pTBgr(pS_Curr)^[Gc]) div 3;
            pTBgr(pD_Prev)^[Rc] := (pTBgr(pS_Prev)^[Rc] + pTBgr(pS_Curr)^[Rc]) div 3;
         end
         else if y = iMax then begin
            pTBgr(pD_Next)^[Bc] := (pTBgr(pS_Next)^[Bc] + pTBgr(pS_Curr)^[Bc]) div 3;
            pTBgr(pD_Next)^[Gc] := (pTBgr(pS_Next)^[Gc] + pTBgr(pS_Curr)^[Gc]) div 3;
            pTBgr(pD_Next)^[Rc] := (pTBgr(pS_Next)^[Rc] + pTBgr(pS_Curr)^[Rc]) div 3;
         end;

         inc (pS_Prev, FRGBSize);
         inc (pS_Curr, FRGBSize);
         inc (pS_Next, FRGBSize);

         inc (pD_Prev, FRGBSize);
         inc (pD_Curr, FRGBSize);
         inc (pD_Next, FRGBSize);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.ModifyColorsToGreyScale (DIB: pDibSection; BitmapBits: LongWord; Width, Height, HeightBound: LongInt);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   x,y : Integer;
   pBm1: LongWord;
   Grey: Byte;
   DoneX, DoneY: Boolean;
begin
   y := 0;
   DoneY := False;
   while not DoneY do begin
      if y >= Height then begin
         DoneY := True;
      end
      else begin
         PBm1 := BitmapBits + (LongWord (y * Width) * FRGBSize);
         DoneX := False;
         x := 0;

         while not DoneX do begin
            if x >= Width then begin
               DoneX := True;
            end
            else begin
               Grey := (pTBgr(pBm1)^[Bc] + pTBgr(pBm1)^[Gc] + pTBgr(pBm1)^[Rc]) div 3;
               pTBgr(pBm1)^[Bc] := Grey;
               pTBgr(pBm1)^[Gc] := Grey;
               pTBgr(pBm1)^[Rc] := Grey;
               inc (pBm1, FRGBSize);
               inc (x, FReduceCPULoadValue);
            end;
         end;
         inc (y, FReduceCPULoadValue);
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TImplMotionDetector.ClearMotionResults;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   i, j: integer;
begin
   FMotionRatio:= 0;
   for j := 0 to FGridYBound do begin
      for i := 0 to FGridXBound do begin
         FInternalGrid.MotionPixelDetected[i, j] := 0;
         FInternalGrid.MotionPixelTotal[i, j] := 0;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.ImgGridWndProc(var Message: TMessage);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   FimgGridProc (Message);
   case Message.Msg of
      WM_WINDOWPOSCHANGED: begin
         RedrawMatricedBitmap;
      end;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.btnOKClick(Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   btnOK.Tag := 1;
   Close;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.updCurrentLevelClick(Sender: TObject; Button: TUDBtnType);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   DlgDet.FCurrentLevel := updCurrentLevel.Position;
   popSetLevel.Items[DlgDet.FCurrentLevel - 1].Checked := True;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.FindBestCurrentLevel;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   n: integer;
   Sum: integer;
   x, y: integer;
begin
 with DlgDet do begin
   n := 0;
   Sum := 0;
   for x := 0 to FGridXBound do begin
      for y := 0 to FGridYBound do begin
         if FInternalGrid.Grid_0_9[x, y] <> 0 then begin
            inc (Sum, FInternalGrid.Grid_0_9[x, y]);
            inc (n);
         end;
      end;
   end;
   if n > 0 then begin
      FCurrentLevel := Round (Sum / n);
   end
   else begin
      FCurrentLevel := DEFAULTLEVEL;
   end;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.UpdatePopup(Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   Case TMenuItem(Sender).Tag of
      1: N11.Checked := True;
      2: N21.Checked := True;
      3: N31.Checked := True;
      4: N41.Checked := True;
      5: N51.Checked := True;
      6: N61.Checked := True;
      7: N71.Checked := True;
      8: N81.Checked := True;
      9: N91.Checked := True;
   end;
   DlgDet.FCurrentLevel := TMenuItem(Sender).Tag;
   updCurrentLevel.Position := DlgDet.FCurrentLevel;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.btnClearAllClick(Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
 with DlgDet do begin
   InitGrid (0);
   RedrawMatricedBitmap;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.RedrawMatricedBitmap;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   TempBitmap: TBitmap;
   xStep, yStep: Integer;
   GridXsize, GridYsize: Integer;
begin
   if ImgGrid.Width < 20 then Exit;
   if ImgGrid.Height < 20 then Exit;
   TempBitmap := TBitmap.Create;
   TempBitmap.Width := ImgGrid.Width;
   TempBitmap.Height := ImgGrid.Height;
   TempBitmap.Canvas.StretchDraw(Rect (0, 0, TempBitmap.Width - 1, TempBitmap.Height - 1), DlgDet.FDialogBitmap);

   GridXsize := DlgDet.FGridXSize;
   GridYsize := DlgDet.FGridXSize;

   xStep := Round (TempBitmap.Width / GridXSize);
   yStep := Round (TempBitmap.Height / GridYSize);

   DisplayGrid (TempBitmap.Canvas, TempBitmap.Width, TempBitmap.Height, xStep, yStep, 5);
   DisplayCoefs (TempBitmap.Canvas, TempBitmap.Width, TempBitmap.Height, GridXSize, GridYSize, xStep, yStep);
   ImgGrid.Picture.Assign (TempBitmap);
   TempBitmap.Free;
   DlgDet.RebuildGridFromInternal;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.btnEnableAllClick(Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
 with DlgDet do begin
   InitGrid (FCurrentLevel);
   RedrawMatricedBitmap;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.updGlobalLevelClick(Sender: TObject; Button: TUDBtnType);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   Increment: integer;
begin
 with DlgDet do begin
   if Button = btNext then begin
      Increment := 1;
   end
   else begin
      Increment := -1;
   end;
   DlgDet.GloballyIncOrDecSensitivity (Increment);
   RedrawMatricedBitmap;
 end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.btnCancelClick(Sender: TObject);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   btnOK.Tag := 0;
   Close;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
function TfrmGridDialog.SetOrRetrieveGridValueFromFrameCoordinates (x, y, FrameWidth, FrameHeight: word; SetValue: Integer = -1): word;
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   xGrid, yGrid: LongInt;
   RetrievedValue: LongInt;
begin
   Result := 0;
   xGrid := x div Round (FrameWidth / DlgDet.FGridXSize);
   yGrid := y div Round (FrameHeight / DlgDet.FGridYSize);
   if SetValue = -1 then begin
      if DlgDet.GetCellSensitivity (xGrid, yGrid, RetrievedValue) then begin
         Result := RetrievedValue;
      end;
   end
   else begin
      DlgDet.SetCellSensitivity (xGrid, yGrid, SetValue);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.imgGridMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if Button = mbLeft then begin
      if not assigned (DlgDet) then Exit;
      FMouseXY.x := x;
      FMouseXY.y := y;
      FMouseDown := True;
      FMouseMoved := False;
      FMouseDownClickValue := SetOrRetrieveGridValueFromFrameCoordinates (x, y, ImgGrid.Width, ImgGrid.Height, -1);
   end
   else if Button = mbRight then begin
      popSetLevel.Popup (Mouse.CursorPos.x, Mouse.CursorPos.y);
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.imgGridMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
begin
   if FMouseDown then begin
      FMouseMoved := True;
      SetOrRetrieveGridValueFromFrameCoordinates (x, y, ImgGrid.Width, ImgGrid.Height, FMouseDownClickValue);
      RedrawMatricedBitmap;
   end;
end;

{………………………………………………………………………………………………………………………………………………………………………………………………………………}
procedure TfrmGridDialog.imgGridMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
{………………………………………………………………………………………………………………………………………………………………………………………………………………}
var
   CurValue: word;
begin
   if Button = mbLeft then begin
      if not FMouseMoved then begin
         CurValue := SetOrRetrieveGridValueFromFrameCoordinates (x, y, ImgGrid.Width, ImgGrid.Height, -1);
         if CurValue = 0 then begin
            SetOrRetrieveGridValueFromFrameCoordinates (x, y, ImgGrid.Width, ImgGrid.Height, DlgDet.FCurrentLevel);
         end
         else begin
            SetOrRetrieveGridValueFromFrameCoordinates (x, y, ImgGrid.Width, ImgGrid.Height, 0);
         end;
      end;
      RedrawMatricedBitmap;
   end;
   FMouseDown := False;
end;


var
   DummySyncManager: TSyncManager = nil;

initialization

finalization
     if assigned (_SyncManager) then begin
        DummySyncManager := _SyncManager;
        _SyncManager := nil;
        DummySyncManager.Free;
     end;
     if assigned (FLog) then begin
        FLog.Free;
        FLog := nil;
     end;
end.





